'use client';
import * as React from 'react';
import { useContext, useRef, useMemo, useCallback, cloneElement } from 'react';
import classNames from 'classnames';
import PropTypes from 'prop-types';
import BaseOverlay from '@restart/ui/Overlay';
import { componentOrElement, elementType } from 'prop-types-extra';
import useMergedRefs from '@restart/hooks/useMergedRefs';
import hasClass from 'dom-helpers/hasClass';
import createWithBsPrefix from '../utils/createWithBsPrefix';
import { getOverlayDirection } from '../utils/helpers';
import { ENTERING, ENTERED } from 'react-transition-group/Transition';
import transitionEndListener from '../utils/transitionEndListener';
import triggerBrowserReflow from '../utils/triggerBrowserReflow';
import TransitionWrapper from '../utils/TransitionWrapper';
import safeFindDOMNode from '../utils/safeFindDOMNode';
import contains from 'dom-helpers/contains';
import useTimeout from '@restart/hooks/useTimeout';
import warning from 'warning';
import { useUncontrolledProp } from 'uncontrollable';

const ThemeContext = React.createContext({ prefixes: {} });
({
    prefixes: PropTypes.object,
    dir: PropTypes.string,
});
function useBootstrapPrefix(prefix, defaultPrefix) {
    const { prefixes } = useContext(ThemeContext);
    return prefix || prefixes[defaultPrefix] || `${defaultPrefix}`;
}
// `sgds-${defaultPrefix}`
function useIsRTL() {
    const { dir } = useContext(ThemeContext);
    return dir === 'rtl';
}
React.forwardRef(({ as: Tag = 'div', ...props }, ref) => {
    return React.createElement(Tag, { ref: ref, ...props, className: classNames(props.className, 'sgds') });
});

var PopoverHeader = createWithBsPrefix('popover-header');

var PopoverBody = createWithBsPrefix('popover-body');

const propTypes$3 = {
    /**
     * @default 'popover'
     */
    bsPrefix: PropTypes.string,
    /**
     * An html id attribute, necessary for accessibility
     * @type {string}
     * @required
     */
    id: PropTypes.string,
    /**
     * Sets the direction the Popover is positioned towards.
     *
     * > This is generally provided by the `Overlay` component positioning the popover
     */
    placement: PropTypes.oneOf([
        'auto-start',
        'auto',
        'auto-end',
        'top-start',
        'top',
        'top-end',
        'right-start',
        'right',
        'right-end',
        'bottom-end',
        'bottom',
        'bottom-start',
        'left-end',
        'left',
        'left-start',
    ]),
    /**
     * An Overlay injected set of props for positioning the popover arrow.
     *
     * > This is generally provided by the `Overlay` component positioning the popover
     */
    arrowProps: PropTypes.shape({
        ref: PropTypes.any,
        style: PropTypes.object,
    }),
    /**
     * When this prop is set, it creates a Popover with a Popover.Body inside
     * passing the children directly to it
     */
    body: PropTypes.bool,
    /** @private */
    popper: PropTypes.object,
    /** @private */
    show: PropTypes.bool,
    hasArrow: PropTypes.bool,
};
const defaultProps$3 = {
    placement: 'right',
};
const Popover = React.forwardRef(({ bsPrefix, placement, className, style, children, body, arrowProps, hasArrow = false, popper: _, show: _1, ...props }, ref) => {
    const decoratedBsPrefix = useBootstrapPrefix(bsPrefix, 'popover');
    const isRTL = useIsRTL();
    const [primaryPlacement] = placement?.split('-') || [];
    const bsDirection = getOverlayDirection(primaryPlacement, isRTL);
    return (React.createElement("div", { ref: ref, role: "tooltip", style: style, "x-placement": primaryPlacement, className: classNames(className, decoratedBsPrefix, primaryPlacement && `bs-popover-${bsDirection}`), ...props },
        hasArrow && React.createElement("div", { className: "popover-arrow", ...arrowProps }),
        React.createElement(React.Fragment, null,
            " ",
            children)));
});
Popover.defaultProps = defaultProps$3;
Popover.propTypes = propTypes$3;
var Popover$1 = Object.assign(Popover, {
    Header: PopoverHeader,
    Body: PopoverBody,
    // Default popover offset.
    // https://github.com/twbs/bootstrap/blob/5c32767e0e0dbac2d934bcdee03719a65d3f1187/js/src/popover.js#L28
    POPPER_OFFSET: [0, 8],
});

// This is meant for internal use.
// This applies a custom offset to the overlay if it's a popover.
function useOverlayOffset(customOffset) {
    const overlayRef = useRef(null);
    const popoverClass = useBootstrapPrefix(undefined, 'popover');
    const offset = useMemo(() => ({
        name: 'offset',
        options: {
            offset: () => {
                if (overlayRef.current &&
                    hasClass(overlayRef.current, popoverClass)) {
                    return customOffset || Popover$1.POPPER_OFFSET;
                }
                return customOffset || [0, 0];
            },
        },
    }), [customOffset, popoverClass]);
    return [overlayRef, [offset]];
}

const propTypes$2 = {
    /**
     * Show the component; triggers the fade in or fade out animation
     */
    in: PropTypes.bool,
    /**
     * Wait until the first "enter" transition to mount the component (add it to the DOM)
     */
    mountOnEnter: PropTypes.bool,
    /**
     * Unmount the component (remove it from the DOM) when it is faded out
     */
    unmountOnExit: PropTypes.bool,
    /**
     * Run the fade in animation when the component mounts, if it is initially
     * shown
     */
    appear: PropTypes.bool,
    /**
     * Duration of the fade animation in milliseconds, to ensure that finishing
     * callbacks are fired even if the original browser transition end events are
     * canceled
     */
    timeout: PropTypes.number,
    /**
     * Callback fired before the component fades in
     */
    onEnter: PropTypes.func,
    /**
     * Callback fired after the component starts to fade in
     */
    onEntering: PropTypes.func,
    /**
     * Callback fired after the has component faded in
     */
    onEntered: PropTypes.func,
    /**
     * Callback fired before the component fades out
     */
    onExit: PropTypes.func,
    /**
     * Callback fired after the component starts to fade out
     */
    onExiting: PropTypes.func,
    /**
     * Callback fired after the component has faded out
     */
    onExited: PropTypes.func,
    /**
     * You must provide a single JSX child element to this component and that element cannot be a \<React.Fragment\>
     */
    children: PropTypes.element.isRequired,
    /**
     * Applies additional specified classes during the transition. Takes an object
     * where the keys correspond to the Transition status
     */
    transitionClasses: PropTypes.object,
};
const defaultProps$2 = {
    in: false,
    timeout: 300,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
};
const fadeStyles = {
    [ENTERING]: 'show',
    [ENTERED]: 'show',
};
const Fade = React.forwardRef(({ className, children, transitionClasses = {}, ...props }, ref) => {
    const handleEnter = useCallback((node, isAppearing) => {
        triggerBrowserReflow(node);
        props.onEnter?.(node, isAppearing);
    }, [props]);
    return (React.createElement(TransitionWrapper, { ref: ref, addEndListener: transitionEndListener, ...props, onEnter: handleEnter, childRef: children.ref }, (status, innerProps) => React.cloneElement(children, {
        ...innerProps,
        className: classNames('fade', className, children.props.className, 
        //@ts-ignore
        fadeStyles[status], transitionClasses[status]),
    })));
});
Fade.propTypes = propTypes$2;
Fade.defaultProps = defaultProps$2;
Fade.displayName = 'Fade';

const propTypes$1 = {
    /**
     * A component instance, DOM node, or function that returns either.
     * The `container` element will have the Overlay appended to it via a React portal.
     */
    container: PropTypes.oneOfType([componentOrElement, PropTypes.func]),
    /**
     * A component instance, DOM node, or function that returns either.
     * The overlay will be positioned in relation to the `target`
     */
    target: PropTypes.oneOfType([componentOrElement, PropTypes.func]),
    /**
     * Set the visibility of the Overlay
     */
    show: PropTypes.bool,
    /**
     * A set of popper options and props passed directly to Popper.
     */
    popperConfig: PropTypes.object,
    /**
     * Specify whether the overlay should trigger onHide when the user clicks outside the overlay
     */
    rootClose: PropTypes.bool,
    /**
     * Specify event for triggering a "root close" toggle.
     */
    rootCloseEvent: PropTypes.oneOf(['click', 'mousedown']),
    /**
     * A callback invoked by the overlay when it wishes to be hidden. Required if
     * `rootClose` is specified.
     */
    onHide: PropTypes.func,
    /**
     * Animate the entering and exiting of the Overlay. `true` will use the `<Fade>` transition,
     * or a custom react-transition-group `<Transition>` component can be provided.
     */
    transition: PropTypes.oneOfType([PropTypes.bool, elementType]),
    /**
     * Callback fired before the Overlay transitions in
     */
    onEnter: PropTypes.func,
    /**
     * Callback fired as the Overlay begins to transition in
     */
    onEntering: PropTypes.func,
    /**
     * Callback fired after the Overlay finishes transitioning in
     */
    onEntered: PropTypes.func,
    /**
     * Callback fired right before the Overlay transitions out
     */
    onExit: PropTypes.func,
    /**
     * Callback fired as the Overlay begins to transition out
     */
    onExiting: PropTypes.func,
    /**
     * Callback fired after the Overlay finishes transitioning out
     */
    onExited: PropTypes.func,
    /**
     * The placement of the Overlay in relation to it's `target`.
     */
    placement: PropTypes.oneOf([
        'auto-start',
        'auto',
        'auto-end',
        'top-start',
        'top',
        'top-end',
        'right-start',
        'right',
        'right-end',
        'bottom-end',
        'bottom',
        'bottom-start',
        'left-end',
        'left',
        'left-start',
    ]),
};
const defaultProps$1 = {
    transition: Fade,
    rootClose: false,
    show: false,
    placement: 'top',
};
function wrapRefs(props, arrowProps) {
    const { ref } = props;
    const { ref: aRef } = arrowProps;
    props.ref = ref.__wrapped || (ref.__wrapped = (r) => ref(safeFindDOMNode(r)));
    arrowProps.ref =
        aRef.__wrapped || (aRef.__wrapped = (r) => aRef(safeFindDOMNode(r)));
}
const Overlay = React.forwardRef(({ children: overlay, transition, popperConfig = {}, ...outerProps }, outerRef) => {
    const popperRef = useRef({});
    const [ref, modifiers] = useOverlayOffset(outerProps.offset);
    const mergedRef = useMergedRefs(outerRef, ref);
    const actualTransition = transition === true ? Fade : transition || undefined;
    return (React.createElement(BaseOverlay, { ...outerProps, ref: mergedRef, popperConfig: {
            ...popperConfig,
            modifiers: modifiers.concat(popperConfig.modifiers || []),
        }, 
        //@ts-ignore
        transition: actualTransition }, (overlayProps, { arrowProps, popper: popperObj, show }) => {
        wrapRefs(overlayProps, arrowProps);
        // Need to get placement from popper object, handling case when overlay is flipped using 'flip' prop
        const updatedPlacement = popperObj?.placement;
        const popper = Object.assign(popperRef.current, {
            state: popperObj?.state,
            scheduleUpdate: popperObj?.update,
            placement: updatedPlacement,
            outOfBoundaries: popperObj?.state?.modifiersData.hide?.isReferenceHidden || false,
        });
        if (typeof overlay === 'function')
            return overlay({
                ...overlayProps,
                placement: updatedPlacement,
                show,
                ...(!transition && show && { className: 'show' }),
                popper,
                arrowProps,
            });
        return React.cloneElement(overlay, {
            ...overlayProps,
            placement: updatedPlacement,
            arrowProps,
            popper,
            className: classNames(overlay.props.className, !transition && show && 'show'),
            style: {
                ...overlay.props.style,
                ...overlayProps.style,
            },
        });
    }));
});
Overlay.displayName = 'Overlay';
Overlay.propTypes = propTypes$1;
Overlay.defaultProps = defaultProps$1;

function normalizeDelay(delay) {
    return delay && typeof delay === 'object'
        ? delay
        : {
            show: delay,
            hide: delay,
        };
}
// Simple implementation of mouseEnter and mouseLeave.
// React's built version is broken: https://github.com/facebook/react/issues/4251
// for cases when the trigger is disabled and mouseOut/Over can cause flicker
// moving from one child element to another.
function handleMouseOverOut(
// eslint-disable-next-line @typescript-eslint/no-shadow
handler, args, relatedNative) {
    const [e] = args;
    const target = e.currentTarget;
    const related = e.relatedTarget || e.nativeEvent[relatedNative];
    if ((!related || related !== target) && !contains(target, related)) {
        handler(...args);
    }
}
const triggerType = PropTypes.oneOf(['click', 'hover', 'focus']);
const propTypes = {
    children: PropTypes.oneOfType([PropTypes.element, PropTypes.func]).isRequired,
    /**
     * Specify which action or actions trigger Overlay visibility
     *
     * @type {'hover' | 'click' |'focus' | Array<'hover' | 'click' |'focus'>}
     */
    trigger: PropTypes.oneOfType([triggerType, PropTypes.arrayOf(triggerType)]),
    /**
     * A millisecond delay amount to show and hide the Overlay once triggered
     */
    delay: PropTypes.oneOfType([
        PropTypes.number,
        PropTypes.shape({
            show: PropTypes.number,
            hide: PropTypes.number,
        }),
    ]),
    /**
     * The visibility of the Overlay. `show` is a _controlled_ prop so should be paired
     * with `onToggle` to avoid breaking user interactions.
     *
     * Manually toggling `show` does **not** wait for `delay` to change the visibility.
     *
     * @controllable onToggle
     */
    show: PropTypes.bool,
    /**
     * The initial visibility state of the Overlay.
     */
    defaultShow: PropTypes.bool,
    /**
     * A callback that fires when the user triggers a change in tooltip visibility.
     *
     * `onToggle` is called with the desired next `show`, and generally should be passed
     * back to the `show` prop. `onToggle` fires _after_ the configured `delay`
     *
     * @controllable `show`
     */
    onToggle: PropTypes.func,
    /**
      The initial flip state of the Overlay.
     */
    flip: PropTypes.bool,
    /**
     * An element or text to overlay next to the target.
     */
    overlay: PropTypes.oneOfType([PropTypes.func, PropTypes.element.isRequired]),
    /**
     * A Popper.js config object passed to the the underlying popper instance.
     */
    popperConfig: PropTypes.object,
    // Overridden props from `<Overlay>`.
    /**
     * @private
     */
    target: PropTypes.oneOf([null]),
    /**
     * @private
     */
    onHide: PropTypes.oneOf([null]),
    /**
     * The placement of the Overlay in relation to it's `target`.
     */
    placement: PropTypes.oneOf([
        'auto-start',
        'auto',
        'auto-end',
        'top-start',
        'top',
        'top-end',
        'right-start',
        'right',
        'right-end',
        'bottom-end',
        'bottom',
        'bottom-start',
        'left-end',
        'left',
        'left-start',
    ]),
};
const defaultProps = {
    defaultShow: false,
    trigger: ['hover', 'focus'],
};
function OverlayTrigger({ trigger, overlay, children, popperConfig = {}, show: propsShow, defaultShow = false, onToggle, delay: propsDelay, placement, flip = placement && placement.indexOf('auto') !== -1, ...props }) {
    const triggerNodeRef = useRef(null);
    const mergedRef = useMergedRefs(triggerNodeRef, children.ref);
    const timeout = useTimeout();
    const hoverStateRef = useRef('');
    const [show, setShow] = useUncontrolledProp(propsShow, defaultShow, onToggle);
    const delay = normalizeDelay(propsDelay);
    const { onFocus, onBlur, onClick } = typeof children !== 'function'
        ? React.Children.only(children).props
        : {};
    const attachRef = (r) => {
        mergedRef(safeFindDOMNode(r));
    };
    const handleShow = useCallback(() => {
        timeout.clear();
        hoverStateRef.current = 'show';
        if (!delay.show) {
            setShow(true);
            return;
        }
        timeout.set(() => {
            if (hoverStateRef.current === 'show')
                setShow(true);
        }, delay.show);
    }, [delay.show, setShow, timeout]);
    const handleHide = useCallback(() => {
        timeout.clear();
        hoverStateRef.current = 'hide';
        if (!delay.hide) {
            setShow(false);
            return;
        }
        timeout.set(() => {
            if (hoverStateRef.current === 'hide')
                setShow(false);
        }, delay.hide);
    }, [delay.hide, setShow, timeout]);
    const handleFocus = useCallback((...args) => {
        handleShow();
        onFocus?.(...args);
    }, [handleShow, onFocus]);
    const handleBlur = useCallback((...args) => {
        handleHide();
        onBlur?.(...args);
    }, [handleHide, onBlur]);
    const handleClick = useCallback((...args) => {
        setShow(!show);
        onClick?.(...args);
    }, [onClick, setShow, show]);
    const handleMouseOver = useCallback((...args) => {
        handleMouseOverOut(handleShow, args, 'fromElement');
    }, [handleShow]);
    const handleMouseOut = useCallback((...args) => {
        handleMouseOverOut(handleHide, args, 'toElement');
    }, [handleHide]);
    const triggers = trigger == null ? [] : [].concat(trigger);
    const triggerProps = {
        ref: attachRef,
    };
    if (triggers.indexOf('click') !== -1) {
        triggerProps.onClick = handleClick;
    }
    if (triggers.indexOf('focus') !== -1) {
        triggerProps.onFocus = handleFocus;
        triggerProps.onBlur = handleBlur;
    }
    if (triggers.indexOf('hover') !== -1) {
        warning(triggers.length > 1, '[react-bootstrap] Specifying only the `"hover"` trigger limits the visibility of the overlay to just mouse users. Consider also including the `"focus"` trigger so that touch and keyboard only users can see the overlay as well.');
        triggerProps.onMouseOver = handleMouseOver;
        triggerProps.onMouseOut = handleMouseOut;
    }
    return (React.createElement(React.Fragment, null,
        typeof children === 'function'
            ? children(triggerProps)
            : cloneElement(children, triggerProps),
        React.createElement(Overlay, { ...props, show: show, onHide: handleHide, flip: flip, placement: placement, popperConfig: popperConfig, target: triggerNodeRef.current }, overlay)));
}
OverlayTrigger.defaultProps = defaultProps;
OverlayTrigger.propTypes = propTypes;

export { Overlay, OverlayTrigger };
