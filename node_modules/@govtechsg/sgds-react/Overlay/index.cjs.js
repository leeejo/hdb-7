'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var classNames = require('classnames');
var PropTypes = require('prop-types');
var BaseOverlay = require('@restart/ui/Overlay');
var propTypesExtra = require('prop-types-extra');
var useMergedRefs = require('@restart/hooks/useMergedRefs');
var hasClass = require('dom-helpers/hasClass');
var createWithBsPrefix = require('../utils/createWithBsPrefix');
var helpers = require('../utils/helpers');
var Transition = require('react-transition-group/Transition');
var transitionEndListener = require('../utils/transitionEndListener');
var triggerBrowserReflow = require('../utils/triggerBrowserReflow');
var TransitionWrapper = require('../utils/TransitionWrapper');
var safeFindDOMNode = require('../utils/safeFindDOMNode');
var contains = require('dom-helpers/contains');
var useTimeout = require('@restart/hooks/useTimeout');
var warning = require('warning');
var uncontrollable = require('uncontrollable');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);
var classNames__default = /*#__PURE__*/_interopDefaultLegacy(classNames);
var PropTypes__default = /*#__PURE__*/_interopDefaultLegacy(PropTypes);
var BaseOverlay__default = /*#__PURE__*/_interopDefaultLegacy(BaseOverlay);
var useMergedRefs__default = /*#__PURE__*/_interopDefaultLegacy(useMergedRefs);
var hasClass__default = /*#__PURE__*/_interopDefaultLegacy(hasClass);
var createWithBsPrefix__default = /*#__PURE__*/_interopDefaultLegacy(createWithBsPrefix);
var transitionEndListener__default = /*#__PURE__*/_interopDefaultLegacy(transitionEndListener);
var triggerBrowserReflow__default = /*#__PURE__*/_interopDefaultLegacy(triggerBrowserReflow);
var TransitionWrapper__default = /*#__PURE__*/_interopDefaultLegacy(TransitionWrapper);
var safeFindDOMNode__default = /*#__PURE__*/_interopDefaultLegacy(safeFindDOMNode);
var contains__default = /*#__PURE__*/_interopDefaultLegacy(contains);
var useTimeout__default = /*#__PURE__*/_interopDefaultLegacy(useTimeout);
var warning__default = /*#__PURE__*/_interopDefaultLegacy(warning);

const ThemeContext = React__namespace.createContext({ prefixes: {} });
({
    prefixes: PropTypes__default["default"].object,
    dir: PropTypes__default["default"].string,
});
function useBootstrapPrefix(prefix, defaultPrefix) {
    const { prefixes } = React.useContext(ThemeContext);
    return prefix || prefixes[defaultPrefix] || `${defaultPrefix}`;
}
// `sgds-${defaultPrefix}`
function useIsRTL() {
    const { dir } = React.useContext(ThemeContext);
    return dir === 'rtl';
}
React__namespace.forwardRef(({ as: Tag = 'div', ...props }, ref) => {
    return React__namespace.createElement(Tag, { ref: ref, ...props, className: classNames__default["default"](props.className, 'sgds') });
});

var PopoverHeader = createWithBsPrefix__default["default"]('popover-header');

var PopoverBody = createWithBsPrefix__default["default"]('popover-body');

const propTypes$3 = {
    /**
     * @default 'popover'
     */
    bsPrefix: PropTypes__default["default"].string,
    /**
     * An html id attribute, necessary for accessibility
     * @type {string}
     * @required
     */
    id: PropTypes__default["default"].string,
    /**
     * Sets the direction the Popover is positioned towards.
     *
     * > This is generally provided by the `Overlay` component positioning the popover
     */
    placement: PropTypes__default["default"].oneOf([
        'auto-start',
        'auto',
        'auto-end',
        'top-start',
        'top',
        'top-end',
        'right-start',
        'right',
        'right-end',
        'bottom-end',
        'bottom',
        'bottom-start',
        'left-end',
        'left',
        'left-start',
    ]),
    /**
     * An Overlay injected set of props for positioning the popover arrow.
     *
     * > This is generally provided by the `Overlay` component positioning the popover
     */
    arrowProps: PropTypes__default["default"].shape({
        ref: PropTypes__default["default"].any,
        style: PropTypes__default["default"].object,
    }),
    /**
     * When this prop is set, it creates a Popover with a Popover.Body inside
     * passing the children directly to it
     */
    body: PropTypes__default["default"].bool,
    /** @private */
    popper: PropTypes__default["default"].object,
    /** @private */
    show: PropTypes__default["default"].bool,
    hasArrow: PropTypes__default["default"].bool,
};
const defaultProps$3 = {
    placement: 'right',
};
const Popover = React__namespace.forwardRef(({ bsPrefix, placement, className, style, children, body, arrowProps, hasArrow = false, popper: _, show: _1, ...props }, ref) => {
    const decoratedBsPrefix = useBootstrapPrefix(bsPrefix, 'popover');
    const isRTL = useIsRTL();
    const [primaryPlacement] = placement?.split('-') || [];
    const bsDirection = helpers.getOverlayDirection(primaryPlacement, isRTL);
    return (React__namespace.createElement("div", { ref: ref, role: "tooltip", style: style, "x-placement": primaryPlacement, className: classNames__default["default"](className, decoratedBsPrefix, primaryPlacement && `bs-popover-${bsDirection}`), ...props },
        hasArrow && React__namespace.createElement("div", { className: "popover-arrow", ...arrowProps }),
        React__namespace.createElement(React__namespace.Fragment, null,
            " ",
            children)));
});
Popover.defaultProps = defaultProps$3;
Popover.propTypes = propTypes$3;
var Popover$1 = Object.assign(Popover, {
    Header: PopoverHeader,
    Body: PopoverBody,
    // Default popover offset.
    // https://github.com/twbs/bootstrap/blob/5c32767e0e0dbac2d934bcdee03719a65d3f1187/js/src/popover.js#L28
    POPPER_OFFSET: [0, 8],
});

// This is meant for internal use.
// This applies a custom offset to the overlay if it's a popover.
function useOverlayOffset(customOffset) {
    const overlayRef = React.useRef(null);
    const popoverClass = useBootstrapPrefix(undefined, 'popover');
    const offset = React.useMemo(() => ({
        name: 'offset',
        options: {
            offset: () => {
                if (overlayRef.current &&
                    hasClass__default["default"](overlayRef.current, popoverClass)) {
                    return customOffset || Popover$1.POPPER_OFFSET;
                }
                return customOffset || [0, 0];
            },
        },
    }), [customOffset, popoverClass]);
    return [overlayRef, [offset]];
}

const propTypes$2 = {
    /**
     * Show the component; triggers the fade in or fade out animation
     */
    in: PropTypes__default["default"].bool,
    /**
     * Wait until the first "enter" transition to mount the component (add it to the DOM)
     */
    mountOnEnter: PropTypes__default["default"].bool,
    /**
     * Unmount the component (remove it from the DOM) when it is faded out
     */
    unmountOnExit: PropTypes__default["default"].bool,
    /**
     * Run the fade in animation when the component mounts, if it is initially
     * shown
     */
    appear: PropTypes__default["default"].bool,
    /**
     * Duration of the fade animation in milliseconds, to ensure that finishing
     * callbacks are fired even if the original browser transition end events are
     * canceled
     */
    timeout: PropTypes__default["default"].number,
    /**
     * Callback fired before the component fades in
     */
    onEnter: PropTypes__default["default"].func,
    /**
     * Callback fired after the component starts to fade in
     */
    onEntering: PropTypes__default["default"].func,
    /**
     * Callback fired after the has component faded in
     */
    onEntered: PropTypes__default["default"].func,
    /**
     * Callback fired before the component fades out
     */
    onExit: PropTypes__default["default"].func,
    /**
     * Callback fired after the component starts to fade out
     */
    onExiting: PropTypes__default["default"].func,
    /**
     * Callback fired after the component has faded out
     */
    onExited: PropTypes__default["default"].func,
    /**
     * You must provide a single JSX child element to this component and that element cannot be a \<React.Fragment\>
     */
    children: PropTypes__default["default"].element.isRequired,
    /**
     * Applies additional specified classes during the transition. Takes an object
     * where the keys correspond to the Transition status
     */
    transitionClasses: PropTypes__default["default"].object,
};
const defaultProps$2 = {
    in: false,
    timeout: 300,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
};
const fadeStyles = {
    [Transition.ENTERING]: 'show',
    [Transition.ENTERED]: 'show',
};
const Fade = React__namespace.forwardRef(({ className, children, transitionClasses = {}, ...props }, ref) => {
    const handleEnter = React.useCallback((node, isAppearing) => {
        triggerBrowserReflow__default["default"](node);
        props.onEnter?.(node, isAppearing);
    }, [props]);
    return (React__namespace.createElement(TransitionWrapper__default["default"], { ref: ref, addEndListener: transitionEndListener__default["default"], ...props, onEnter: handleEnter, childRef: children.ref }, (status, innerProps) => React__namespace.cloneElement(children, {
        ...innerProps,
        className: classNames__default["default"]('fade', className, children.props.className, 
        //@ts-ignore
        fadeStyles[status], transitionClasses[status]),
    })));
});
Fade.propTypes = propTypes$2;
Fade.defaultProps = defaultProps$2;
Fade.displayName = 'Fade';

const propTypes$1 = {
    /**
     * A component instance, DOM node, or function that returns either.
     * The `container` element will have the Overlay appended to it via a React portal.
     */
    container: PropTypes__default["default"].oneOfType([propTypesExtra.componentOrElement, PropTypes__default["default"].func]),
    /**
     * A component instance, DOM node, or function that returns either.
     * The overlay will be positioned in relation to the `target`
     */
    target: PropTypes__default["default"].oneOfType([propTypesExtra.componentOrElement, PropTypes__default["default"].func]),
    /**
     * Set the visibility of the Overlay
     */
    show: PropTypes__default["default"].bool,
    /**
     * A set of popper options and props passed directly to Popper.
     */
    popperConfig: PropTypes__default["default"].object,
    /**
     * Specify whether the overlay should trigger onHide when the user clicks outside the overlay
     */
    rootClose: PropTypes__default["default"].bool,
    /**
     * Specify event for triggering a "root close" toggle.
     */
    rootCloseEvent: PropTypes__default["default"].oneOf(['click', 'mousedown']),
    /**
     * A callback invoked by the overlay when it wishes to be hidden. Required if
     * `rootClose` is specified.
     */
    onHide: PropTypes__default["default"].func,
    /**
     * Animate the entering and exiting of the Overlay. `true` will use the `<Fade>` transition,
     * or a custom react-transition-group `<Transition>` component can be provided.
     */
    transition: PropTypes__default["default"].oneOfType([PropTypes__default["default"].bool, propTypesExtra.elementType]),
    /**
     * Callback fired before the Overlay transitions in
     */
    onEnter: PropTypes__default["default"].func,
    /**
     * Callback fired as the Overlay begins to transition in
     */
    onEntering: PropTypes__default["default"].func,
    /**
     * Callback fired after the Overlay finishes transitioning in
     */
    onEntered: PropTypes__default["default"].func,
    /**
     * Callback fired right before the Overlay transitions out
     */
    onExit: PropTypes__default["default"].func,
    /**
     * Callback fired as the Overlay begins to transition out
     */
    onExiting: PropTypes__default["default"].func,
    /**
     * Callback fired after the Overlay finishes transitioning out
     */
    onExited: PropTypes__default["default"].func,
    /**
     * The placement of the Overlay in relation to it's `target`.
     */
    placement: PropTypes__default["default"].oneOf([
        'auto-start',
        'auto',
        'auto-end',
        'top-start',
        'top',
        'top-end',
        'right-start',
        'right',
        'right-end',
        'bottom-end',
        'bottom',
        'bottom-start',
        'left-end',
        'left',
        'left-start',
    ]),
};
const defaultProps$1 = {
    transition: Fade,
    rootClose: false,
    show: false,
    placement: 'top',
};
function wrapRefs(props, arrowProps) {
    const { ref } = props;
    const { ref: aRef } = arrowProps;
    props.ref = ref.__wrapped || (ref.__wrapped = (r) => ref(safeFindDOMNode__default["default"](r)));
    arrowProps.ref =
        aRef.__wrapped || (aRef.__wrapped = (r) => aRef(safeFindDOMNode__default["default"](r)));
}
const Overlay = React__namespace.forwardRef(({ children: overlay, transition, popperConfig = {}, ...outerProps }, outerRef) => {
    const popperRef = React.useRef({});
    const [ref, modifiers] = useOverlayOffset(outerProps.offset);
    const mergedRef = useMergedRefs__default["default"](outerRef, ref);
    const actualTransition = transition === true ? Fade : transition || undefined;
    return (React__namespace.createElement(BaseOverlay__default["default"], { ...outerProps, ref: mergedRef, popperConfig: {
            ...popperConfig,
            modifiers: modifiers.concat(popperConfig.modifiers || []),
        }, 
        //@ts-ignore
        transition: actualTransition }, (overlayProps, { arrowProps, popper: popperObj, show }) => {
        wrapRefs(overlayProps, arrowProps);
        // Need to get placement from popper object, handling case when overlay is flipped using 'flip' prop
        const updatedPlacement = popperObj?.placement;
        const popper = Object.assign(popperRef.current, {
            state: popperObj?.state,
            scheduleUpdate: popperObj?.update,
            placement: updatedPlacement,
            outOfBoundaries: popperObj?.state?.modifiersData.hide?.isReferenceHidden || false,
        });
        if (typeof overlay === 'function')
            return overlay({
                ...overlayProps,
                placement: updatedPlacement,
                show,
                ...(!transition && show && { className: 'show' }),
                popper,
                arrowProps,
            });
        return React__namespace.cloneElement(overlay, {
            ...overlayProps,
            placement: updatedPlacement,
            arrowProps,
            popper,
            className: classNames__default["default"](overlay.props.className, !transition && show && 'show'),
            style: {
                ...overlay.props.style,
                ...overlayProps.style,
            },
        });
    }));
});
Overlay.displayName = 'Overlay';
Overlay.propTypes = propTypes$1;
Overlay.defaultProps = defaultProps$1;

function normalizeDelay(delay) {
    return delay && typeof delay === 'object'
        ? delay
        : {
            show: delay,
            hide: delay,
        };
}
// Simple implementation of mouseEnter and mouseLeave.
// React's built version is broken: https://github.com/facebook/react/issues/4251
// for cases when the trigger is disabled and mouseOut/Over can cause flicker
// moving from one child element to another.
function handleMouseOverOut(
// eslint-disable-next-line @typescript-eslint/no-shadow
handler, args, relatedNative) {
    const [e] = args;
    const target = e.currentTarget;
    const related = e.relatedTarget || e.nativeEvent[relatedNative];
    if ((!related || related !== target) && !contains__default["default"](target, related)) {
        handler(...args);
    }
}
const triggerType = PropTypes__default["default"].oneOf(['click', 'hover', 'focus']);
const propTypes = {
    children: PropTypes__default["default"].oneOfType([PropTypes__default["default"].element, PropTypes__default["default"].func]).isRequired,
    /**
     * Specify which action or actions trigger Overlay visibility
     *
     * @type {'hover' | 'click' |'focus' | Array<'hover' | 'click' |'focus'>}
     */
    trigger: PropTypes__default["default"].oneOfType([triggerType, PropTypes__default["default"].arrayOf(triggerType)]),
    /**
     * A millisecond delay amount to show and hide the Overlay once triggered
     */
    delay: PropTypes__default["default"].oneOfType([
        PropTypes__default["default"].number,
        PropTypes__default["default"].shape({
            show: PropTypes__default["default"].number,
            hide: PropTypes__default["default"].number,
        }),
    ]),
    /**
     * The visibility of the Overlay. `show` is a _controlled_ prop so should be paired
     * with `onToggle` to avoid breaking user interactions.
     *
     * Manually toggling `show` does **not** wait for `delay` to change the visibility.
     *
     * @controllable onToggle
     */
    show: PropTypes__default["default"].bool,
    /**
     * The initial visibility state of the Overlay.
     */
    defaultShow: PropTypes__default["default"].bool,
    /**
     * A callback that fires when the user triggers a change in tooltip visibility.
     *
     * `onToggle` is called with the desired next `show`, and generally should be passed
     * back to the `show` prop. `onToggle` fires _after_ the configured `delay`
     *
     * @controllable `show`
     */
    onToggle: PropTypes__default["default"].func,
    /**
      The initial flip state of the Overlay.
     */
    flip: PropTypes__default["default"].bool,
    /**
     * An element or text to overlay next to the target.
     */
    overlay: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].element.isRequired]),
    /**
     * A Popper.js config object passed to the the underlying popper instance.
     */
    popperConfig: PropTypes__default["default"].object,
    // Overridden props from `<Overlay>`.
    /**
     * @private
     */
    target: PropTypes__default["default"].oneOf([null]),
    /**
     * @private
     */
    onHide: PropTypes__default["default"].oneOf([null]),
    /**
     * The placement of the Overlay in relation to it's `target`.
     */
    placement: PropTypes__default["default"].oneOf([
        'auto-start',
        'auto',
        'auto-end',
        'top-start',
        'top',
        'top-end',
        'right-start',
        'right',
        'right-end',
        'bottom-end',
        'bottom',
        'bottom-start',
        'left-end',
        'left',
        'left-start',
    ]),
};
const defaultProps = {
    defaultShow: false,
    trigger: ['hover', 'focus'],
};
function OverlayTrigger({ trigger, overlay, children, popperConfig = {}, show: propsShow, defaultShow = false, onToggle, delay: propsDelay, placement, flip = placement && placement.indexOf('auto') !== -1, ...props }) {
    const triggerNodeRef = React.useRef(null);
    const mergedRef = useMergedRefs__default["default"](triggerNodeRef, children.ref);
    const timeout = useTimeout__default["default"]();
    const hoverStateRef = React.useRef('');
    const [show, setShow] = uncontrollable.useUncontrolledProp(propsShow, defaultShow, onToggle);
    const delay = normalizeDelay(propsDelay);
    const { onFocus, onBlur, onClick } = typeof children !== 'function'
        ? React__namespace.Children.only(children).props
        : {};
    const attachRef = (r) => {
        mergedRef(safeFindDOMNode__default["default"](r));
    };
    const handleShow = React.useCallback(() => {
        timeout.clear();
        hoverStateRef.current = 'show';
        if (!delay.show) {
            setShow(true);
            return;
        }
        timeout.set(() => {
            if (hoverStateRef.current === 'show')
                setShow(true);
        }, delay.show);
    }, [delay.show, setShow, timeout]);
    const handleHide = React.useCallback(() => {
        timeout.clear();
        hoverStateRef.current = 'hide';
        if (!delay.hide) {
            setShow(false);
            return;
        }
        timeout.set(() => {
            if (hoverStateRef.current === 'hide')
                setShow(false);
        }, delay.hide);
    }, [delay.hide, setShow, timeout]);
    const handleFocus = React.useCallback((...args) => {
        handleShow();
        onFocus?.(...args);
    }, [handleShow, onFocus]);
    const handleBlur = React.useCallback((...args) => {
        handleHide();
        onBlur?.(...args);
    }, [handleHide, onBlur]);
    const handleClick = React.useCallback((...args) => {
        setShow(!show);
        onClick?.(...args);
    }, [onClick, setShow, show]);
    const handleMouseOver = React.useCallback((...args) => {
        handleMouseOverOut(handleShow, args, 'fromElement');
    }, [handleShow]);
    const handleMouseOut = React.useCallback((...args) => {
        handleMouseOverOut(handleHide, args, 'toElement');
    }, [handleHide]);
    const triggers = trigger == null ? [] : [].concat(trigger);
    const triggerProps = {
        ref: attachRef,
    };
    if (triggers.indexOf('click') !== -1) {
        triggerProps.onClick = handleClick;
    }
    if (triggers.indexOf('focus') !== -1) {
        triggerProps.onFocus = handleFocus;
        triggerProps.onBlur = handleBlur;
    }
    if (triggers.indexOf('hover') !== -1) {
        warning__default["default"](triggers.length > 1, '[react-bootstrap] Specifying only the `"hover"` trigger limits the visibility of the overlay to just mouse users. Consider also including the `"focus"` trigger so that touch and keyboard only users can see the overlay as well.');
        triggerProps.onMouseOver = handleMouseOver;
        triggerProps.onMouseOut = handleMouseOut;
    }
    return (React__namespace.createElement(React__namespace.Fragment, null,
        typeof children === 'function'
            ? children(triggerProps)
            : React.cloneElement(children, triggerProps),
        React__namespace.createElement(Overlay, { ...props, show: show, onHide: handleHide, flip: flip, placement: placement, popperConfig: popperConfig, target: triggerNodeRef.current }, overlay)));
}
OverlayTrigger.defaultProps = defaultProps;
OverlayTrigger.propTypes = propTypes;

exports.Overlay = Overlay;
exports.OverlayTrigger = OverlayTrigger;
