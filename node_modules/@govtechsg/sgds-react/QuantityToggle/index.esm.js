'use client';
import * as React from 'react';
import { useContext, useMemo } from 'react';
import classNames from 'classnames';
import PropTypes from 'prop-types';
import { useButtonProps } from '@restart/ui/Button';
import createWithBsPrefix from '../utils/createWithBsPrefix';
import warning from 'warning';

const ThemeContext = React.createContext({ prefixes: {} });
({
    prefixes: PropTypes.object,
    dir: PropTypes.string,
});
function useBootstrapPrefix(prefix, defaultPrefix) {
    const { prefixes } = useContext(ThemeContext);
    return prefix || prefixes[defaultPrefix] || `${defaultPrefix}`;
}
const SGDSWrapper = React.forwardRef(({ as: Tag = 'div', ...props }, ref) => {
    return React.createElement(Tag, { ref: ref, ...props, className: classNames(props.className, 'sgds') });
});

const propTypes$e = {
    /**
     * @default 'btn'
     */
    bsPrefix: PropTypes.string,
    /**
     * One or more button variant combinations
     *
     * buttons may be one of a variety of visual variants such as:
     *
     * `'primary', 'secondary', 'success', 'danger', 'warning', 'info', 'dark', 'light', 'link'`
     *
     * as well as "outline" versions (prefixed by 'outline-*')
     *
     * `'outline-primary', 'outline-secondary', 'outline-success', 'outline-danger', 'outline-warning', 'outline-info', 'outline-dark', 'outline-light'`
     */
    variant: PropTypes.string,
    /**
     * Specifies a large or small button.
     *
     * @type ('sm'|'lg')
     */
    size: PropTypes.string,
    /** Manually set the visual state of the button to `:active` */
    active: PropTypes.bool,
    /**
     * Disables the Button, preventing mouse events,
     * even if the underlying component is an `<a>` element
     */
    disabled: PropTypes.bool,
    /** Providing a `href` will render an `<a>` element, _styled_ as a button. */
    href: PropTypes.string,
    /**
     * Defines HTML button type attribute.
     *
     * @default 'button'
     */
    type: PropTypes.oneOf(['button', 'reset', 'submit', null]),
    as: PropTypes.elementType,
};
const defaultProps$2 = {
    variant: 'primary',
    active: false,
    disabled: false,
};
const Button = React.forwardRef(({ as, bsPrefix, variant, size, active, className, ...props }, ref) => {
    const prefix = useBootstrapPrefix(bsPrefix, 'btn');
    const [buttonProps, { tagName }] = useButtonProps({
        tagName: as,
        ...props,
    });
    const Component = tagName;
    return (React.createElement(SGDSWrapper, { as: Component, ...props, ...buttonProps, ref: ref, className: classNames(className, prefix, active && 'active', variant && `${prefix}-${variant}`, size && `${prefix}-${size}`, props.href && props.disabled && 'disabled') }));
});
Button.displayName = 'Button';
Button.propTypes = propTypes$e;
Button.defaultProps = defaultProps$2;

const InputGroupText = createWithBsPrefix('input-group-text', {
    Component: 'span',
});

const context = React.createContext(null);
context.displayName = 'InputGroupContext';

const FormContext = React.createContext({});

const propTypes$d = {
    /**
     * @default 'form-check-input'
     */
    bsPrefix: PropTypes.string,
    /**
     * The underlying HTML element to use when rendering the FormCheckInput.
     *
     * @type {('input'|elementType)}
     */
    as: PropTypes.elementType,
    /** A HTML id attribute, necessary for proper form accessibility. */
    id: PropTypes.string,
    /** The type of checkable. */
    type: PropTypes.oneOf(['radio', 'checkbox']).isRequired,
    /** Manually style the input as valid */
    isValid: PropTypes.bool,
    /** Manually style the input as invalid */
    isInvalid: PropTypes.bool,
};
const FormCheckInput = React.forwardRef(({ id, bsPrefix, className, type = 'checkbox', isValid = false, isInvalid = false, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'input', ...props }, ref) => {
    const { controlId } = useContext(FormContext);
    bsPrefix = useBootstrapPrefix(bsPrefix, 'form-check-input');
    return (React.createElement(Component, { ...props, ref: ref, type: type, id: id || controlId, className: classNames(className, bsPrefix, isValid && 'is-valid', isInvalid && 'is-invalid') }));
});
FormCheckInput.displayName = 'FormCheckInput';
FormCheckInput.propTypes = propTypes$d;

const InputGroupCheckbox = (props) => (React.createElement(InputGroupText, null,
    React.createElement(FormCheckInput, { type: "checkbox", ...props })));
const InputGroupRadio = (props) => (React.createElement(InputGroupText, null,
    React.createElement(FormCheckInput, { type: "radio", ...props })));

const propTypes$c = {
    /** @default 'input-group' */
    bsPrefix: PropTypes.string,
    /**
     * Control the size of buttons and form elements from the top-level.
     *
     * @type {('sm'|'lg')}
     */
    size: PropTypes.string,
    /**
     * Handles the input's rounded corners when using form validation.
     *
     * Use this when your input group contains both an input and feedback element.
     */
    hasValidation: PropTypes.bool,
    as: PropTypes.elementType,
    variant: PropTypes.oneOf(['quantity-toggle'])
};
/**
 *
 * @property {InputGroupText} Text
 * @property {InputGroupRadio} Radio
 * @property {InputGroupCheckbox} Checkbox
 */
const InputGroup = React.forwardRef(({ bsPrefix, size, hasValidation, className, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'div', ...InputGroupProps }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'input-group');
    // Intentionally an empty object. Used in detecting if a dropdown
    // exists under an input group.
    const contextValue = useMemo(() => ({}), []);
    return (React.createElement(context.Provider, { value: contextValue },
        React.createElement(SGDSWrapper, { as: Component, ref: ref, ...InputGroupProps, className: classNames(className, bsPrefix, size && `${bsPrefix}-${size}`, hasValidation && 'has-validation') })));
});
InputGroup.propTypes = propTypes$c;
InputGroup.displayName = 'InputGroup';
var InputGroup$1 = Object.assign(InputGroup, {
    Text: InputGroupText,
    Radio: InputGroupRadio,
    Checkbox: InputGroupCheckbox,
});

const propTypes$b = {
    /**
     * Specify whether the feedback is for valid or invalid fields
     *
     * @type {('valid'|'invalid')}
     */
    type: PropTypes.string,
    as: PropTypes.elementType,
};
const Feedback = React.forwardRef(
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
({ as: Component = 'div', className, type = 'valid', ...props }, ref) => {
    return (React.createElement(Component, { ...props, ref: ref, className: classNames(className, `${type}-feedback`) }));
});
Feedback.displayName = 'Feedback';
Feedback.propTypes = propTypes$b;

const propTypes$a = {
    as: PropTypes.elementType,
    icon: PropTypes.element,
};
const FormControlGroup = React.forwardRef(({ icon, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'div', bsPrefix, children, className, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'form-control-group');
    return (React.createElement(SGDSWrapper, { className: classNames(bsPrefix, className), ...props, ref: ref },
        icon &&
            React.cloneElement(icon, {
                className: classNames(icon.props.className, 'form-control-icon'),
            }),
        children));
});
FormControlGroup.displayName = 'FormControlGroup';
FormControlGroup.propTypes = propTypes$a;

const propTypes$9 = {
    /**
     * @default {'form-control'}
     */
    bsPrefix: PropTypes.string,
    /**
     * The FormControl `ref` will be forwarded to the underlying input element,
     * which means unless `as` is a composite component,
     * it will be a DOM node, when resolved.
     *
     * @type {ReactRef}
     * @alias ref
     */
    _ref: PropTypes.any,
    /**
     * Input size variants
     *
     * @type {('sm'|'lg')}
     */
    size: PropTypes.string,
    /**
     * The underlying HTML element to use when rendering the FormControl.
     *
     * @type {('input'|'textarea'|elementType)}
     */
    as: PropTypes.elementType,
    /**
     * Render the input as plain text. Generally used along side `readOnly`.
     */
    plaintext: PropTypes.bool,
    /** Make the control readonly */
    readOnly: PropTypes.bool,
    /** Make the control disabled */
    disabled: PropTypes.bool,
    /**
     * The `value` attribute of underlying input
     *
     * @controllable onChange
     * */
    value: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.arrayOf(PropTypes.string),
        PropTypes.number,
    ]),
    /** A callback fired when the `value` prop changes */
    onChange: PropTypes.func,
    /**
     * The HTML input `type`, which is only relevant if `as` is `'input'` (the default).
     */
    type: PropTypes.string,
    /**
     * Uses `controlId` from `<FormGroup>` if not explicitly specified.
     */
    id: PropTypes.string,
    /** Add "valid" validation styles to the control */
    isValid: PropTypes.bool,
    /** Add "invalid" validation styles to the control and accompanying label */
    isInvalid: PropTypes.bool,
};
const FormControl = React.forwardRef(({ bsPrefix, type, size, id, className, isValid = false, isInvalid = false, plaintext, readOnly, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'input', ...props }, ref) => {
    const { controlId } = useContext(FormContext);
    bsPrefix = useBootstrapPrefix(bsPrefix, 'form-control');
    let classes;
    if (plaintext) {
        classes = { [`${bsPrefix}-plaintext`]: true };
    }
    else {
        classes = {
            [bsPrefix]: true,
            [`${bsPrefix}-${size}`]: size,
        };
    }
    warning(controlId == null || !id, '`controlId` is ignored on `<FormControl>` when `id` is specified.');
    return (React.createElement(Component, { ...props, type: type, ref: ref, readOnly: readOnly, id: id || controlId, className: classNames(className, classes, isValid && `is-valid`, isInvalid && `is-invalid`, type === 'color' && `${bsPrefix}-color`) }));
});
FormControl.displayName = 'FormControl';
FormControl.propTypes = propTypes$9;
var FormControl$1 = Object.assign(FormControl, { Feedback, Group: FormControlGroup });

const propTypes$8 = {
    /**
     * @default 'form-check-label'
     */
    bsPrefix: PropTypes.string,
    /** The HTML for attribute for associating the label with an input */
    htmlFor: PropTypes.string,
};
const FormCheckLabel = React.forwardRef(({ bsPrefix, className, htmlFor, ...props }, ref) => {
    const { controlId } = useContext(FormContext);
    bsPrefix = useBootstrapPrefix(bsPrefix, 'form-check-label');
    return (React.createElement("label", { ...props, ref: ref, htmlFor: htmlFor || controlId, className: classNames(className, bsPrefix) }));
});
FormCheckLabel.displayName = 'FormCheckLabel';
FormCheckLabel.propTypes = propTypes$8;

const propTypes$7 = {
    /**
     * @default 'form-check'
     */
    bsPrefix: PropTypes.string,
    /**
     * bsPrefix override for the base switch class.
     *
     * @default 'form-switch'
     */
    bsSwitchPrefix: PropTypes.string,
    /**
     * The FormCheck `ref` will be forwarded to the underlying input element,
     * which means it will be a DOM node, when resolved.
     *
     * @type {ReactRef}
     * @alias ref
     */
    _ref: PropTypes.any,
    /**
     * The underlying HTML element to use when rendering the FormCheck.
     *
     * @type {('input'|elementType)}
     */
    as: PropTypes.elementType,
    /**
     * A HTML id attribute, necessary for proper form accessibility.
     * An id is recommended for allowing label clicks to toggle the check control.
     *
     * This is **required** when `type="switch"` due to how they are rendered.
     */
    id: PropTypes.string,
    /**
     * Groups controls horizontally with other `FormCheck`s.
     */
    inline: PropTypes.bool,
    /**
     * Disables the control.
     */
    disabled: PropTypes.bool,
    /**
     * `title` attribute for the underlying `FormCheckLabel`.
     */
    title: PropTypes.string,
    /**
     * Label for the control.
     */
    label: PropTypes.node,
    /**
     * aria-label for label element.
     */
    ariaLabel: PropTypes.string,
    /**
     * The type of checkable.
     * @type {('radio' | 'checkbox' | 'switch')}
     */
    type: PropTypes.oneOf(['radio', 'checkbox', 'switch']),
    /** Manually style the input as valid */
    isValid: PropTypes.bool,
    /** Manually style the input as invalid */
    isInvalid: PropTypes.bool,
    /** A message to display when the input is in a validation state */
    feedback: PropTypes.node,
    feedbackType: PropTypes.oneOf(['invalid', 'valid'])
};
const FormCheck = React.forwardRef(({ id, bsPrefix, bsSwitchPrefix, inline = false, disabled = false, isValid = false, isInvalid = false, feedback, feedbackType, className, style, title = '', type = 'checkbox', label, ariaLabel, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as = 'input', ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'form-check');
    bsSwitchPrefix = useBootstrapPrefix(bsSwitchPrefix, 'form-switch');
    const { controlId } = useContext(FormContext);
    const innerFormContext = useMemo(() => ({
        controlId: id || controlId,
    }), [controlId, id]);
    const input = (React.createElement(FormCheckInput, { ...props, type: type === 'switch' ? 'checkbox' : type, ref: ref, isValid: isValid, isInvalid: isInvalid, disabled: disabled, as: as }));
    return (React.createElement(FormContext.Provider, { value: innerFormContext },
        React.createElement("div", { style: style, className: classNames(className, label && bsPrefix, inline && `${bsPrefix}-inline`, type === 'switch' && bsSwitchPrefix) },
            input,
            React.createElement(FormCheckLabel, { title: title, "aria-label": ariaLabel }, label),
            feedback && React.createElement(Feedback, { type: feedbackType }, feedback))));
});
FormCheck.displayName = 'FormCheck';
FormCheck.propTypes = propTypes$7;
var FormCheck$1 = Object.assign(FormCheck, {
    Input: FormCheckInput,
    Label: FormCheckLabel,
});

const propTypes$6 = {
    as: PropTypes.elementType,
    /**
     * Sets `id` on `<FormControl>` and `htmlFor` on `<FormGroup.Label>`.
     */
    controlId: PropTypes.string,
    /**
     * The FormGroup `ref` will be forwarded to the underlying element.
     * Unless the FormGroup is rendered `as` a composite component,
     * it will be a DOM node, when resolved.
     *
     * @type {ReactRef}
     * @alias ref
     */
    _ref: PropTypes.any,
};
const FormGroup = React.forwardRef(({ controlId, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'div', ...props }, ref) => {
    const context = useMemo(() => ({ controlId }), [controlId]);
    return (React.createElement(FormContext.Provider, { value: context },
        React.createElement(Component, { ...props, ref: ref })));
});
FormGroup.displayName = 'FormGroup';
FormGroup.propTypes = propTypes$6;

const DEVICE_SIZES = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];
const colSize = PropTypes.oneOfType([
    PropTypes.bool,
    PropTypes.number,
    PropTypes.string,
    PropTypes.oneOf(['auto']),
]);
const stringOrNumber = PropTypes.oneOfType([
    PropTypes.number,
    PropTypes.string,
]);
const column = PropTypes.oneOfType([
    colSize,
    PropTypes.shape({
        size: colSize,
        order: stringOrNumber,
        offset: stringOrNumber,
    }),
]);
const propTypes$5 = {
    /**
     * @default 'col'
     */
    bsPrefix: PropTypes.string,
    as: PropTypes.elementType,
    /**
     * The number of columns to span on extra small devices (<576px)
     *
     * @type {(boolean|"auto"|number|{ span: boolean|"auto"|number, offset: number, order: "first"|"last"|number })}
     */
    xs: column,
    /**
     * The number of columns to span on small devices (≥576px)
     *
     * @type {(boolean|"auto"|number|{ span: boolean|"auto"|number, offset: number, order: "first"|"last"|number })}
     */
    sm: column,
    /**
     * The number of columns to span on medium devices (≥768px)
     *
     * @type {(boolean|"auto"|number|{ span: boolean|"auto"|number, offset: number, order: "first"|"last"|number })}
     */
    md: column,
    /**
     * The number of columns to span on large devices (≥992px)
     *
     * @type {(boolean|"auto"|number|{ span: boolean|"auto"|number, offset: number, order: "first"|"last"|number })}
     */
    lg: column,
    /**
     * The number of columns to span on extra large devices (≥1200px)
     *
     * @type {(boolean|"auto"|number|{ span: boolean|"auto"|number, offset: number, order: "first"|"last"|number })}
     */
    xl: column,
    /**
     * The number of columns to span on extra extra large devices (≥1400px)
     *
     * @type {(boolean|"auto"|number|{ span: boolean|"auto"|number, offset: number, order: "first"|"last"|number })}
     */
    xxl: column,
};
function useCol({ as, bsPrefix, className, ...props }) {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'col');
    const spans = [];
    const classes = [];
    DEVICE_SIZES.forEach((brkPoint) => {
        const propValue = props[brkPoint];
        delete props[brkPoint];
        let span;
        let offset;
        let order;
        if (typeof propValue === 'object' && propValue != null) {
            ({ span, offset, order } = propValue);
        }
        else {
            span = propValue;
        }
        const infix = brkPoint !== 'xs' ? `-${brkPoint}` : '';
        if (span)
            spans.push(span === true ? `${bsPrefix}${infix}` : `${bsPrefix}${infix}-${span}`);
        if (order != null)
            classes.push(`order${infix}-${order}`);
        if (offset != null)
            classes.push(`offset${infix}-${offset}`);
    });
    return [
        { ...props, className: classNames(className, ...spans, ...classes) },
        {
            as,
            bsPrefix,
            spans,
        },
    ];
}
const Col = React.forwardRef(
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
(props, ref) => {
    const [{ className, ...colProps }, { as: Component = 'div', bsPrefix, spans },] = useCol(props);
    return (React.createElement(Component, { ...colProps, ref: ref, className: classNames(className, !spans.length && bsPrefix) }));
});
Col.displayName = 'Col';
Col.propTypes = propTypes$5;

const propTypes$4 = {
    /**
     * @default 'form-label'
     */
    bsPrefix: PropTypes.string,
    /**
     * Uses `controlId` from `<FormGroup>` if not explicitly specified.
     */
    htmlFor: PropTypes.string,
    /**
     * Renders the FormLabel as a `<Col>` component (accepting all the same props),
     * as well as adding additional styling for horizontal forms.
     */
    column: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['sm', 'lg'])]),
    /**
     * The FormLabel `ref` will be forwarded to the underlying element.
     * Unless the FormLabel is rendered `as` a composite component,
     * it will be a DOM node, when resolved.
     *
     * @type {ReactRef}
     * @alias ref
     */
    _ref: PropTypes.any,
    /**
     * Hides the label visually while still allowing it to be
     * read by assistive technologies.
     */
    visuallyHidden: PropTypes.bool,
    /** Set a custom element for this component */
    as: PropTypes.elementType,
};
const defaultProps$1 = {
    column: false,
    visuallyHidden: false,
};
const FormLabel = React.forwardRef(({ 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'label', bsPrefix, column, visuallyHidden, className, htmlFor, ...props }, ref) => {
    const { controlId } = useContext(FormContext);
    bsPrefix = useBootstrapPrefix(bsPrefix, 'form-label');
    let columnClass = 'col-form-label';
    if (typeof column === 'string')
        columnClass = `${columnClass} ${columnClass}-${column}`;
    const classes = classNames(className, bsPrefix, visuallyHidden && 'visually-hidden', column && columnClass);
    warning(controlId == null || !htmlFor, '`controlId` is ignored on `<FormLabel>` when `htmlFor` is specified.');
    htmlFor = htmlFor || controlId;
    if (column)
        return (React.createElement(Col, { ref: ref, as: "label", className: classes, htmlFor: htmlFor, ...props }));
    return (
    // eslint-disable-next-line jsx-a11y/label-has-for, jsx-a11y/label-has-associated-control
    React.createElement(Component, { ref: ref, className: classes, htmlFor: htmlFor, ...props }));
});
FormLabel.displayName = 'FormLabel';
FormLabel.propTypes = propTypes$4;
FormLabel.defaultProps = defaultProps$1;

const propTypes$3 = {
    /**
     * @default {'form-select'}
     */
    bsPrefix: PropTypes.string,
    /**
     * Size variants
     *
     * @type {('sm'|'lg')}
     */
    size: PropTypes.string,
    /** Make the control disabled */
    disabled: PropTypes.bool,
    /**
     * The `value` attribute of underlying input
     *
     * @controllable onChange
     * */
    value: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.arrayOf(PropTypes.string),
        PropTypes.number,
    ]),
    /** A callback fired when the `value` prop changes */
    onChange: PropTypes.func,
    /** Add "valid" validation styles to the control */
    isValid: PropTypes.bool,
    /** Add "invalid" validation styles to the control and accompanying label */
    isInvalid: PropTypes.bool,
};
const FormSelect = React.forwardRef(({ bsPrefix, size, className, isValid = false, isInvalid = false, id, ...props }, ref) => {
    const { controlId } = useContext(FormContext);
    bsPrefix = useBootstrapPrefix(bsPrefix, 'form-select');
    return (React.createElement("select", { ...props, ref: ref, className: classNames(className, bsPrefix, size && `${bsPrefix}-${size}`, isValid && `is-valid`, isInvalid && `is-invalid`), id: id || controlId }));
});
FormSelect.displayName = 'FormSelect';
FormSelect.propTypes = propTypes$3;

const propTypes$2 = {
    /** @default 'form-text' */
    bsPrefix: PropTypes.string,
    /**
     * The FormText `ref` will be forwarded to the underlying element.
     * Unless the FormText is rendered `as` a composite component,
     * it will be a DOM node, when resolved.
     *
     * @type {ReactRef}
     * @alias ref
     */
    _ref: PropTypes.any,
    /**
     * A convenience prop for add the `text-muted` class,
     * since it's so commonly used here.
     */
    muted: PropTypes.bool,
    as: PropTypes.elementType,
};
const FormText = React.forwardRef(
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
({ bsPrefix, className, as: Component = 'small', muted, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'form-text');
    return (React.createElement(Component, { ...props, ref: ref, className: classNames(className, bsPrefix, muted && 'text-muted') }));
});
FormText.displayName = 'FormText';
FormText.propTypes = propTypes$2;

const Switch = React.forwardRef((props, ref) => (React.createElement(FormCheck$1, { ...props, ref: ref, type: "switch" })));
Switch.displayName = 'Switch';
var Switch$1 = Object.assign(Switch, {
    Input: FormCheck$1.Input,
    Label: FormCheck$1.Label,
});

const propTypes$1 = {
    /**
     * The Form `ref` will be forwarded to the underlying element,
     * which means, unless it's rendered `as` a composite component,
     * it will be a DOM node, when resolved.
     *
     * @type {ReactRef}
     * @alias ref
     */
    _ref: PropTypes.any,
    /**
     * Mark a form as having been validated. Setting it to `true` will
     * toggle any validation styles on the forms elements.
     */
    validated: PropTypes.bool,
    as: PropTypes.elementType,
};
const Form = React.forwardRef(({ className, validated, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'form', ...props }, ref) => (React.createElement(Component, { ...props, ref: ref, className: classNames(className, validated && 'was-validated') })));
Form.displayName = 'Form';
Form.propTypes = propTypes$1;
Object.assign(Form, {
    Group: FormGroup,
    Control: FormControl$1,
    Check: FormCheck$1,
    Switch: Switch$1,
    Label: FormLabel,
    Text: FormText,
    // Range: FormRange,
    Select: FormSelect,
});

const defaultProps = {
    size: 'sm',
    step: 1,
};
const propTypes = {
    step: PropTypes.number,
    size: PropTypes.oneOf(['sm', 'lg']),
    count: PropTypes.number.isRequired,
    setCount: PropTypes.func.isRequired,
    disabled: PropTypes.bool,
    variant: PropTypes.oneOf([
        'primary',
        'secondary',
        'success',
        'danger',
        'warning',
        'info',
        'dark',
        'light',
        'link',
        'outline-primary',
        'outline-secondary',
        'outline-success',
        'outline-danger',
        'outline-warning',
        'outline-info',
        'outline-dark',
        'outline-light',
    ]),
};
const QuantityToggle = React.forwardRef(({ size, step = 1, disabled, variant, count, setCount, ...props }, ref) => {
    const buttonProps = { disabled, variant };
    const onPlus = () => {
        setCount(count + step);
    };
    const onMinus = () => {
        if (count < 1)
            setCount(0);
        else
            setCount(count - step);
    };
    React.useEffect(() => {
        if (count < 0)
            setCount(0);
    }, []);
    return (React.createElement(React.Fragment, null,
        React.createElement(FormLabel, { className: "visually-hidden" }, "quantity-toggle"),
        React.createElement(InputGroup$1, { size: size, variant: "quantity-toggle" },
            React.createElement(Button, { onClick: onMinus, ...buttonProps, "aria-label": `decrease by ${step}` },
                React.createElement("i", { className: "bi bi-dash" })),
            React.createElement(FormControl$1, { ...props, disabled: disabled, ref: ref, type: "number", className: "text-center", value: count, name: "quantity", onChange: (e) => {
                    setCount(parseInt(e.target.value));
                }, min: 0 }),
            React.createElement("div", { id: "quantitytoggle-announcer", role: "region", "aria-live": "assertive", className: "visually-hidden" }, count),
            React.createElement(Button, { onClick: onPlus, ...buttonProps, "aria-label": `increase by ${step}` },
                React.createElement("i", { className: "bi bi-plus" })))));
});
QuantityToggle.displayName = 'QuantityToggle';
QuantityToggle.defaultProps = defaultProps;
QuantityToggle.propTypes = propTypes;

export { QuantityToggle };
