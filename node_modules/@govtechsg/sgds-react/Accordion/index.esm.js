'use client';
import classNames from 'classnames';
import * as React from 'react';
import React__default, { useContext, useMemo } from 'react';
import PropTypes from 'prop-types';
import { useUncontrolled } from 'uncontrollable';
import css from 'dom-helpers/css';
import { EXITED, EXITING, ENTERING, ENTERED } from 'react-transition-group/Transition';
import transitionEndListener from '../utils/transitionEndListener';
import createChainedFunction from '../utils/createChainedFunction';
import triggerBrowserReflow from '../utils/triggerBrowserReflow';
import TransitionWrapper from '../utils/TransitionWrapper';

const ThemeContext = React.createContext({ prefixes: {} });
({
    prefixes: PropTypes.object,
    dir: PropTypes.string,
});
function useBootstrapPrefix(prefix, defaultPrefix) {
    const { prefixes } = useContext(ThemeContext);
    return prefix || prefixes[defaultPrefix] || `${defaultPrefix}`;
}
const SGDSWrapper = React.forwardRef(({ as: Tag = 'div', ...props }, ref) => {
    return React.createElement(Tag, { ref: ref, ...props, className: classNames(props.className, 'sgds') });
});

const MARGINS = {
    height: ['marginTop', 'marginBottom'],
    width: ['marginLeft', 'marginRight'],
};
function getDefaultDimensionValue(dimension, elem) {
    const offset = `offset${dimension[0].toUpperCase()}${dimension.slice(1)}`;
    const value = elem[offset];
    const margins = MARGINS[dimension];
    return (value +
        // @ts-ignore
        parseInt(css(elem, margins[0]), 10) +
        // @ts-ignore
        parseInt(css(elem, margins[1]), 10));
}
const collapseStyles = {
    [EXITED]: 'collapse',
    [EXITING]: 'collapsing',
    [ENTERING]: 'collapsing',
    [ENTERED]: 'collapse show',
};
const propTypes$6 = {
    /**
     * Show the component; triggers the expand or collapse animation
     */
    in: PropTypes.bool,
    /**
     * Wait until the first "enter" transition to mount the component (add it to the DOM)
     */
    mountOnEnter: PropTypes.bool,
    /**
     * Unmount the component (remove it from the DOM) when it is collapsed
     */
    unmountOnExit: PropTypes.bool,
    /**
     * Run the expand animation when the component mounts, if it is initially
     * shown
     */
    appear: PropTypes.bool,
    /**
     * Duration of the collapse animation in milliseconds, to ensure that
     * finishing callbacks are fired even if the original browser transition end
     * events are canceled
     */
    timeout: PropTypes.number,
    /**
     * Callback fired before the component expands
     */
    onEnter: PropTypes.func,
    /**
     * Callback fired after the component starts to expand
     */
    onEntering: PropTypes.func,
    /**
     * Callback fired after the component has expanded
     */
    onEntered: PropTypes.func,
    /**
     * Callback fired before the component collapses
     */
    onExit: PropTypes.func,
    /**
     * Callback fired after the component starts to collapse
     */
    onExiting: PropTypes.func,
    /**
     * Callback fired after the component has collapsed
     */
    onExited: PropTypes.func,
    /**
     * The dimension used when collapsing, or a function that returns the
     * dimension
     */
    dimension: PropTypes.oneOfType([
        PropTypes.oneOf(['height', 'width']),
        PropTypes.func,
    ]),
    /**
     * Function that returns the height or width of the animating DOM node
     *
     * Allows for providing some custom logic for how much the Collapse component
     * should animate in its specified dimension. Called with the current
     * dimension prop value and the DOM node.
     *
     * @default element.offsetWidth | element.offsetHeight
     */
    getDimensionValue: PropTypes.func,
    /**
     * ARIA role of collapsible element
     */
    role: PropTypes.string,
    /**
     * You must provide a single JSX child element to this component and that element cannot be a \<React.Fragment\>
     */
    children: PropTypes.element.isRequired,
};
const defaultProps = {
    in: false,
    timeout: 300,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
    getDimensionValue: getDefaultDimensionValue,
};
const Collapse = React__default.forwardRef(({ onEnter, onEntering, onEntered, onExit, onExiting, className, children, dimension = 'height', getDimensionValue = getDefaultDimensionValue, ...props }, ref) => {
    /* Compute dimension */
    const computedDimension = typeof dimension === 'function' ? dimension() : dimension;
    /* -- Expanding -- */
    const handleEnter = useMemo(() => createChainedFunction((elem) => {
        elem.style[computedDimension] = '0';
    }, onEnter), [computedDimension, onEnter]);
    const handleEntering = useMemo(() => createChainedFunction((elem) => {
        const scroll = `scroll${computedDimension[0].toUpperCase()}${computedDimension.slice(1)}`;
        elem.style[computedDimension] = `${elem[scroll]}px`;
    }, onEntering), [computedDimension, onEntering]);
    const handleEntered = useMemo(() => createChainedFunction((elem) => {
        elem.style[computedDimension] = null;
    }, onEntered), [computedDimension, onEntered]);
    /* -- Collapsing -- */
    const handleExit = useMemo(() => createChainedFunction((elem) => {
        elem.style[computedDimension] = `${getDimensionValue(computedDimension, elem)}px`;
        triggerBrowserReflow(elem);
    }, onExit), [onExit, getDimensionValue, computedDimension]);
    const handleExiting = useMemo(() => createChainedFunction((elem) => {
        elem.style[computedDimension] = null;
    }, onExiting), [computedDimension, onExiting]);
    return (React__default.createElement(TransitionWrapper, { ref: ref, addEndListener: transitionEndListener, ...props, "aria-expanded": props.role ? props.in : null, onEnter: handleEnter, onEntering: handleEntering, onEntered: handleEntered, onExit: handleExit, onExiting: handleExiting, childRef: children.ref }, (state, innerProps) => React__default.cloneElement(children, {
        ...innerProps,
        className: classNames(className, children.props.className, collapseStyles[state], computedDimension === 'width' && 'collapse-horizontal'),
    })));
});
// @ts-ignore
Collapse.propTypes = propTypes$6;
// @ts-ignore
Collapse.defaultProps = defaultProps;

function isAccordionItemSelected(activeEventKey, eventKey) {
    return Array.isArray(activeEventKey)
        ? activeEventKey.includes(eventKey)
        : activeEventKey === eventKey;
}
const context$1 = React.createContext({});
context$1.displayName = 'AccordionContext';

const propTypes$5 = {
    /** Set a custom element for this component */
    as: PropTypes.elementType,
    /**
     * A key that corresponds to the toggler that triggers this collapse's expand or collapse.
     */
    eventKey: PropTypes.string.isRequired,
    /** Children prop should only contain a single child, and is enforced as such */
    children: PropTypes.element.isRequired,
};
const AccordionCollapse = React.forwardRef(({ as: Component = 'div', bsPrefix, className, children, eventKey, ...props }, ref) => {
    const { activeEventKey } = useContext(context$1);
    bsPrefix = useBootstrapPrefix(bsPrefix, 'accordion-collapse');
    return (React.createElement(Collapse, { ref: ref, in: isAccordionItemSelected(activeEventKey, eventKey), ...props, className: classNames(className, bsPrefix) },
        React.createElement(Component, null, React.Children.only(children))));
});
AccordionCollapse.propTypes = propTypes$5;
AccordionCollapse.displayName = 'AccordionCollapse';

const context = React.createContext({
    eventKey: '',
});
context.displayName = 'AccordionItemContext';

const propTypes$4 = {
    /** Set a custom element for this component */
    as: PropTypes.elementType,
    /** @default 'accordion-body' */
    bsPrefix: PropTypes.string,
};
const AccordionBody = React.forwardRef(({ 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'div', bsPrefix, className, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'accordion-body');
    const { eventKey } = useContext(context);
    return (React.createElement(AccordionCollapse, { eventKey: eventKey },
        React.createElement(Component, { ref: ref, ...props, className: classNames(className, bsPrefix) })));
});
AccordionBody.propTypes = propTypes$4;
AccordionBody.displayName = 'AccordionBody';

const propTypes$3 = {
    /** Set a custom element for this component */
    as: PropTypes.elementType,
    /** @default 'accordion-button' */
    bsPrefix: PropTypes.string,
    /** A callback function for when this component is clicked */
    onClick: PropTypes.func,
};
function useAccordionButton(eventKey, onClick) {
    const { activeEventKey, onSelect, alwaysOpen } = useContext(context$1);
    return (e) => {
        /*
          Compare the event key in context with the given event key.
          If they are the same, then collapse the component.
        */
        let eventKeyPassed = eventKey === activeEventKey ? null : eventKey;
        if (alwaysOpen) {
            if (Array.isArray(activeEventKey)) {
                if (activeEventKey.includes(eventKey)) {
                    eventKeyPassed = activeEventKey.filter((k) => k !== eventKey);
                }
                else {
                    eventKeyPassed = [...activeEventKey, eventKey];
                }
            }
            else {
                // activeEventKey is undefined.
                eventKeyPassed = [eventKey];
            }
        }
        onSelect?.(eventKeyPassed, e);
        onClick?.(e);
    };
}
const AccordionButton = React.forwardRef(({ 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'button', bsPrefix, className, onClick, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'accordion-button');
    const { eventKey } = useContext(context);
    const accordionOnClick = useAccordionButton(eventKey, onClick);
    const { activeEventKey } = useContext(context$1);
    if (Component === 'button') {
        props.type = 'button';
    }
    return (React.createElement(Component, { ref: ref, onClick: accordionOnClick, ...props, "aria-expanded": eventKey === activeEventKey, className: classNames(className, bsPrefix, eventKey !== activeEventKey && 'collapsed') }));
});
AccordionButton.propTypes = propTypes$3;
AccordionButton.displayName = 'AccordionButton';

const propTypes$2 = {
    /** Set a custom element for this component */
    as: PropTypes.elementType,
    /** @default 'accordion-header' */
    bsPrefix: PropTypes.string,
    /** Click handler for the `AccordionButton` element */
    onClick: PropTypes.func,
};
const AccordionHeader = React.forwardRef(({ 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'h2', bsPrefix, className, children, onClick, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'accordion-header');
    return (React.createElement(Component, { ref: ref, ...props, className: classNames(className, bsPrefix) },
        React.createElement(AccordionButton, { onClick: onClick }, children)));
});
AccordionHeader.propTypes = propTypes$2;
AccordionHeader.displayName = 'AccordionHeader';

const propTypes$1 = {
    /** Set a custom element for this component */
    as: PropTypes.elementType,
    /** @default 'accordion-item' */
    bsPrefix: PropTypes.string,
    /**
     * A unique key used to control this item's collapse/expand.
     * @required
     */
    eventKey: PropTypes.string.isRequired,
};
const AccordionItem = React.forwardRef(({ 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'div', bsPrefix, className, eventKey, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'accordion-item');
    const contextValue = useMemo(() => ({
        eventKey,
    }), [eventKey]);
    return (React.createElement(context.Provider, { value: contextValue },
        React.createElement(Component, { ref: ref, ...props, className: classNames(className, bsPrefix) })));
});
AccordionItem.propTypes = propTypes$1;
AccordionItem.displayName = 'AccordionItem';

const propTypes = {
    /** Set a custom element for this component */
    as: PropTypes.elementType,
    /** @default 'accordion' */
    bsPrefix: PropTypes.string,
    /** The current active key that corresponds to the currently expanded card */
    activeKey: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),
    /** The default active key that is expanded on start */
    defaultActiveKey: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),
    /** Renders accordion edge-to-edge with its parent container */
    flush: PropTypes.bool,
    /** Allow accordion items to stay open when another item is opened */
    alwaysOpen: PropTypes.bool,
};
const Accordion = React.forwardRef((props, ref) => {
    const { 
    // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
    as: Component = 'div', activeKey, bsPrefix, className, onSelect, flush, alwaysOpen, ...controlledProps } = useUncontrolled(props, {
        activeKey: 'onSelect',
    });
    const prefix = useBootstrapPrefix(bsPrefix, 'accordion');
    const contextValue = useMemo(() => ({
        activeEventKey: activeKey,
        onSelect,
        alwaysOpen,
    }), [activeKey, onSelect, alwaysOpen]);
    return (React.createElement(context$1.Provider, { value: contextValue },
        React.createElement(SGDSWrapper, { as: Component, ref: ref, ...controlledProps, className: classNames(className, prefix, flush && `${prefix}-flush`) })));
});
Accordion.displayName = 'Accordion';
Accordion.propTypes = propTypes;
var Accordion$1 = Object.assign(Accordion, {
    Button: AccordionButton,
    Collapse: AccordionCollapse,
    Item: AccordionItem,
    Header: AccordionHeader,
    Body: AccordionBody,
});

export { Accordion$1 as Accordion, AccordionBody, AccordionButton, AccordionCollapse, context$1 as AccordionContext, AccordionHeader, AccordionItem, useAccordionButton };
