'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var classNames = require('classnames');
var addEventListener = require('dom-helpers/addEventListener');
var canUseDOM = require('dom-helpers/canUseDOM');
var ownerDocument = require('dom-helpers/ownerDocument');
var removeEventListener = require('dom-helpers/removeEventListener');
var getScrollbarSize = require('dom-helpers/scrollbarSize');
var useCallbackRef = require('@restart/hooks/useCallbackRef');
var useEventCallback = require('@restart/hooks/useEventCallback');
var useMergedRefs = require('@restart/hooks/useMergedRefs');
var useWillUnmount = require('@restart/hooks/useWillUnmount');
var transitionEnd = require('dom-helpers/transitionEnd');
var React = require('react');
var PropTypes = require('prop-types');
var BaseModal = require('@restart/ui/Modal');
var addClass = require('dom-helpers/addClass');
var css = require('dom-helpers/css');
var qsa = require('dom-helpers/querySelectorAll');
var removeClass = require('dom-helpers/removeClass');
var ModalManager = require('@restart/ui/ModalManager');
var Transition = require('react-transition-group/Transition');
var transitionEndListener = require('../utils/transitionEndListener');
var triggerBrowserReflow = require('../utils/triggerBrowserReflow');
var TransitionWrapper = require('../utils/TransitionWrapper');
var createWithBsPrefix = require('../utils/createWithBsPrefix');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var classNames__default = /*#__PURE__*/_interopDefaultLegacy(classNames);
var addEventListener__default = /*#__PURE__*/_interopDefaultLegacy(addEventListener);
var canUseDOM__default = /*#__PURE__*/_interopDefaultLegacy(canUseDOM);
var ownerDocument__default = /*#__PURE__*/_interopDefaultLegacy(ownerDocument);
var removeEventListener__default = /*#__PURE__*/_interopDefaultLegacy(removeEventListener);
var getScrollbarSize__default = /*#__PURE__*/_interopDefaultLegacy(getScrollbarSize);
var useCallbackRef__default = /*#__PURE__*/_interopDefaultLegacy(useCallbackRef);
var useEventCallback__default = /*#__PURE__*/_interopDefaultLegacy(useEventCallback);
var useMergedRefs__default = /*#__PURE__*/_interopDefaultLegacy(useMergedRefs);
var useWillUnmount__default = /*#__PURE__*/_interopDefaultLegacy(useWillUnmount);
var transitionEnd__default = /*#__PURE__*/_interopDefaultLegacy(transitionEnd);
var React__namespace = /*#__PURE__*/_interopNamespace(React);
var PropTypes__default = /*#__PURE__*/_interopDefaultLegacy(PropTypes);
var BaseModal__default = /*#__PURE__*/_interopDefaultLegacy(BaseModal);
var addClass__default = /*#__PURE__*/_interopDefaultLegacy(addClass);
var css__default = /*#__PURE__*/_interopDefaultLegacy(css);
var qsa__default = /*#__PURE__*/_interopDefaultLegacy(qsa);
var removeClass__default = /*#__PURE__*/_interopDefaultLegacy(removeClass);
var ModalManager__default = /*#__PURE__*/_interopDefaultLegacy(ModalManager);
var transitionEndListener__default = /*#__PURE__*/_interopDefaultLegacy(transitionEndListener);
var triggerBrowserReflow__default = /*#__PURE__*/_interopDefaultLegacy(triggerBrowserReflow);
var TransitionWrapper__default = /*#__PURE__*/_interopDefaultLegacy(TransitionWrapper);
var createWithBsPrefix__default = /*#__PURE__*/_interopDefaultLegacy(createWithBsPrefix);

const Selector = {
    FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',
    STICKY_CONTENT: '.sticky-top',
    NAVBAR_TOGGLER: '.navbar-toggler',
};
class BootstrapModalManager extends ModalManager__default["default"] {
    adjustAndStore(prop, element, adjust) {
        const actual = element.style[prop];
        // TODO: DOMStringMap and CSSStyleDeclaration aren't strictly compatible
        // @ts-ignore
        element.dataset[prop] = actual;
        css__default["default"](element, {
            [prop]: `${parseFloat(css__default["default"](element, prop)) + adjust}px`,
        });
    }
    restore(prop, element) {
        const value = element.dataset[prop];
        if (value !== undefined) {
            delete element.dataset[prop];
            css__default["default"](element, { [prop]: value });
        }
    }
    setContainerStyle(containerState) {
        super.setContainerStyle(containerState);
        const container = this.getElement();
        addClass__default["default"](container, 'modal-open');
        if (!containerState.scrollBarWidth)
            return;
        const paddingProp = this.isRTL ? 'paddingLeft' : 'paddingRight';
        const marginProp = this.isRTL ? 'marginLeft' : 'marginRight';
        qsa__default["default"](container, Selector.FIXED_CONTENT).forEach((el) => this.adjustAndStore(paddingProp, el, containerState.scrollBarWidth));
        qsa__default["default"](container, Selector.STICKY_CONTENT).forEach((el) => this.adjustAndStore(marginProp, el, -containerState.scrollBarWidth));
        qsa__default["default"](container, Selector.NAVBAR_TOGGLER).forEach((el) => this.adjustAndStore(marginProp, el, containerState.scrollBarWidth));
    }
    removeContainerStyle(containerState) {
        super.removeContainerStyle(containerState);
        const container = this.getElement();
        removeClass__default["default"](container, 'modal-open');
        const paddingProp = this.isRTL ? 'paddingLeft' : 'paddingRight';
        const marginProp = this.isRTL ? 'marginLeft' : 'marginRight';
        qsa__default["default"](container, Selector.FIXED_CONTENT).forEach((el) => this.restore(paddingProp, el));
        qsa__default["default"](container, Selector.STICKY_CONTENT).forEach((el) => this.restore(marginProp, el));
        qsa__default["default"](container, Selector.NAVBAR_TOGGLER).forEach((el) => this.restore(marginProp, el));
    }
}
let sharedManager;
function getSharedManager(options) {
    if (!sharedManager)
        sharedManager = new BootstrapModalManager(options);
    return sharedManager;
}

const propTypes$5 = {
    /**
     * Show the component; triggers the fade in or fade out animation
     */
    in: PropTypes__default["default"].bool,
    /**
     * Wait until the first "enter" transition to mount the component (add it to the DOM)
     */
    mountOnEnter: PropTypes__default["default"].bool,
    /**
     * Unmount the component (remove it from the DOM) when it is faded out
     */
    unmountOnExit: PropTypes__default["default"].bool,
    /**
     * Run the fade in animation when the component mounts, if it is initially
     * shown
     */
    appear: PropTypes__default["default"].bool,
    /**
     * Duration of the fade animation in milliseconds, to ensure that finishing
     * callbacks are fired even if the original browser transition end events are
     * canceled
     */
    timeout: PropTypes__default["default"].number,
    /**
     * Callback fired before the component fades in
     */
    onEnter: PropTypes__default["default"].func,
    /**
     * Callback fired after the component starts to fade in
     */
    onEntering: PropTypes__default["default"].func,
    /**
     * Callback fired after the has component faded in
     */
    onEntered: PropTypes__default["default"].func,
    /**
     * Callback fired before the component fades out
     */
    onExit: PropTypes__default["default"].func,
    /**
     * Callback fired after the component starts to fade out
     */
    onExiting: PropTypes__default["default"].func,
    /**
     * Callback fired after the component has faded out
     */
    onExited: PropTypes__default["default"].func,
    /**
     * You must provide a single JSX child element to this component and that element cannot be a \<React.Fragment\>
     */
    children: PropTypes__default["default"].element.isRequired,
    /**
     * Applies additional specified classes during the transition. Takes an object
     * where the keys correspond to the Transition status
     */
    transitionClasses: PropTypes__default["default"].object,
};
const defaultProps$4 = {
    in: false,
    timeout: 300,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
};
const fadeStyles = {
    [Transition.ENTERING]: 'show',
    [Transition.ENTERED]: 'show',
};
const Fade = React__namespace.forwardRef(({ className, children, transitionClasses = {}, ...props }, ref) => {
    const handleEnter = React.useCallback((node, isAppearing) => {
        triggerBrowserReflow__default["default"](node);
        props.onEnter?.(node, isAppearing);
    }, [props]);
    return (React__namespace.createElement(TransitionWrapper__default["default"], { ref: ref, addEndListener: transitionEndListener__default["default"], ...props, onEnter: handleEnter, childRef: children.ref }, (status, innerProps) => React__namespace.cloneElement(children, {
        ...innerProps,
        className: classNames__default["default"]('fade', className, children.props.className, 
        //@ts-ignore
        fadeStyles[status], transitionClasses[status]),
    })));
});
Fade.propTypes = propTypes$5;
Fade.defaultProps = defaultProps$4;
Fade.displayName = 'Fade';

const ModalBody = createWithBsPrefix__default["default"]('modal-body');

const ModalContext = React__namespace.createContext({
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    onHide() { },
});

const ThemeContext = React__namespace.createContext({ prefixes: {} });
({
    prefixes: PropTypes__default["default"].object,
    dir: PropTypes__default["default"].string,
});
function useBootstrapPrefix(prefix, defaultPrefix) {
    const { prefixes } = React.useContext(ThemeContext);
    return prefix || prefixes[defaultPrefix] || `${defaultPrefix}`;
}
// `sgds-${defaultPrefix}`
function useIsRTL() {
    const { dir } = React.useContext(ThemeContext);
    return dir === 'rtl';
}
const SGDSWrapper = React__namespace.forwardRef(({ as: Tag = 'div', ...props }, ref) => {
    return React__namespace.createElement(Tag, { ref: ref, ...props, className: classNames__default["default"](props.className, 'sgds') });
});

const propTypes$4 = {
    /** @default 'modal' */
    bsPrefix: PropTypes__default["default"].string,
    contentClassName: PropTypes__default["default"].string,
    /**
     * Render a large, extra large or small modal.
     *
     * @type ('sm'|'lg','xl')
     */
    size: PropTypes__default["default"].string,
    /**
     * Renders a fullscreen modal. Specifying a breakpoint will render the modal
     * as fullscreen __below__ the breakpoint size.
     *
     * @type (true|'sm-down'|'md-down'|'lg-down'|'xl-down'|'xxl-down')
     */
    fullscreen: PropTypes__default["default"].oneOfType([PropTypes__default["default"].bool, PropTypes__default["default"].string]),
    /**
     * Specify whether the Component should be vertically centered
     */
    centered: PropTypes__default["default"].bool,
    /**
     * Allows scrolling the `<Modal.Body>` instead of the entire Modal when overflowing.
     */
    scrollable: PropTypes__default["default"].bool,
};
const ModalDialog = React__namespace.forwardRef(({ bsPrefix, className, contentClassName, centered, size, fullscreen, children, scrollable, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'modal');
    const dialogClass = `${bsPrefix}-dialog`;
    const fullScreenClass = typeof fullscreen === 'string'
        ? `${bsPrefix}-fullscreen-${fullscreen}`
        : `${bsPrefix}-fullscreen`;
    return (React__namespace.createElement("div", { ...props, ref: ref, className: classNames__default["default"](dialogClass, className, size && `${bsPrefix}-${size}`, centered && `${dialogClass}-centered`, scrollable && `${dialogClass}-scrollable`, fullscreen && fullScreenClass) },
        React__namespace.createElement("div", { className: classNames__default["default"](`${bsPrefix}-content`, contentClassName) }, children)));
});
ModalDialog.displayName = 'ModalDialog';
ModalDialog.propTypes = propTypes$4;

const ModalFooter = createWithBsPrefix__default["default"]('modal-footer');

const propTypes$3 = {
    'aria-label': PropTypes__default["default"].string,
    onClick: PropTypes__default["default"].func,
    /**
     * Render different color variant for the button.
     *
     * Omitting this will render the default dark color.
     */
    variant: PropTypes__default["default"].oneOf(['white']),
};
const defaultProps$3 = {
    'aria-label': 'Close',
};
const CloseButton = React__namespace.forwardRef(({ className, variant, ...props }, ref) => (React__namespace.createElement("button", { ref: ref, type: "button", className: classNames__default["default"]('btn-close', variant && `btn-close-${variant}`, className), ...props })));
CloseButton.displayName = 'CloseButton';
CloseButton.propTypes = propTypes$3;
CloseButton.defaultProps = defaultProps$3;

const propTypes$2 = {
    /**
     * Provides an accessible label for the close
     * button. It is used for Assistive Technology when the label text is not
     * readable.
     */
    closeLabel: PropTypes__default["default"].string,
    /**
     * Sets the variant for close button.
     */
    closeVariant: PropTypes__default["default"].oneOf(['white']),
    /**
     * Specify whether the Component should contain a close button
     */
    closeButton: PropTypes__default["default"].bool,
    /**
     * A Callback fired when the close button is clicked. If used directly inside
     * a ModalContext, the onHide will automatically be propagated up
     * to the parent `onHide`.
     */
    onHide: PropTypes__default["default"].func,
};
const defaultProps$2 = {
    closeLabel: 'Close',
    closeButton: false,
};
const AbstractModalHeader = React__namespace.forwardRef(({ closeLabel, closeVariant, closeButton, onHide, children, ...props }, ref) => {
    const context = React.useContext(ModalContext);
    const handleClick = useEventCallback__default["default"](() => {
        context?.onHide();
        onHide?.();
    });
    return (React__namespace.createElement("div", { ref: ref, ...props },
        children,
        closeButton && (React__namespace.createElement(CloseButton, { "aria-label": closeLabel, variant: closeVariant, onClick: handleClick }))));
});
AbstractModalHeader.propTypes = propTypes$2;
AbstractModalHeader.defaultProps = defaultProps$2;

const propTypes$1 = {
    /**
     * @default 'modal-header'
     */
    bsPrefix: PropTypes__default["default"].string,
    /**
     * Provides an accessible label for the close
     * button. It is used for Assistive Technology when the label text is not
     * readable.
     */
    closeLabel: PropTypes__default["default"].string,
    /**
     * Sets the variant for close button.
     */
    closeVariant: PropTypes__default["default"].oneOf(['white']),
    /**
     * Specify whether the Component should contain a close button
     */
    closeButton: PropTypes__default["default"].bool,
    /**
     * A Callback fired when the close button is clicked. If used directly inside
     * a Modal component, the onHide will automatically be propagated up to the
     * parent Modal `onHide`.
     */
    onHide: PropTypes__default["default"].func,
};
const defaultProps$1 = {
    closeLabel: 'Close',
    closeButton: false,
};
const ModalHeader = React__namespace.forwardRef(({ bsPrefix, className, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'modal-header');
    return (React__namespace.createElement(AbstractModalHeader, { ref: ref, ...props, className: classNames__default["default"](className, bsPrefix) }));
});
ModalHeader.displayName = 'ModalHeader';
ModalHeader.propTypes = propTypes$1;
ModalHeader.defaultProps = defaultProps$1;

const ModalTitle = createWithBsPrefix__default["default"]('modal-title', {
    Component: 'h3',
});

const propTypes = {
    /**
     * @default 'modal'
     */
    bsPrefix: PropTypes__default["default"].string,
    /**
     * Render a large, extra large or small modal.
     * When not provided, the modal is rendered with medium (default) size.
     * @type ('sm'|'lg'|'xl')
     */
    size: PropTypes__default["default"].string,
    /**
     * Renders a fullscreen modal. Specifying a breakpoint will render the modal
     * as fullscreen __below__ the breakpoint size.
     *
     * @type (true|'sm-down'|'md-down'|'lg-down'|'xl-down'|'xxl-down')
     */
    fullscreen: PropTypes__default["default"].oneOfType([PropTypes__default["default"].bool, PropTypes__default["default"].string]),
    /**
     * vertically center the Dialog in the window
     */
    centered: PropTypes__default["default"].bool,
    /**
     * Include a backdrop component. Specify 'static' for a backdrop that doesn't
     * trigger an "onHide" when clicked.
     */
    backdrop: PropTypes__default["default"].oneOf(['static', true, false]),
    /**
     * Add an optional extra class name to .modal-backdrop
     * It could end up looking like class="modal-backdrop foo-modal-backdrop in".
     */
    backdropClassName: PropTypes__default["default"].string,
    /**
     * Close the modal when escape key is pressed
     */
    keyboard: PropTypes__default["default"].bool,
    /**
     * Allows scrolling the `<Modal.Body>` instead of the entire Modal when overflowing.
     */
    scrollable: PropTypes__default["default"].bool,
    /**
     * Open and close the Modal with a slide and fade animation.
     */
    animation: PropTypes__default["default"].bool,
    /**
     * A css class to apply to the Modal dialog DOM node.
     */
    dialogClassName: PropTypes__default["default"].string,
    /**
     * Add an optional extra class name to .modal-content
     */
    contentClassName: PropTypes__default["default"].string,
    /**
     * A Component type that provides the modal content Markup. This is a useful
     * prop when you want to use your own styles and markup to create a custom
     * modal component.
     */
    dialogAs: PropTypes__default["default"].elementType,
    /**
     * When `true` The modal will automatically shift focus to itself when it
     * opens, and replace it to the last focused element when it closes.
     * Generally this should never be set to false as it makes the Modal less
     * accessible to assistive technologies, like screen-readers.
     */
    autoFocus: PropTypes__default["default"].bool,
    /**
     * When `true` The modal will prevent focus from leaving the Modal while
     * open. Consider leaving the default value here, as it is necessary to make
     * the Modal work well with assistive technologies, such as screen readers.
     */
    enforceFocus: PropTypes__default["default"].bool,
    /**
     * When `true` The modal will restore focus to previously focused element once
     * modal is hidden
     */
    restoreFocus: PropTypes__default["default"].bool,
    /**
     * Options passed to focus function when `restoreFocus` is set to `true`
     *
     * @link  https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus#Parameters
     */
    restoreFocusOptions: PropTypes__default["default"].shape({
        preventScroll: PropTypes__default["default"].bool,
    }),
    /**
     * When `true` The modal will show itself.
     */
    show: PropTypes__default["default"].bool,
    /**
     * A callback fired when the Modal is opening.
     */
    onShow: PropTypes__default["default"].func,
    /**
     * A callback fired when the header closeButton or non-static backdrop is
     * clicked. Required if either are specified.
     */
    onHide: PropTypes__default["default"].func,
    /**
     * A callback fired when the escape key, if specified in `keyboard`, is pressed.
     */
    onEscapeKeyDown: PropTypes__default["default"].func,
    /**
     * Callback fired before the Modal transitions in
     */
    onEnter: PropTypes__default["default"].func,
    /**
     * Callback fired as the Modal begins to transition in
     */
    onEntering: PropTypes__default["default"].func,
    /**
     * Callback fired after the Modal finishes transitioning in
     */
    onEntered: PropTypes__default["default"].func,
    /**
     * Callback fired right before the Modal transitions out
     */
    onExit: PropTypes__default["default"].func,
    /**
     * Callback fired as the Modal begins to transition out
     */
    onExiting: PropTypes__default["default"].func,
    /**
     * Callback fired after the Modal finishes transitioning out
     */
    onExited: PropTypes__default["default"].func,
    /**
     * A ModalManager instance used to track and manage the state of open
     * Modals. Useful when customizing how modals interact within a container
     */
    manager: PropTypes__default["default"].object,
    /**
     * @private
     */
    container: PropTypes__default["default"].any,
    'aria-labelledby': PropTypes__default["default"].string,
    'aria-describedby': PropTypes__default["default"].string,
    'aria-label': PropTypes__default["default"].string,
    /**
     * Conveys centered align style to Modal
     */
    centeredAlignVariant: PropTypes__default["default"].bool,
};
const defaultProps = {
    show: false,
    backdrop: true,
    keyboard: true,
    autoFocus: true,
    enforceFocus: true,
    restoreFocus: true,
    animation: true,
    dialogAs: ModalDialog,
    centeredAlignVariant: false,
};
function DialogTransition(props) {
    return React__namespace.createElement(Fade, { ...props, timeout: null });
}
function BackdropTransition(props) {
    return React__namespace.createElement(Fade, { ...props, timeout: null });
}
/* eslint-enable no-use-before-define */
const Modal = React__namespace.forwardRef(({ bsPrefix, className, style, dialogClassName, contentClassName, children, dialogAs: Dialog = ModalDialog, 'aria-labelledby': ariaLabelledby, 'aria-describedby': ariaDescribedby, 'aria-label': ariaLabel, centeredAlignVariant, 
/* BaseModal props */
show, animation, backdrop, keyboard, onEscapeKeyDown, onShow, onHide, container, autoFocus, enforceFocus, restoreFocus, restoreFocusOptions, onEntered, onExit, onExiting, onEnter, onEntering, onExited, backdropClassName, manager: propsManager, ...props }, ref) => {
    const [modalStyle, setStyle] = React.useState({});
    const [animateStaticModal, setAnimateStaticModal] = React.useState(false);
    const waitingForMouseUpRef = React.useRef(false);
    const ignoreBackdropClickRef = React.useRef(false);
    const removeStaticModalAnimationRef = React.useRef(null);
    const [modal, setModalRef] = useCallbackRef__default["default"]();
    const mergedRef = useMergedRefs__default["default"](ref, setModalRef);
    const handleHide = useEventCallback__default["default"](onHide);
    const isRTL = useIsRTL();
    bsPrefix = useBootstrapPrefix(bsPrefix, 'modal');
    const modalContext = React.useMemo(() => ({
        onHide: handleHide,
    }), [handleHide]);
    function getModalManager() {
        if (propsManager)
            return propsManager;
        return getSharedManager({ isRTL });
    }
    function updateDialogStyle(node) {
        if (!canUseDOM__default["default"])
            return;
        const containerIsOverflowing = getModalManager().getScrollbarWidth() > 0;
        const modalIsOverflowing = node.scrollHeight >
            ownerDocument__default["default"](node).documentElement.clientHeight;
        setStyle({
            paddingRight: containerIsOverflowing && !modalIsOverflowing
                ? getScrollbarSize__default["default"]()
                : undefined,
            paddingLeft: !containerIsOverflowing && modalIsOverflowing
                ? getScrollbarSize__default["default"]()
                : undefined,
        });
    }
    const handleWindowResize = useEventCallback__default["default"](() => {
        if (modal) {
            updateDialogStyle(modal.dialog);
        }
    });
    useWillUnmount__default["default"](() => {
        removeEventListener__default["default"](window, 'resize', handleWindowResize);
        removeStaticModalAnimationRef.current?.();
    });
    // We prevent the modal from closing during a drag by detecting where the
    // the click originates from. If it starts in the modal and then ends outside
    // don't close.
    const handleDialogMouseDown = () => {
        waitingForMouseUpRef.current = true;
    };
    const handleMouseUp = (e) => {
        if (waitingForMouseUpRef.current &&
            modal &&
            e.target === modal.dialog) {
            ignoreBackdropClickRef.current = true;
        }
        waitingForMouseUpRef.current = false;
    };
    const handleStaticModalAnimation = () => {
        setAnimateStaticModal(true);
        removeStaticModalAnimationRef.current = transitionEnd__default["default"](modal.dialog, () => {
            setAnimateStaticModal(false);
        });
    };
    const handleStaticBackdropClick = (e) => {
        if (e.target !== e.currentTarget) {
            return;
        }
        handleStaticModalAnimation();
    };
    const handleClick = (e) => {
        if (backdrop === 'static') {
            handleStaticBackdropClick(e);
            return;
        }
        if (ignoreBackdropClickRef.current || e.target !== e.currentTarget) {
            ignoreBackdropClickRef.current = false;
            return;
        }
        onHide?.();
    };
    const handleEscapeKeyDown = (e) => {
        if (!keyboard && backdrop === 'static') {
            // Call preventDefault to stop modal from closing in restart ui,
            // then play our animation.
            e.preventDefault();
            handleStaticModalAnimation();
        }
        else if (keyboard && onEscapeKeyDown) {
            onEscapeKeyDown(e);
        }
    };
    const handleEnter = (node, isAppearing) => {
        if (node) {
            node.style.display = 'block';
            updateDialogStyle(node);
        }
        onEnter?.(node, isAppearing);
    };
    const handleExit = (node) => {
        removeStaticModalAnimationRef.current?.();
        onExit?.(node);
    };
    const handleEntering = (node, isAppearing) => {
        onEntering?.(node, isAppearing);
        // FIXME: This should work even when animation is disabled.
        addEventListener__default["default"](window, 'resize', handleWindowResize);
    };
    const handleExited = (node) => {
        if (node)
            node.style.display = ''; // RHL removes it sometimes
        onExited?.(node);
        // FIXME: This should work even when animation is disabled.
        removeEventListener__default["default"](window, 'resize', handleWindowResize);
    };
    const renderBackdrop = React.useCallback((backdropProps) => (React__namespace.createElement("div", { ...backdropProps, className: classNames__default["default"](`${bsPrefix}-backdrop`, backdropClassName, !animation && 'show') })), [animation, backdropClassName, bsPrefix]);
    const baseModalStyle = { ...style, ...modalStyle };
    // Sets `display` always block when `animation` is false
    if (!animation) {
        baseModalStyle.display = 'block';
    }
    const renderDialog = (dialogProps) => (React__namespace.createElement(SGDSWrapper, { role: "dialog", ...dialogProps, style: baseModalStyle, className: classNames__default["default"](className, bsPrefix, animateStaticModal && `${bsPrefix}-static`), onClick: backdrop ? handleClick : undefined, onMouseUp: handleMouseUp, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby, "aria-describedby": ariaDescribedby, variant: centeredAlignVariant ? 'centered-align-icon' : undefined },
        React__namespace.createElement(Dialog, { ...props, onMouseDown: handleDialogMouseDown, className: dialogClassName, contentClassName: contentClassName }, children)));
    return (React__namespace.createElement(ModalContext.Provider, { value: modalContext },
        React__namespace.createElement(BaseModal__default["default"], { show: show, ref: mergedRef, backdrop: backdrop, container: container, keyboard // Always set true - see handleEscapeKeyDown
            : true, autoFocus: autoFocus, enforceFocus: enforceFocus, restoreFocus: restoreFocus, restoreFocusOptions: restoreFocusOptions, onEscapeKeyDown: handleEscapeKeyDown, onShow: onShow, onHide: onHide, onEnter: handleEnter, onEntering: handleEntering, onEntered: onEntered, onExit: handleExit, onExiting: onExiting, onExited: handleExited, manager: getModalManager(), transition: animation
                ? DialogTransition
                : undefined, backdropTransition: animation
                ? BackdropTransition
                : undefined, renderBackdrop: renderBackdrop, renderDialog: renderDialog })));
});
Modal.displayName = 'Modal';
Modal.propTypes = propTypes;
Modal.defaultProps = defaultProps;
var Modal$1 = Object.assign(Modal, {
    Body: ModalBody,
    Header: ModalHeader,
    Title: ModalTitle,
    Footer: ModalFooter,
    Dialog: ModalDialog,
    TRANSITION_DURATION: 300,
    BACKDROP_TRANSITION_DURATION: 150,
});

exports.Modal = Modal$1;
exports.ModalBody = ModalBody;
exports.ModalDialog = ModalDialog;
exports.ModalFooter = ModalFooter;
exports.ModalHeader = ModalHeader;
exports.ModalTitle = ModalTitle;
