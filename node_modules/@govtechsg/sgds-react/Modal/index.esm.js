'use client';
import classNames from 'classnames';
import addEventListener from 'dom-helpers/addEventListener';
import canUseDOM from 'dom-helpers/canUseDOM';
import ownerDocument from 'dom-helpers/ownerDocument';
import removeEventListener from 'dom-helpers/removeEventListener';
import getScrollbarSize from 'dom-helpers/scrollbarSize';
import useCallbackRef from '@restart/hooks/useCallbackRef';
import useEventCallback from '@restart/hooks/useEventCallback';
import useMergedRefs from '@restart/hooks/useMergedRefs';
import useWillUnmount from '@restart/hooks/useWillUnmount';
import transitionEnd from 'dom-helpers/transitionEnd';
import * as React from 'react';
import { useCallback, useContext, useState, useRef, useMemo } from 'react';
import PropTypes from 'prop-types';
import BaseModal from '@restart/ui/Modal';
import addClass from 'dom-helpers/addClass';
import css from 'dom-helpers/css';
import qsa from 'dom-helpers/querySelectorAll';
import removeClass from 'dom-helpers/removeClass';
import ModalManager from '@restart/ui/ModalManager';
import { ENTERING, ENTERED } from 'react-transition-group/Transition';
import transitionEndListener from '../utils/transitionEndListener';
import triggerBrowserReflow from '../utils/triggerBrowserReflow';
import TransitionWrapper from '../utils/TransitionWrapper';
import createWithBsPrefix from '../utils/createWithBsPrefix';

const Selector = {
    FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',
    STICKY_CONTENT: '.sticky-top',
    NAVBAR_TOGGLER: '.navbar-toggler',
};
class BootstrapModalManager extends ModalManager {
    adjustAndStore(prop, element, adjust) {
        const actual = element.style[prop];
        // TODO: DOMStringMap and CSSStyleDeclaration aren't strictly compatible
        // @ts-ignore
        element.dataset[prop] = actual;
        css(element, {
            [prop]: `${parseFloat(css(element, prop)) + adjust}px`,
        });
    }
    restore(prop, element) {
        const value = element.dataset[prop];
        if (value !== undefined) {
            delete element.dataset[prop];
            css(element, { [prop]: value });
        }
    }
    setContainerStyle(containerState) {
        super.setContainerStyle(containerState);
        const container = this.getElement();
        addClass(container, 'modal-open');
        if (!containerState.scrollBarWidth)
            return;
        const paddingProp = this.isRTL ? 'paddingLeft' : 'paddingRight';
        const marginProp = this.isRTL ? 'marginLeft' : 'marginRight';
        qsa(container, Selector.FIXED_CONTENT).forEach((el) => this.adjustAndStore(paddingProp, el, containerState.scrollBarWidth));
        qsa(container, Selector.STICKY_CONTENT).forEach((el) => this.adjustAndStore(marginProp, el, -containerState.scrollBarWidth));
        qsa(container, Selector.NAVBAR_TOGGLER).forEach((el) => this.adjustAndStore(marginProp, el, containerState.scrollBarWidth));
    }
    removeContainerStyle(containerState) {
        super.removeContainerStyle(containerState);
        const container = this.getElement();
        removeClass(container, 'modal-open');
        const paddingProp = this.isRTL ? 'paddingLeft' : 'paddingRight';
        const marginProp = this.isRTL ? 'marginLeft' : 'marginRight';
        qsa(container, Selector.FIXED_CONTENT).forEach((el) => this.restore(paddingProp, el));
        qsa(container, Selector.STICKY_CONTENT).forEach((el) => this.restore(marginProp, el));
        qsa(container, Selector.NAVBAR_TOGGLER).forEach((el) => this.restore(marginProp, el));
    }
}
let sharedManager;
function getSharedManager(options) {
    if (!sharedManager)
        sharedManager = new BootstrapModalManager(options);
    return sharedManager;
}

const propTypes$5 = {
    /**
     * Show the component; triggers the fade in or fade out animation
     */
    in: PropTypes.bool,
    /**
     * Wait until the first "enter" transition to mount the component (add it to the DOM)
     */
    mountOnEnter: PropTypes.bool,
    /**
     * Unmount the component (remove it from the DOM) when it is faded out
     */
    unmountOnExit: PropTypes.bool,
    /**
     * Run the fade in animation when the component mounts, if it is initially
     * shown
     */
    appear: PropTypes.bool,
    /**
     * Duration of the fade animation in milliseconds, to ensure that finishing
     * callbacks are fired even if the original browser transition end events are
     * canceled
     */
    timeout: PropTypes.number,
    /**
     * Callback fired before the component fades in
     */
    onEnter: PropTypes.func,
    /**
     * Callback fired after the component starts to fade in
     */
    onEntering: PropTypes.func,
    /**
     * Callback fired after the has component faded in
     */
    onEntered: PropTypes.func,
    /**
     * Callback fired before the component fades out
     */
    onExit: PropTypes.func,
    /**
     * Callback fired after the component starts to fade out
     */
    onExiting: PropTypes.func,
    /**
     * Callback fired after the component has faded out
     */
    onExited: PropTypes.func,
    /**
     * You must provide a single JSX child element to this component and that element cannot be a \<React.Fragment\>
     */
    children: PropTypes.element.isRequired,
    /**
     * Applies additional specified classes during the transition. Takes an object
     * where the keys correspond to the Transition status
     */
    transitionClasses: PropTypes.object,
};
const defaultProps$4 = {
    in: false,
    timeout: 300,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
};
const fadeStyles = {
    [ENTERING]: 'show',
    [ENTERED]: 'show',
};
const Fade = React.forwardRef(({ className, children, transitionClasses = {}, ...props }, ref) => {
    const handleEnter = useCallback((node, isAppearing) => {
        triggerBrowserReflow(node);
        props.onEnter?.(node, isAppearing);
    }, [props]);
    return (React.createElement(TransitionWrapper, { ref: ref, addEndListener: transitionEndListener, ...props, onEnter: handleEnter, childRef: children.ref }, (status, innerProps) => React.cloneElement(children, {
        ...innerProps,
        className: classNames('fade', className, children.props.className, 
        //@ts-ignore
        fadeStyles[status], transitionClasses[status]),
    })));
});
Fade.propTypes = propTypes$5;
Fade.defaultProps = defaultProps$4;
Fade.displayName = 'Fade';

const ModalBody = createWithBsPrefix('modal-body');

const ModalContext = React.createContext({
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    onHide() { },
});

const ThemeContext = React.createContext({ prefixes: {} });
({
    prefixes: PropTypes.object,
    dir: PropTypes.string,
});
function useBootstrapPrefix(prefix, defaultPrefix) {
    const { prefixes } = useContext(ThemeContext);
    return prefix || prefixes[defaultPrefix] || `${defaultPrefix}`;
}
// `sgds-${defaultPrefix}`
function useIsRTL() {
    const { dir } = useContext(ThemeContext);
    return dir === 'rtl';
}
const SGDSWrapper = React.forwardRef(({ as: Tag = 'div', ...props }, ref) => {
    return React.createElement(Tag, { ref: ref, ...props, className: classNames(props.className, 'sgds') });
});

const propTypes$4 = {
    /** @default 'modal' */
    bsPrefix: PropTypes.string,
    contentClassName: PropTypes.string,
    /**
     * Render a large, extra large or small modal.
     *
     * @type ('sm'|'lg','xl')
     */
    size: PropTypes.string,
    /**
     * Renders a fullscreen modal. Specifying a breakpoint will render the modal
     * as fullscreen __below__ the breakpoint size.
     *
     * @type (true|'sm-down'|'md-down'|'lg-down'|'xl-down'|'xxl-down')
     */
    fullscreen: PropTypes.oneOfType([PropTypes.bool, PropTypes.string]),
    /**
     * Specify whether the Component should be vertically centered
     */
    centered: PropTypes.bool,
    /**
     * Allows scrolling the `<Modal.Body>` instead of the entire Modal when overflowing.
     */
    scrollable: PropTypes.bool,
};
const ModalDialog = React.forwardRef(({ bsPrefix, className, contentClassName, centered, size, fullscreen, children, scrollable, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'modal');
    const dialogClass = `${bsPrefix}-dialog`;
    const fullScreenClass = typeof fullscreen === 'string'
        ? `${bsPrefix}-fullscreen-${fullscreen}`
        : `${bsPrefix}-fullscreen`;
    return (React.createElement("div", { ...props, ref: ref, className: classNames(dialogClass, className, size && `${bsPrefix}-${size}`, centered && `${dialogClass}-centered`, scrollable && `${dialogClass}-scrollable`, fullscreen && fullScreenClass) },
        React.createElement("div", { className: classNames(`${bsPrefix}-content`, contentClassName) }, children)));
});
ModalDialog.displayName = 'ModalDialog';
ModalDialog.propTypes = propTypes$4;

const ModalFooter = createWithBsPrefix('modal-footer');

const propTypes$3 = {
    'aria-label': PropTypes.string,
    onClick: PropTypes.func,
    /**
     * Render different color variant for the button.
     *
     * Omitting this will render the default dark color.
     */
    variant: PropTypes.oneOf(['white']),
};
const defaultProps$3 = {
    'aria-label': 'Close',
};
const CloseButton = React.forwardRef(({ className, variant, ...props }, ref) => (React.createElement("button", { ref: ref, type: "button", className: classNames('btn-close', variant && `btn-close-${variant}`, className), ...props })));
CloseButton.displayName = 'CloseButton';
CloseButton.propTypes = propTypes$3;
CloseButton.defaultProps = defaultProps$3;

const propTypes$2 = {
    /**
     * Provides an accessible label for the close
     * button. It is used for Assistive Technology when the label text is not
     * readable.
     */
    closeLabel: PropTypes.string,
    /**
     * Sets the variant for close button.
     */
    closeVariant: PropTypes.oneOf(['white']),
    /**
     * Specify whether the Component should contain a close button
     */
    closeButton: PropTypes.bool,
    /**
     * A Callback fired when the close button is clicked. If used directly inside
     * a ModalContext, the onHide will automatically be propagated up
     * to the parent `onHide`.
     */
    onHide: PropTypes.func,
};
const defaultProps$2 = {
    closeLabel: 'Close',
    closeButton: false,
};
const AbstractModalHeader = React.forwardRef(({ closeLabel, closeVariant, closeButton, onHide, children, ...props }, ref) => {
    const context = useContext(ModalContext);
    const handleClick = useEventCallback(() => {
        context?.onHide();
        onHide?.();
    });
    return (React.createElement("div", { ref: ref, ...props },
        children,
        closeButton && (React.createElement(CloseButton, { "aria-label": closeLabel, variant: closeVariant, onClick: handleClick }))));
});
AbstractModalHeader.propTypes = propTypes$2;
AbstractModalHeader.defaultProps = defaultProps$2;

const propTypes$1 = {
    /**
     * @default 'modal-header'
     */
    bsPrefix: PropTypes.string,
    /**
     * Provides an accessible label for the close
     * button. It is used for Assistive Technology when the label text is not
     * readable.
     */
    closeLabel: PropTypes.string,
    /**
     * Sets the variant for close button.
     */
    closeVariant: PropTypes.oneOf(['white']),
    /**
     * Specify whether the Component should contain a close button
     */
    closeButton: PropTypes.bool,
    /**
     * A Callback fired when the close button is clicked. If used directly inside
     * a Modal component, the onHide will automatically be propagated up to the
     * parent Modal `onHide`.
     */
    onHide: PropTypes.func,
};
const defaultProps$1 = {
    closeLabel: 'Close',
    closeButton: false,
};
const ModalHeader = React.forwardRef(({ bsPrefix, className, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'modal-header');
    return (React.createElement(AbstractModalHeader, { ref: ref, ...props, className: classNames(className, bsPrefix) }));
});
ModalHeader.displayName = 'ModalHeader';
ModalHeader.propTypes = propTypes$1;
ModalHeader.defaultProps = defaultProps$1;

const ModalTitle = createWithBsPrefix('modal-title', {
    Component: 'h3',
});

const propTypes = {
    /**
     * @default 'modal'
     */
    bsPrefix: PropTypes.string,
    /**
     * Render a large, extra large or small modal.
     * When not provided, the modal is rendered with medium (default) size.
     * @type ('sm'|'lg'|'xl')
     */
    size: PropTypes.string,
    /**
     * Renders a fullscreen modal. Specifying a breakpoint will render the modal
     * as fullscreen __below__ the breakpoint size.
     *
     * @type (true|'sm-down'|'md-down'|'lg-down'|'xl-down'|'xxl-down')
     */
    fullscreen: PropTypes.oneOfType([PropTypes.bool, PropTypes.string]),
    /**
     * vertically center the Dialog in the window
     */
    centered: PropTypes.bool,
    /**
     * Include a backdrop component. Specify 'static' for a backdrop that doesn't
     * trigger an "onHide" when clicked.
     */
    backdrop: PropTypes.oneOf(['static', true, false]),
    /**
     * Add an optional extra class name to .modal-backdrop
     * It could end up looking like class="modal-backdrop foo-modal-backdrop in".
     */
    backdropClassName: PropTypes.string,
    /**
     * Close the modal when escape key is pressed
     */
    keyboard: PropTypes.bool,
    /**
     * Allows scrolling the `<Modal.Body>` instead of the entire Modal when overflowing.
     */
    scrollable: PropTypes.bool,
    /**
     * Open and close the Modal with a slide and fade animation.
     */
    animation: PropTypes.bool,
    /**
     * A css class to apply to the Modal dialog DOM node.
     */
    dialogClassName: PropTypes.string,
    /**
     * Add an optional extra class name to .modal-content
     */
    contentClassName: PropTypes.string,
    /**
     * A Component type that provides the modal content Markup. This is a useful
     * prop when you want to use your own styles and markup to create a custom
     * modal component.
     */
    dialogAs: PropTypes.elementType,
    /**
     * When `true` The modal will automatically shift focus to itself when it
     * opens, and replace it to the last focused element when it closes.
     * Generally this should never be set to false as it makes the Modal less
     * accessible to assistive technologies, like screen-readers.
     */
    autoFocus: PropTypes.bool,
    /**
     * When `true` The modal will prevent focus from leaving the Modal while
     * open. Consider leaving the default value here, as it is necessary to make
     * the Modal work well with assistive technologies, such as screen readers.
     */
    enforceFocus: PropTypes.bool,
    /**
     * When `true` The modal will restore focus to previously focused element once
     * modal is hidden
     */
    restoreFocus: PropTypes.bool,
    /**
     * Options passed to focus function when `restoreFocus` is set to `true`
     *
     * @link  https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus#Parameters
     */
    restoreFocusOptions: PropTypes.shape({
        preventScroll: PropTypes.bool,
    }),
    /**
     * When `true` The modal will show itself.
     */
    show: PropTypes.bool,
    /**
     * A callback fired when the Modal is opening.
     */
    onShow: PropTypes.func,
    /**
     * A callback fired when the header closeButton or non-static backdrop is
     * clicked. Required if either are specified.
     */
    onHide: PropTypes.func,
    /**
     * A callback fired when the escape key, if specified in `keyboard`, is pressed.
     */
    onEscapeKeyDown: PropTypes.func,
    /**
     * Callback fired before the Modal transitions in
     */
    onEnter: PropTypes.func,
    /**
     * Callback fired as the Modal begins to transition in
     */
    onEntering: PropTypes.func,
    /**
     * Callback fired after the Modal finishes transitioning in
     */
    onEntered: PropTypes.func,
    /**
     * Callback fired right before the Modal transitions out
     */
    onExit: PropTypes.func,
    /**
     * Callback fired as the Modal begins to transition out
     */
    onExiting: PropTypes.func,
    /**
     * Callback fired after the Modal finishes transitioning out
     */
    onExited: PropTypes.func,
    /**
     * A ModalManager instance used to track and manage the state of open
     * Modals. Useful when customizing how modals interact within a container
     */
    manager: PropTypes.object,
    /**
     * @private
     */
    container: PropTypes.any,
    'aria-labelledby': PropTypes.string,
    'aria-describedby': PropTypes.string,
    'aria-label': PropTypes.string,
    /**
     * Conveys centered align style to Modal
     */
    centeredAlignVariant: PropTypes.bool,
};
const defaultProps = {
    show: false,
    backdrop: true,
    keyboard: true,
    autoFocus: true,
    enforceFocus: true,
    restoreFocus: true,
    animation: true,
    dialogAs: ModalDialog,
    centeredAlignVariant: false,
};
function DialogTransition(props) {
    return React.createElement(Fade, { ...props, timeout: null });
}
function BackdropTransition(props) {
    return React.createElement(Fade, { ...props, timeout: null });
}
/* eslint-enable no-use-before-define */
const Modal = React.forwardRef(({ bsPrefix, className, style, dialogClassName, contentClassName, children, dialogAs: Dialog = ModalDialog, 'aria-labelledby': ariaLabelledby, 'aria-describedby': ariaDescribedby, 'aria-label': ariaLabel, centeredAlignVariant, 
/* BaseModal props */
show, animation, backdrop, keyboard, onEscapeKeyDown, onShow, onHide, container, autoFocus, enforceFocus, restoreFocus, restoreFocusOptions, onEntered, onExit, onExiting, onEnter, onEntering, onExited, backdropClassName, manager: propsManager, ...props }, ref) => {
    const [modalStyle, setStyle] = useState({});
    const [animateStaticModal, setAnimateStaticModal] = useState(false);
    const waitingForMouseUpRef = useRef(false);
    const ignoreBackdropClickRef = useRef(false);
    const removeStaticModalAnimationRef = useRef(null);
    const [modal, setModalRef] = useCallbackRef();
    const mergedRef = useMergedRefs(ref, setModalRef);
    const handleHide = useEventCallback(onHide);
    const isRTL = useIsRTL();
    bsPrefix = useBootstrapPrefix(bsPrefix, 'modal');
    const modalContext = useMemo(() => ({
        onHide: handleHide,
    }), [handleHide]);
    function getModalManager() {
        if (propsManager)
            return propsManager;
        return getSharedManager({ isRTL });
    }
    function updateDialogStyle(node) {
        if (!canUseDOM)
            return;
        const containerIsOverflowing = getModalManager().getScrollbarWidth() > 0;
        const modalIsOverflowing = node.scrollHeight >
            ownerDocument(node).documentElement.clientHeight;
        setStyle({
            paddingRight: containerIsOverflowing && !modalIsOverflowing
                ? getScrollbarSize()
                : undefined,
            paddingLeft: !containerIsOverflowing && modalIsOverflowing
                ? getScrollbarSize()
                : undefined,
        });
    }
    const handleWindowResize = useEventCallback(() => {
        if (modal) {
            updateDialogStyle(modal.dialog);
        }
    });
    useWillUnmount(() => {
        removeEventListener(window, 'resize', handleWindowResize);
        removeStaticModalAnimationRef.current?.();
    });
    // We prevent the modal from closing during a drag by detecting where the
    // the click originates from. If it starts in the modal and then ends outside
    // don't close.
    const handleDialogMouseDown = () => {
        waitingForMouseUpRef.current = true;
    };
    const handleMouseUp = (e) => {
        if (waitingForMouseUpRef.current &&
            modal &&
            e.target === modal.dialog) {
            ignoreBackdropClickRef.current = true;
        }
        waitingForMouseUpRef.current = false;
    };
    const handleStaticModalAnimation = () => {
        setAnimateStaticModal(true);
        removeStaticModalAnimationRef.current = transitionEnd(modal.dialog, () => {
            setAnimateStaticModal(false);
        });
    };
    const handleStaticBackdropClick = (e) => {
        if (e.target !== e.currentTarget) {
            return;
        }
        handleStaticModalAnimation();
    };
    const handleClick = (e) => {
        if (backdrop === 'static') {
            handleStaticBackdropClick(e);
            return;
        }
        if (ignoreBackdropClickRef.current || e.target !== e.currentTarget) {
            ignoreBackdropClickRef.current = false;
            return;
        }
        onHide?.();
    };
    const handleEscapeKeyDown = (e) => {
        if (!keyboard && backdrop === 'static') {
            // Call preventDefault to stop modal from closing in restart ui,
            // then play our animation.
            e.preventDefault();
            handleStaticModalAnimation();
        }
        else if (keyboard && onEscapeKeyDown) {
            onEscapeKeyDown(e);
        }
    };
    const handleEnter = (node, isAppearing) => {
        if (node) {
            node.style.display = 'block';
            updateDialogStyle(node);
        }
        onEnter?.(node, isAppearing);
    };
    const handleExit = (node) => {
        removeStaticModalAnimationRef.current?.();
        onExit?.(node);
    };
    const handleEntering = (node, isAppearing) => {
        onEntering?.(node, isAppearing);
        // FIXME: This should work even when animation is disabled.
        addEventListener(window, 'resize', handleWindowResize);
    };
    const handleExited = (node) => {
        if (node)
            node.style.display = ''; // RHL removes it sometimes
        onExited?.(node);
        // FIXME: This should work even when animation is disabled.
        removeEventListener(window, 'resize', handleWindowResize);
    };
    const renderBackdrop = useCallback((backdropProps) => (React.createElement("div", { ...backdropProps, className: classNames(`${bsPrefix}-backdrop`, backdropClassName, !animation && 'show') })), [animation, backdropClassName, bsPrefix]);
    const baseModalStyle = { ...style, ...modalStyle };
    // Sets `display` always block when `animation` is false
    if (!animation) {
        baseModalStyle.display = 'block';
    }
    const renderDialog = (dialogProps) => (React.createElement(SGDSWrapper, { role: "dialog", ...dialogProps, style: baseModalStyle, className: classNames(className, bsPrefix, animateStaticModal && `${bsPrefix}-static`), onClick: backdrop ? handleClick : undefined, onMouseUp: handleMouseUp, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby, "aria-describedby": ariaDescribedby, variant: centeredAlignVariant ? 'centered-align-icon' : undefined },
        React.createElement(Dialog, { ...props, onMouseDown: handleDialogMouseDown, className: dialogClassName, contentClassName: contentClassName }, children)));
    return (React.createElement(ModalContext.Provider, { value: modalContext },
        React.createElement(BaseModal, { show: show, ref: mergedRef, backdrop: backdrop, container: container, keyboard // Always set true - see handleEscapeKeyDown
            : true, autoFocus: autoFocus, enforceFocus: enforceFocus, restoreFocus: restoreFocus, restoreFocusOptions: restoreFocusOptions, onEscapeKeyDown: handleEscapeKeyDown, onShow: onShow, onHide: onHide, onEnter: handleEnter, onEntering: handleEntering, onEntered: onEntered, onExit: handleExit, onExiting: onExiting, onExited: handleExited, manager: getModalManager(), transition: animation
                ? DialogTransition
                : undefined, backdropTransition: animation
                ? BackdropTransition
                : undefined, renderBackdrop: renderBackdrop, renderDialog: renderDialog })));
});
Modal.displayName = 'Modal';
Modal.propTypes = propTypes;
Modal.defaultProps = defaultProps;
var Modal$1 = Object.assign(Modal, {
    Body: ModalBody,
    Header: ModalHeader,
    Title: ModalTitle,
    Footer: ModalFooter,
    Dialog: ModalDialog,
    TRANSITION_DURATION: 300,
    BACKDROP_TRANSITION_DURATION: 150,
});

export { Modal$1 as Modal, ModalBody, ModalDialog, ModalFooter, ModalHeader, ModalTitle };
