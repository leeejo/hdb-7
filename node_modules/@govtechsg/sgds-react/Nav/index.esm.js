'use client';
import classNames from 'classnames';
import PropTypes from 'prop-types';
import * as React from 'react';
import React__default, { useContext, useMemo, useCallback } from 'react';
import { useUncontrolled } from 'uncontrollable';
import BaseNav from '@restart/ui/Nav';
import createWithBsPrefix from '../utils/createWithBsPrefix';
import Anchor from '@restart/ui/Anchor';
import { useNavItem } from '@restart/ui/NavItem';
import SelectableContext, { makeEventKey } from '@restart/ui/SelectableContext';
import BaseDropdown from '@restart/ui/Dropdown';
import useEventCallback from '@restart/hooks/useEventCallback';
import { useDropdownItem } from '@restart/ui/DropdownItem';
import { useDropdownMenu } from '@restart/ui/DropdownMenu';
import useIsomorphicEffect from '@restart/hooks/useIsomorphicEffect';
import useMergedRefs from '@restart/hooks/useMergedRefs';
import warning from 'warning';
import { alignPropType, alignDirection } from '../utils/types';
import useWrappedRefWithWarning from '../utils/useWrappedRefWithWarning';
import { useDropdownToggle } from '@restart/ui/DropdownToggle';
import DropdownContext$1 from '@restart/ui/DropdownContext';
import { useButtonProps } from '@restart/ui/Button';
import css from 'dom-helpers/css';
import { EXITED, EXITING, ENTERING, ENTERED } from 'react-transition-group/Transition';
import transitionEndListener from '../utils/transitionEndListener';
import createChainedFunction from '../utils/createChainedFunction';
import triggerBrowserReflow from '../utils/triggerBrowserReflow';
import TransitionWrapper from '../utils/TransitionWrapper';

const ThemeContext = React.createContext({ prefixes: {} });
({
    prefixes: PropTypes.object,
    dir: PropTypes.string,
});
function useBootstrapPrefix(prefix, defaultPrefix) {
    const { prefixes } = useContext(ThemeContext);
    return prefix || prefixes[defaultPrefix] || `${defaultPrefix}`;
}
// `sgds-${defaultPrefix}`
function useIsRTL() {
    const { dir } = useContext(ThemeContext);
    return dir === 'rtl';
}
const SGDSWrapper = React.forwardRef(({ as: Tag = 'div', ...props }, ref) => {
    return React.createElement(Tag, { ref: ref, ...props, className: classNames(props.className, 'sgds') });
});

const context$1 = React.createContext(null);
context$1.displayName = 'NavbarContext';

const NavItem = createWithBsPrefix('nav-item', {
    Component: "li",
    displayName: 'NavItem'
});

const propTypes$c = {
    /**
     * @default 'nav-link'
     */
    bsPrefix: PropTypes.string,
    /**
     * The active state of the NavItem item.
     */
    active: PropTypes.bool,
    /**
     * The disabled state of the NavItem item.
     */
    disabled: PropTypes.bool,
    /**
     * The ARIA role for the `NavLink`, In the context of a 'tablist' parent Nav,
     * the role defaults to 'tab'
     * */
    role: PropTypes.string,
    /** The HTML href attribute for the `NavLink` */
    href: PropTypes.string,
    /**
     * Uniquely identifies the `NavItem` amongst its siblings,
     * used to determine and control the active state of the parent `Nav`
     */
    eventKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    /** @default 'a' */
    as: PropTypes.elementType,
};
const defaultProps$6 = {
    disabled: false,
};
const NavLink = React.forwardRef(({ bsPrefix, className, as: Component = Anchor, active, eventKey, 
// onClick,
...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'nav-link');
    const [navItemProps, meta] = useNavItem({
        key: makeEventKey(eventKey, props.href),
        active,
        ...props,
    });
    return (React.createElement(Component, { ...props, ...navItemProps, ref: ref, className: classNames(className, bsPrefix, props.disabled && 'disabled', meta.isActive && 'active'), "aria-current": meta.isActive ? "page" : "false" }));
});
NavLink.displayName = 'NavLink';
NavLink.propTypes = propTypes$c;
NavLink.defaultProps = defaultProps$6;

const DropdownContext = React.createContext({});
DropdownContext.displayName = 'DropdownContext';

const propTypes$b = {
    /** @default 'dropdown-item' */
    bsPrefix: PropTypes.string,
    /**
     * Highlight the menu item as active.
     */
    active: PropTypes.bool,
    /**
     * Disable the menu item, making it unselectable.
     */
    disabled: PropTypes.bool,
    /**
     * Value passed to the `onSelect` handler, useful for identifying the selected menu item.
     */
    eventKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    /**
     * HTML `href` attribute corresponding to `a.href`.
     */
    href: PropTypes.string,
    /**
     * Callback fired when the menu item is clicked.
     */
    onClick: PropTypes.func,
    as: PropTypes.elementType,
};
const DropdownItem = React.forwardRef(({ bsPrefix, className, eventKey, disabled = false, onClick, active, as: Component = Anchor, ...props }, ref) => {
    const prefix = 'dropdown-item';
    const [dropdownItemProps, meta] = useDropdownItem({
        key: eventKey,
        href: props.href,
        disabled,
        onClick,
        active,
    });
    return (React.createElement("li", null,
        React.createElement(Component, { ...props, ...dropdownItemProps, ref: ref, className: classNames(className, prefix, meta.isActive && 'active', disabled && 'disabled') })));
});
DropdownItem.displayName = 'DropdownItem';
DropdownItem.propTypes = propTypes$b;

const context = React.createContext(null);
context.displayName = 'InputGroupContext';

const propTypes$a = {
    /**
     * @default 'dropdown-menu'
     */
    bsPrefix: PropTypes.string,
    /** Controls the visibility of the Dropdown menu  */
    show: PropTypes.bool,
    /** Whether to render the dropdown menu in the DOM before the first time it is shown */
    renderOnMount: PropTypes.bool,
    /** Have the dropdown switch to it's opposite placement when necessary to stay on screen. */
    flip: PropTypes.bool,
    /**
     * Aligns the dropdown menu to the specified side of the container. You can also align
     * the menu responsively for breakpoints starting at `sm` and up. The alignment
     * direction will affect the specified breakpoint or larger.
     *
     * *Note: Using responsive alignment will disable Popper usage for positioning.*
     *
     * @type {"start"|"end"|{ sm: "start"|"end" }|{ md: "start"|"end" }|{ lg: "start"|"end" }|{ xl: "start"|"end"}|{ xxl: "start"|"end"} }
     */
    align: alignPropType,
    onSelect: PropTypes.func,
    /**
     * Which event when fired outside the component will cause it to be closed
     *
     * *Note: For custom dropdown components, you will have to pass the
     * `rootCloseEvent` to `<RootCloseWrapper>` in your custom dropdown menu
     * component ([similarly to how it is implemented in `<Dropdown.Menu>`](https://github.com/react-bootstrap/react-bootstrap/blob/v0.31.5/src/DropdownMenu.js#L115-L119)).*
     */
    rootCloseEvent: PropTypes.oneOf(['click', 'mousedown']),
    /**
     * Control the rendering of the DropdownMenu. All non-menu props
     * (listed here) are passed through to the `as` Component.
     *
     * If providing a custom, non DOM, component. the `show`, `close` and `align` props
     * are also injected and should be handled appropriately.
     */
    as: PropTypes.elementType,
    /**
     * A set of popper options and props passed directly to Popper.
     */
    popperConfig: PropTypes.object,
    /**
     * Menu color variant.
     *
     * Omitting this will use the default light color.
     */
    variant: PropTypes.string,
    /** @private Provides context when used in NavDropdown component  */
    isNav: PropTypes.bool,
};
const defaultProps$5 = {
    flip: true,
};
function getDropdownMenuPlacement(alignEnd, dropDirection, isRTL) {
    const topStart = isRTL ? 'top-end' : 'top-start';
    const topEnd = isRTL ? 'top-start' : 'top-end';
    const bottomStart = isRTL ? 'bottom-end' : 'bottom-start';
    const bottomEnd = isRTL ? 'bottom-start' : 'bottom-end';
    // const leftStart = isRTL ? 'right-start' : 'left-start';
    // const leftEnd = isRTL ? 'right-end' : 'left-end';
    const rightStart = isRTL ? 'left-start' : 'right-start';
    const rightEnd = isRTL ? 'left-end' : 'right-end';
    let placement = alignEnd ? bottomEnd : bottomStart;
    if (dropDirection === 'up')
        placement = alignEnd ? topEnd : topStart;
    else if (dropDirection === 'end')
        placement = alignEnd ? rightEnd : rightStart;
    // else if (dropDirection === 'start')
    //   placement = alignEnd ? leftEnd : leftStart;
    return placement;
}
const DropdownMenu = React.forwardRef(({ bsPrefix, className, align, rootCloseEvent, flip, show: showProps, renderOnMount, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'ul', popperConfig, variant, isNav, ...props }, ref) => {
    let alignEnd = false;
    const isNavbar = useContext(context$1);
    const prefix = 'dropdown-menu';
    const { align: contextAlign, drop, isRTL } = useContext(DropdownContext);
    align = align || contextAlign;
    const isInputGroup = useContext(context);
    const alignClasses = [];
    if (align) {
        if (typeof align === 'object') {
            const keys = Object.keys(align);
            warning(keys.length === 1, 'There should only be 1 breakpoint when passing an object to `align`');
            if (keys.length) {
                const brkPoint = keys[0];
                const direction = align[brkPoint];
                // .dropdown-menu-end is required for responsively aligning
                // left in addition to align left classes.
                alignEnd = direction === 'start';
                alignClasses.push(`${prefix}-${brkPoint}-${direction}`);
            }
        }
        else if (align === 'end') {
            alignEnd = true;
        }
    }
    const placement = getDropdownMenuPlacement(alignEnd, drop, isRTL);
    const [menuProps, { hasShown, popper, show, toggle }] = useDropdownMenu({
        flip,
        rootCloseEvent,
        show: showProps,
        usePopper: !isNavbar && alignClasses.length === 0,
        offset: !isNav ? [0, 10] : undefined,
        popperConfig,
        placement,
    });
    menuProps.ref = useMergedRefs(useWrappedRefWithWarning(ref, 'DropdownMenu'), menuProps.ref);
    useIsomorphicEffect(() => {
        // Popper's initial position for the menu is incorrect when
        // renderOnMount=true. Need to call update() to correct it.
        if (show)
            popper?.update();
    }, [show]);
    if (!hasShown && !renderOnMount && !isInputGroup)
        return null;
    // For custom components provide additional, non-DOM, props;
    if (typeof Component !== 'string') {
        menuProps.show = show;
        menuProps.close = () => toggle?.(false);
        menuProps.align = align;
    }
    let style = props.style;
    if (popper?.placement) {
        // we don't need the default popper style,
        // menus are display: none when not shown.
        style = { ...props.style, ...menuProps.style };
        //@ts-ignore
        props['x-placement'] = popper.placement;
    }
    return (React.createElement(Component, { ...props, ...menuProps, style: style, ...((alignClasses.length || isNavbar) && {
            'data-bs-popper': 'static',
        }), className: classNames(className, prefix, show && 'show', alignEnd && `${prefix}-end`, variant && `${prefix}-${variant}`, ...alignClasses) }));
});
DropdownMenu.displayName = 'DropdownMenu';
DropdownMenu.propTypes = propTypes$a;
DropdownMenu.defaultProps = defaultProps$5;

const propTypes$9 = {
    /**
     * @default 'btn'
     */
    bsPrefix: PropTypes.string,
    /**
     * One or more button variant combinations
     *
     * buttons may be one of a variety of visual variants such as:
     *
     * `'primary', 'secondary', 'success', 'danger', 'warning', 'info', 'dark', 'light', 'link'`
     *
     * as well as "outline" versions (prefixed by 'outline-*')
     *
     * `'outline-primary', 'outline-secondary', 'outline-success', 'outline-danger', 'outline-warning', 'outline-info', 'outline-dark', 'outline-light'`
     */
    variant: PropTypes.string,
    /**
     * Specifies a large or small button.
     *
     * @type ('sm'|'lg')
     */
    size: PropTypes.string,
    /** Manually set the visual state of the button to `:active` */
    active: PropTypes.bool,
    /**
     * Disables the Button, preventing mouse events,
     * even if the underlying component is an `<a>` element
     */
    disabled: PropTypes.bool,
    /** Providing a `href` will render an `<a>` element, _styled_ as a button. */
    href: PropTypes.string,
    /**
     * Defines HTML button type attribute.
     *
     * @default 'button'
     */
    type: PropTypes.oneOf(['button', 'reset', 'submit', null]),
    as: PropTypes.elementType,
};
const defaultProps$4 = {
    variant: 'primary',
    active: false,
    disabled: false,
};
const Button = React.forwardRef(({ as, bsPrefix, variant, size, active, className, ...props }, ref) => {
    const prefix = useBootstrapPrefix(bsPrefix, 'btn');
    const [buttonProps, { tagName }] = useButtonProps({
        tagName: as,
        ...props,
    });
    const Component = tagName;
    return (React.createElement(SGDSWrapper, { as: Component, ...props, ...buttonProps, ref: ref, className: classNames(className, prefix, active && 'active', variant && `${prefix}-${variant}`, size && `${prefix}-${size}`, props.href && props.disabled && 'disabled') }));
});
Button.displayName = 'Button';
Button.propTypes = propTypes$9;
Button.defaultProps = defaultProps$4;

const propTypes$8 = {
    /**
     * @default 'dropdown-toggle'
     */
    bsPrefix: PropTypes.string,
    /**
     * An html id attribute, necessary for assistive technologies, such as screen readers.
     * @type {string|number}
     */
    id: PropTypes.string,
    split: PropTypes.bool,
    as: PropTypes.elementType,
    /**
     * to passthrough to the underlying button or whatever from DropdownButton
     * @private
     */
    childBsPrefix: PropTypes.string,
};
const DropdownToggle = React.forwardRef(({ bsPrefix, split, className, childBsPrefix, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = Button, ...props }, ref) => {
    const prefix = 'dropdown-toggle';
    const dropdownContext = useContext(DropdownContext$1);
    const isInputGroup = useContext(context);
    if (childBsPrefix !== undefined) {
        props.bsPrefix = childBsPrefix;
    }
    const [toggleProps] = useDropdownToggle();
    toggleProps.ref = useMergedRefs(toggleProps.ref, useWrappedRefWithWarning(ref, 'DropdownToggle'));
    // This intentionally forwards size and variant (if set) to the
    // underlying component, to allow it to render size and style variants.
    return (React.createElement(Component, { className: classNames(className, prefix, split && `${prefix}-split`, !!isInputGroup && dropdownContext?.show && 'show'), variant: "outline-secondary", ...toggleProps, ...props, "aria-haspopup": "menu" }));
});
DropdownToggle.displayName = 'DropdownToggle';
DropdownToggle.propTypes = propTypes$8;

const DropdownHeader = createWithBsPrefix('dropdown-header', {
    defaultProps: { role: 'heading' },
});
const DropdownDivider = createWithBsPrefix('dropdown-divider', {
    Component: 'hr',
    defaultProps: { role: 'separator' },
});
const DropdownItemText = createWithBsPrefix('dropdown-item-text', {
    Component: 'span',
});

const propTypes$7 = {
    /** @default 'dropdown' */
    bsPrefix: PropTypes.string,
    /**
     * Determines the direction and location of the Menu in relation to it's Toggle.
     *
     * @type {"end"|"up"|"down" }
     */
    drop: PropTypes.oneOf(['up', 'end', 'down']),
    as: PropTypes.elementType,
    align: alignDirection,
    /**
     * Whether or not the Dropdown is visible.
     *
     * @controllable onToggle
     */
    show: PropTypes.bool,
    /**
     * Allow Dropdown to flip in case of an overlapping on the reference element. For more information refer to
     * Popper.js's flip [docs](https://popper.js.org/docs/v2/modifiers/flip/).
     *
     */
    flip: PropTypes.bool,
    /**
     * A callback fired when the Dropdown wishes to change visibility. Called with the requested
     * `show` value, the DOM event, and the source that fired it: `'click'`,`'keydown'`,`'rootClose'`, or `'select'`.
     *
     * ```js
     * function(
     *   isOpen: boolean,
     *   event: SyntheticEvent,
     *   metadata: {
     *     source: 'select' | 'click' | 'rootClose' | 'keydown'
     *   }
     * ): void
     * ```
     *
     * @controllable show
     */
    onToggle: PropTypes.func,
    /**
     * A callback fired when a menu item is selected.
     *
     * ```js
     * (eventKey: any, event: Object) => any
     * ```
     */
    onSelect: PropTypes.func,
    /**
     * Controls the focus behavior for when the Dropdown is opened. Set to
     * `true` to always focus the first menu item, `keyboard` to focus only when
     * navigating via the keyboard, or `false` to disable completely
     *
     * The Default behavior is `false` **unless** the Menu has a `role="menu"`
     * where it will default to `keyboard` to match the recommended [ARIA Authoring practices](https://www.w3.org/TR/wai-aria-practices-1.1/#menubutton).
     */
    focusFirstItemOnShow: PropTypes.oneOf([false, true, 'keyboard']),
    /** @private */
    navbar: PropTypes.bool,
    /**
     * Controls the auto close behaviour of the dropdown when clicking outside of
     * the button or the list.
     */
    autoClose: PropTypes.oneOf([true, 'outside', 'inside', false]),
};
const defaultProps$3 = {
    navbar: false,
    align: 'start',
    autoClose: true,
    focusFirstItemOnShow: 'keyboard',
};
const Dropdown = React.forwardRef((pProps, ref) => {
    const { bsPrefix, drop, show, className, align, onSelect, onToggle, focusFirstItemOnShow, 
    // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
    as: Component = 'div', navbar: _4, autoClose, ...props } = useUncontrolled(pProps, { show: 'onToggle' });
    const isInputGroup = useContext(context);
    const prefix = useBootstrapPrefix(bsPrefix, 'dropdown');
    const isRTL = useIsRTL();
    const isClosingPermitted = (source) => {
        // autoClose=false only permits close on button click
        if (autoClose === false)
            return source === 'click';
        // autoClose=inside doesn't permit close on rootClose
        if (autoClose === 'inside')
            return source !== 'rootClose';
        // autoClose=outside doesn't permit close on select
        if (autoClose === 'outside')
            return source !== 'select';
        return true;
    };
    const handleToggle = useEventCallback((nextShow, meta) => {
        if (meta.originalEvent.currentTarget === document &&
            (meta.source !== 'keydown' ||
                meta.originalEvent.key === 'Escape'))
            meta.source = 'rootClose';
        if (isClosingPermitted(meta.source))
            onToggle?.(nextShow, meta);
    });
    const alignEnd = align === 'end';
    const placement = getDropdownMenuPlacement(alignEnd, drop, isRTL);
    const contextValue = useMemo(() => ({
        align,
        drop,
        isRTL,
    }), [align, drop, isRTL]);
    return (React.createElement(DropdownContext.Provider, { value: contextValue },
        React.createElement(BaseDropdown, { placement: placement, show: show, onSelect: onSelect, onToggle: handleToggle, focusFirstItemOnShow: focusFirstItemOnShow, itemSelector: `.${prefix}-item:not(.disabled):not(:disabled)` }, isInputGroup ? (props.children) : (React.createElement(SGDSWrapper, { as: Component, ...props, ref: ref, className: classNames(className, show && 'show', prefix, drop === 'up' && 'dropup', drop === 'end' && 'dropend') })))));
});
Dropdown.displayName = 'Dropdown';
Dropdown.propTypes = propTypes$7;
Dropdown.defaultProps = defaultProps$3;
var Dropdown$1 = Object.assign(Dropdown, {
    Toggle: DropdownToggle,
    Menu: DropdownMenu,
    Item: DropdownItem,
    ItemText: DropdownItemText,
    Divider: DropdownDivider,
    Header: DropdownHeader,
});

const NavContext = React.createContext(null);
NavContext.displayName = 'NavContext';

const propTypes$6 = {
    /**
     * An html id attribute for the Toggle button, necessary for assistive technologies, such as screen readers.
     * @type {string}
     */
    id: PropTypes.string,
    /** An `onClick` handler passed to the Toggle component */
    onClick: PropTypes.func,
    /** The content of the non-toggle Button.  */
    title: PropTypes.node.isRequired,
    /** Disables the toggle NavLink  */
    disabled: PropTypes.bool,
    /** Style the toggle NavLink as active  */
    active: PropTypes.bool,
    /** An ARIA accessible role applied to the Menu component. When set to 'menu', The dropdown */
    menuRole: PropTypes.string,
    /** Whether to render the dropdown menu in the DOM before the first time it is shown */
    renderMenuOnMount: PropTypes.bool,
    /**
     *  Which event when fired outside the component will cause it to be closed.
     *
     * _see [DropdownMenu](#menu-props) for more details_
     */
    rootCloseEvent: PropTypes.string,
    /**
     * Menu color variant.
     *
     * Omitting this will use the default light color.
     */
    menuVariant: PropTypes.oneOf(['dark']),
    /** @ignore */
    bsPrefix: PropTypes.string,
    /** When true, applies mega menu stylings */
    isMegaMenu: PropTypes.bool,
    eventKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
};
const NavDropdown = React.forwardRef(({ id, title, children, bsPrefix, className, rootCloseEvent, menuRole, disabled, active, renderMenuOnMount, menuVariant, isMegaMenu, eventKey, align, ...props }, ref) => {
    /* NavItem has no additional logic, it's purely presentational. Can set nav item class here to support "as" */
    const navContext = useContext(NavContext);
    const navItemPrefix = useBootstrapPrefix(undefined, 'nav-item');
    const dropDownClass = classNames(className, navItemPrefix, isMegaMenu ? 'has-megamenu' : undefined);
    return (React.createElement(Dropdown$1, { ref: ref, as: "li", ...props, className: dropDownClass, align: align },
        React.createElement(Dropdown$1.Toggle, { id: id, eventKey: null, active: active || navContext?.activeKey === eventKey, disabled: disabled, childBsPrefix: bsPrefix, as: NavLink },
            title,
            React.createElement("i", { className: "bi bi-chevron-down" })),
        React.createElement(Dropdown$1.Menu, { role: menuRole, renderOnMount: renderMenuOnMount, rootCloseEvent: rootCloseEvent, variant: menuVariant, isNav: true, align: align, as: isMegaMenu ? 'div' : undefined, className: isMegaMenu ? 'mega-menu' : undefined }, children)));
});
NavDropdown.displayName = 'NavDropdown';
NavDropdown.propTypes = propTypes$6;
var NavDropdown$1 = Object.assign(NavDropdown, {
    Item: Dropdown$1.Item,
    ItemText: Dropdown$1.ItemText,
    Divider: Dropdown$1.Divider,
    Header: Dropdown$1.Header,
});

const propTypes$5 = {
    /**
     * @default 'nav'
     */
    bsPrefix: PropTypes.string,
    /** @private */
    // navbarBsPrefix: PropTypes.string,
    /** @private */
    // cardHeaderBsPrefix: PropTypes.string,
    /**
     * The visual variant of the nav items.
     *
     * @type {('tabs-basic-toggle' | 'tabs-info-toggle')}
     */
    variant: PropTypes.string,
    /**
     * The default active key that is selected on start.
     */
    defaultActiveKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    /**
     * Marks the NavItem with a matching `eventKey` (or `href` if present) as active.
     */
    activeKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    /**
     * A callback fired when a NavItem is selected.
     *
     * ```js
     * function (
     *  Any eventKey,
     *  SyntheticEvent event?
     * )
     * ```
     */
    onSelect: PropTypes.func,
    /**
     * ARIA role for the Nav, in the context of a TabContainer, the default will
     * be set to "tablist", but can be overridden by the Nav when set explicitly.
     *
     * When the role is "tablist", NavLink focus is managed according to
     * the ARIA authoring practices for tabs:
     * https://www.w3.org/TR/2013/WD-wai-aria-practices-20130307/#tabpanel
     */
    role: PropTypes.string,
    /**
     * Apply styling an alignment for use in a Navbar. This prop will be set
     * automatically when the Nav is used inside a Navbar.
     */
    // navbar: PropTypes.bool,
    /**
     * Enable vertical scrolling within the toggleable contents of a collapsed Navbar.
     */
    navbarScroll: PropTypes.bool,
    as: PropTypes.elementType,
    /** @private */
    onKeyDown: PropTypes.func,
};
const Nav = React.forwardRef((uncontrolledProps, ref) => {
    const { as = 'ul', bsPrefix: initialBsPrefix, navbarScroll, className, activeKey, ...props } = useUncontrolled(uncontrolledProps, { activeKey: 'onSelect' });
    const bsPrefix = useBootstrapPrefix(initialBsPrefix, 'nav');
    const contextValue = useMemo(() => ({
        activeKey,
    }), [activeKey]);
    const navbarContext = useContext(context$1);
    return (React.createElement(NavContext.Provider, { value: contextValue },
        React.createElement(BaseNav, { as: as, ref: ref, activeKey: activeKey, className: classNames(className, {
                [bsPrefix]: !navbarContext,
                [`${navbarContext?.bsPrefix}-nav`]: navbarContext,
                [`${navbarContext?.bsPrefix}-nav-scroll`]: navbarContext && navbarScroll,
                ['sgds']: !navbarContext,
                ['nav-tabs']: !navbarContext,
            }), ...props })));
});
Nav.displayName = 'Nav';
Nav.propTypes = propTypes$5;
var Nav$1 = Object.assign(Nav, {
    Item: NavItem,
    Link: NavLink,
    Dropdown: NavDropdown$1,
});

const propTypes$4 = {
    /** @default 'navbar' */
    bsPrefix: PropTypes.string,
    /**
     * An href, when provided the Brand will render as an `<a>` element (unless `as` is provided).
     */
    href: PropTypes.string,
    /**
     * Set a custom element for this component.
     */
    as: PropTypes.elementType,
};
const NavbarBrand = React.forwardRef(({ bsPrefix, className, as, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'navbar-brand');
    const Component = as || (props.href ? 'a' : 'span');
    return (React.createElement(Component, { ...props, ref: ref, className: classNames(className, bsPrefix) }));
});
NavbarBrand.displayName = 'NavbarBrand';
NavbarBrand.propTypes = propTypes$4;

const MARGINS = {
    height: ['marginTop', 'marginBottom'],
    width: ['marginLeft', 'marginRight'],
};
function getDefaultDimensionValue(dimension, elem) {
    const offset = `offset${dimension[0].toUpperCase()}${dimension.slice(1)}`;
    const value = elem[offset];
    const margins = MARGINS[dimension];
    return (value +
        // @ts-ignore
        parseInt(css(elem, margins[0]), 10) +
        // @ts-ignore
        parseInt(css(elem, margins[1]), 10));
}
const collapseStyles = {
    [EXITED]: 'collapse',
    [EXITING]: 'collapsing',
    [ENTERING]: 'collapsing',
    [ENTERED]: 'collapse show',
};
const propTypes$3 = {
    /**
     * Show the component; triggers the expand or collapse animation
     */
    in: PropTypes.bool,
    /**
     * Wait until the first "enter" transition to mount the component (add it to the DOM)
     */
    mountOnEnter: PropTypes.bool,
    /**
     * Unmount the component (remove it from the DOM) when it is collapsed
     */
    unmountOnExit: PropTypes.bool,
    /**
     * Run the expand animation when the component mounts, if it is initially
     * shown
     */
    appear: PropTypes.bool,
    /**
     * Duration of the collapse animation in milliseconds, to ensure that
     * finishing callbacks are fired even if the original browser transition end
     * events are canceled
     */
    timeout: PropTypes.number,
    /**
     * Callback fired before the component expands
     */
    onEnter: PropTypes.func,
    /**
     * Callback fired after the component starts to expand
     */
    onEntering: PropTypes.func,
    /**
     * Callback fired after the component has expanded
     */
    onEntered: PropTypes.func,
    /**
     * Callback fired before the component collapses
     */
    onExit: PropTypes.func,
    /**
     * Callback fired after the component starts to collapse
     */
    onExiting: PropTypes.func,
    /**
     * Callback fired after the component has collapsed
     */
    onExited: PropTypes.func,
    /**
     * The dimension used when collapsing, or a function that returns the
     * dimension
     */
    dimension: PropTypes.oneOfType([
        PropTypes.oneOf(['height', 'width']),
        PropTypes.func,
    ]),
    /**
     * Function that returns the height or width of the animating DOM node
     *
     * Allows for providing some custom logic for how much the Collapse component
     * should animate in its specified dimension. Called with the current
     * dimension prop value and the DOM node.
     *
     * @default element.offsetWidth | element.offsetHeight
     */
    getDimensionValue: PropTypes.func,
    /**
     * ARIA role of collapsible element
     */
    role: PropTypes.string,
    /**
     * You must provide a single JSX child element to this component and that element cannot be a \<React.Fragment\>
     */
    children: PropTypes.element.isRequired,
};
const defaultProps$2 = {
    in: false,
    timeout: 300,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
    getDimensionValue: getDefaultDimensionValue,
};
const Collapse = React__default.forwardRef(({ onEnter, onEntering, onEntered, onExit, onExiting, className, children, dimension = 'height', getDimensionValue = getDefaultDimensionValue, ...props }, ref) => {
    /* Compute dimension */
    const computedDimension = typeof dimension === 'function' ? dimension() : dimension;
    /* -- Expanding -- */
    const handleEnter = useMemo(() => createChainedFunction((elem) => {
        elem.style[computedDimension] = '0';
    }, onEnter), [computedDimension, onEnter]);
    const handleEntering = useMemo(() => createChainedFunction((elem) => {
        const scroll = `scroll${computedDimension[0].toUpperCase()}${computedDimension.slice(1)}`;
        elem.style[computedDimension] = `${elem[scroll]}px`;
    }, onEntering), [computedDimension, onEntering]);
    const handleEntered = useMemo(() => createChainedFunction((elem) => {
        elem.style[computedDimension] = null;
    }, onEntered), [computedDimension, onEntered]);
    /* -- Collapsing -- */
    const handleExit = useMemo(() => createChainedFunction((elem) => {
        elem.style[computedDimension] = `${getDimensionValue(computedDimension, elem)}px`;
        triggerBrowserReflow(elem);
    }, onExit), [onExit, getDimensionValue, computedDimension]);
    const handleExiting = useMemo(() => createChainedFunction((elem) => {
        elem.style[computedDimension] = null;
    }, onExiting), [computedDimension, onExiting]);
    return (React__default.createElement(TransitionWrapper, { ref: ref, addEndListener: transitionEndListener, ...props, "aria-expanded": props.role ? props.in : null, onEnter: handleEnter, onEntering: handleEntering, onEntered: handleEntered, onExit: handleExit, onExiting: handleExiting, childRef: children.ref }, (state, innerProps) => React__default.cloneElement(children, {
        ...innerProps,
        className: classNames(className, children.props.className, collapseStyles[state], computedDimension === 'width' && 'collapse-horizontal'),
    })));
});
// @ts-ignore
Collapse.propTypes = propTypes$3;
// @ts-ignore
Collapse.defaultProps = defaultProps$2;

const propTypes$2 = {
    /** @default 'navbar-collapse' */
    bsPrefix: PropTypes.string,
};
const NavbarCollapse = React.forwardRef(({ children, bsPrefix, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'navbar-collapse');
    const context = useContext(context$1);
    return (React.createElement(Collapse, { in: !!(context && context.expanded), ...props },
        React.createElement("div", { ref: ref, className: bsPrefix }, children)));
});
NavbarCollapse.displayName = 'NavbarCollapse';
NavbarCollapse.propTypes = propTypes$2;

const propTypes$1 = {
    /** @default 'navbar-toggler' */
    bsPrefix: PropTypes.string,
    /** An accessible ARIA label for the toggler button. */
    label: PropTypes.string,
    /** @private */
    onClick: PropTypes.func,
    /**
     * The toggle content. When empty, the default toggle will be rendered.
     */
    children: PropTypes.node,
    as: PropTypes.elementType,
};
const defaultProps$1 = {
    label: 'Toggle navigation',
};
const NavbarToggle = React.forwardRef(({ bsPrefix, className, children, label, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'button', onClick, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'navbar-toggler');
    const { onToggle, expanded } = useContext(context$1) || {};
    const handleClick = useEventCallback((e) => {
        if (onClick)
            onClick(e);
        if (onToggle)
            onToggle();
    });
    if (Component === 'button') {
        props.type = 'button';
    }
    return (React.createElement(Component, { ...props, ref: ref, onClick: handleClick, "aria-label": label, className: classNames(className, bsPrefix, !expanded && 'collapsed'), "aria-expanded": expanded }, children || React.createElement("span", { className: `${bsPrefix}-icon` })));
});
NavbarToggle.displayName = 'NavbarToggle';
NavbarToggle.propTypes = propTypes$1;
NavbarToggle.defaultProps = defaultProps$1;

const NavbarText = createWithBsPrefix('navbar-text', {
    Component: 'span',
});

const propTypes = {
    /** @default 'navbar' */
    bsPrefix: PropTypes.string,
    /**
     * The breakpoint, below which, the Navbar will collapse.
     * When `true` the Navbar will always be expanded regardless of screen size.
     */
    expand: PropTypes.oneOfType([
        PropTypes.bool,
        PropTypes.oneOf(['sm', 'md', 'lg', 'xl', 'xxl']),
    ]).isRequired,
    /**
     * A convenience prop for adding `bg-*` utility classes since they are so commonly used here.
     * `light` and `dark` are common choices but any `bg-*` class is supported, including any custom ones you might define.
     *
     * Pairs nicely with the `variant` prop.
     */
    bg: PropTypes.string,
    /**
     * Create a fixed navbar along the top or bottom of the screen, that scrolls with the
     * page. A convenience prop for the `fixed-*` positioning classes.
     */
    fixed: PropTypes.oneOf(['top', 'bottom']),
    /**
     * Position the navbar at the top of the viewport, but only after scrolling past it.
     * A convenience prop for the `sticky-top` positioning class.
     *
     *  __Not supported in <= IE11 and other older browsers without a polyfill__
     */
    sticky: PropTypes.oneOf(['top']),
    /**
     * Set a custom element for this component.
     */
    as: PropTypes.elementType,
    /**
     * A callback fired when the `<Navbar>` body collapses or expands. Fired when
     * a `<Navbar.Toggle>` is clicked and called with the new `expanded`
     * boolean value.
     *
     * @controllable expanded
     */
    onToggle: PropTypes.func,
    /**
     * A callback fired when a descendant of a child `<Nav>` is selected. Should
     * be used to execute complex closing or other miscellaneous actions desired
     * after selecting a descendant of `<Nav>`. Does nothing if no `<Nav>` or `<Nav>`
     * descendants exist. The callback is called with an eventKey, which is a
     * prop from the selected `<Nav>` descendant, and an event.
     *
     * ```js
     * function (
     *  eventKey: mixed,
     *  event?: SyntheticEvent
     * )
     * ```
     *
     * For basic closing behavior after all `<Nav>` descendant onSelect events in
     * mobile viewports, try using collapseOnSelect.
     *
     * Note: If you are manually closing the navbar using this `OnSelect` prop,
     * ensure that you are setting `expanded` to false and not *toggling* between
     * true and false.
     */
    onSelect: PropTypes.func,
    /**
     * Toggles `expanded` to `false` after the onSelect event of a descendant of a
     * child `<Nav>` fires. Does nothing if no `<Nav>` or `<Nav>` descendants exist.
     *
     * Manually controlling `expanded` via the onSelect callback is recommended instead,
     * for more complex operations that need to be executed after
     * the `select` event of `<Nav>` descendants.
     */
    collapseOnSelect: PropTypes.bool,
    /**
     * Controls the visiblity of the navbar body
     *
     * @controllable onToggle
     */
    expanded: PropTypes.bool,
    /**
     * The ARIA role for the navbar, will default to 'navigation' for
     * Navbars whose `as` is something other than `<nav>`.
     *
     * @default 'navigation'
     */
    role: PropTypes.string,
    hasBorderBottom: PropTypes.bool,
};
const defaultProps = {
    expand: true,
    collapseOnSelect: false,
};
const Navbar = React.forwardRef((props, ref) => {
    const { bsPrefix: initialBsPrefix, expand, bg, fixed, sticky, className, hasBorderBottom, 
    // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
    as: Component = 'nav', expanded, onToggle, onSelect, collapseOnSelect, ...controlledProps } = useUncontrolled(props, {
        expanded: 'onToggle',
    });
    const bsPrefix = useBootstrapPrefix(initialBsPrefix, 'navbar');
    const handleCollapse = useCallback((...args) => {
        onSelect?.(...args);
        if (collapseOnSelect && expanded) {
            onToggle?.(false);
        }
    }, [onSelect, collapseOnSelect, expanded, onToggle]);
    // will result in some false positives but that seems better
    // than false negatives. strict `undefined` check allows explicit
    // "nulling" of the role if the user really doesn't want one
    if (controlledProps.role === undefined && Component !== 'nav') {
        controlledProps.role = 'navigation';
    }
    let expandClass = `${bsPrefix}-expand`;
    if (typeof expand === 'string')
        expandClass = `${expandClass}-${expand}`;
    const navbarContext = useMemo(() => ({
        onToggle: () => onToggle?.(!expanded),
        bsPrefix,
        expanded: !!expanded,
    }), [bsPrefix, expanded, onToggle]);
    return (React.createElement(context$1.Provider, { value: navbarContext },
        React.createElement(SelectableContext.Provider, { value: handleCollapse },
            React.createElement(SGDSWrapper, { as: Component, ref: ref, ...controlledProps, className: classNames(className, bsPrefix, expand && expandClass, 'navbar-light', bg && `bg-${bg}`, sticky && `sticky-${sticky}`, fixed && `fixed-${fixed}`, hasBorderBottom && 'border-bottom') }))));
});
Navbar.propTypes = propTypes;
Navbar.defaultProps = defaultProps;
Navbar.displayName = 'Navbar';
var Navbar$1 = Object.assign(Navbar, {
    Brand: NavbarBrand,
    Collapse: NavbarCollapse,
    // Offcanvas: NavbarOffcanvas,
    Text: NavbarText,
    Toggle: NavbarToggle,
});

export { Nav$1 as Nav, NavDropdown$1 as NavDropdown, NavItem, NavLink, Navbar$1 as Navbar, NavbarBrand, NavbarCollapse, NavbarText, NavbarToggle };
