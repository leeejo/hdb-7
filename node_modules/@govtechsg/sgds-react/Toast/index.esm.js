'use client';
import * as React from 'react';
import { useCallback, useContext, useRef, useEffect, useMemo } from 'react';
import PropTypes from 'prop-types';
import classNames from 'classnames';
import useTimeout from '@restart/hooks/useTimeout';
import { ENTERING, ENTERED, EXITING } from 'react-transition-group/Transition';
import transitionEndListener from '../utils/transitionEndListener';
import triggerBrowserReflow from '../utils/triggerBrowserReflow';
import TransitionWrapper from '../utils/TransitionWrapper';
import useEventCallback from '@restart/hooks/useEventCallback';
import createWithBsPrefix from '../utils/createWithBsPrefix';

const propTypes$4 = {
    /**
     * Show the component; triggers the fade in or fade out animation
     */
    in: PropTypes.bool,
    /**
     * Wait until the first "enter" transition to mount the component (add it to the DOM)
     */
    mountOnEnter: PropTypes.bool,
    /**
     * Unmount the component (remove it from the DOM) when it is faded out
     */
    unmountOnExit: PropTypes.bool,
    /**
     * Run the fade in animation when the component mounts, if it is initially
     * shown
     */
    appear: PropTypes.bool,
    /**
     * Duration of the fade animation in milliseconds, to ensure that finishing
     * callbacks are fired even if the original browser transition end events are
     * canceled
     */
    timeout: PropTypes.number,
    /**
     * Callback fired before the component fades in
     */
    onEnter: PropTypes.func,
    /**
     * Callback fired after the component starts to fade in
     */
    onEntering: PropTypes.func,
    /**
     * Callback fired after the has component faded in
     */
    onEntered: PropTypes.func,
    /**
     * Callback fired before the component fades out
     */
    onExit: PropTypes.func,
    /**
     * Callback fired after the component starts to fade out
     */
    onExiting: PropTypes.func,
    /**
     * Callback fired after the component has faded out
     */
    onExited: PropTypes.func,
    /**
     * You must provide a single JSX child element to this component and that element cannot be a \<React.Fragment\>
     */
    children: PropTypes.element.isRequired,
    /**
     * Applies additional specified classes during the transition. Takes an object
     * where the keys correspond to the Transition status
     */
    transitionClasses: PropTypes.object,
};
const defaultProps$2 = {
    in: false,
    timeout: 300,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
};
const fadeStyles$1 = {
    [ENTERING]: 'show',
    [ENTERED]: 'show',
};
const Fade = React.forwardRef(({ className, children, transitionClasses = {}, ...props }, ref) => {
    const handleEnter = useCallback((node, isAppearing) => {
        triggerBrowserReflow(node);
        props.onEnter?.(node, isAppearing);
    }, [props]);
    return (React.createElement(TransitionWrapper, { ref: ref, addEndListener: transitionEndListener, ...props, onEnter: handleEnter, childRef: children.ref }, (status, innerProps) => React.cloneElement(children, {
        ...innerProps,
        className: classNames('fade', className, children.props.className, 
        //@ts-ignore
        fadeStyles$1[status], transitionClasses[status]),
    })));
});
Fade.propTypes = propTypes$4;
Fade.defaultProps = defaultProps$2;
Fade.displayName = 'Fade';

const fadeStyles = {
    [ENTERING]: 'showing',
    [EXITING]: 'showing show',
};
const ToastFade = React.forwardRef((props, ref) => (React.createElement(Fade, { ...props, ref: ref, transitionClasses: fadeStyles })));
ToastFade.displayName = 'ToastFade';

const ThemeContext = React.createContext({ prefixes: {} });
({
    prefixes: PropTypes.object,
    dir: PropTypes.string,
});
function useBootstrapPrefix(prefix, defaultPrefix) {
    const { prefixes } = useContext(ThemeContext);
    return prefix || prefixes[defaultPrefix] || `${defaultPrefix}`;
}
const SGDSWrapper = React.forwardRef(({ as: Tag = 'div', ...props }, ref) => {
    return React.createElement(Tag, { ref: ref, ...props, className: classNames(props.className, 'sgds') });
});

const propTypes$3 = {
    'aria-label': PropTypes.string,
    onClick: PropTypes.func,
    /**
     * Render different color variant for the button.
     *
     * Omitting this will render the default dark color.
     */
    variant: PropTypes.oneOf(['white']),
};
const defaultProps$1 = {
    'aria-label': 'Close',
};
const CloseButton = React.forwardRef(({ className, variant, ...props }, ref) => (React.createElement("button", { ref: ref, type: "button", className: classNames('btn-close', variant && `btn-close-${variant}`, className), ...props })));
CloseButton.displayName = 'CloseButton';
CloseButton.propTypes = propTypes$3;
CloseButton.defaultProps = defaultProps$1;

const ToastContext = React.createContext({
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    onClose() { },
});

const propTypes$2 = {
    bsPrefix: PropTypes.string,
    /**
     * Provides an accessible label for the close
     * button. It is used for Assistive Technology when the label text is not
     * readable.
     */
    closeLabel: PropTypes.string,
    /**
     * Sets the variant for close button.
     */
    closeVariant: PropTypes.oneOf(['white']),
    /**
     * Specify whether the Component should contain a close button
     */
    closeButton: PropTypes.bool,
};
const defaultProps = {
    closeLabel: 'Close',
    closeButton: true,
};
const ToastHeader = React.forwardRef(({ bsPrefix, closeLabel, closeVariant, closeButton, className, children, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'toast-header');
    const context = useContext(ToastContext);
    const handleClick = useEventCallback((e) => {
        context?.onClose?.(e);
    });
    return (React.createElement("div", { ref: ref, ...props, className: classNames(bsPrefix, className) },
        children,
        closeButton && (React.createElement(CloseButton, { "aria-label": closeLabel, variant: closeVariant, onClick: handleClick, "data-dismiss": "toast" }))));
});
ToastHeader.displayName = 'ToastHeader';
ToastHeader.propTypes = propTypes$2;
ToastHeader.defaultProps = defaultProps;

const ToastBody = createWithBsPrefix('toast-body');

const propTypes$1 = {
    /**
     * @default 'toast'
     */
    bsPrefix: PropTypes.string,
    /**
     * Apply a CSS fade transition to the toast
     */
    animation: PropTypes.bool,
    /**
     * Auto hide the toast
     */
    autohide: PropTypes.bool,
    /**
     * Delay hiding the toast (ms)
     */
    delay: PropTypes.number,
    /**
     * A Callback fired when the close button is clicked.
     */
    onClose: PropTypes.func,
    /**
     * When `true` The toast will show itself.
     */
    show: PropTypes.bool,
    /**
     * A `react-transition-group` Transition component used to animate the Toast on dismissal.
     */
    transition: PropTypes.elementType,
    /**
     * Sets Toast background
     *
     * @type {('primary'|'secondary'|'success'|'danger'|'warning'|'info'|'dark'|'light')}
     */
    bg: PropTypes.string,
    isSGDS: PropTypes.bool,
    status: PropTypes.oneOf(['success', 'warning', 'danger']),
};
const Toast = React.forwardRef(({ bsPrefix, className, transition: Transition = ToastFade, show = true, animation = true, delay = 5000, autohide = false, onClose, bg, isSGDS = true, status, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'toast');
    // We use refs for these, because we don't want to restart the autohide
    // timer in case these values change.
    const delayRef = useRef(delay);
    const onCloseRef = useRef(onClose);
    useEffect(() => {
        delayRef.current = delay;
        onCloseRef.current = onClose;
    }, [delay, onClose]);
    const autohideTimeout = useTimeout();
    const autohideToast = !!(autohide && show);
    const autohideFunc = useCallback(() => {
        if (autohideToast) {
            onCloseRef.current?.();
        }
    }, [autohideToast]);
    useEffect(() => {
        // Only reset timer if show or autohide changes.
        autohideTimeout.set(autohideFunc, delayRef.current);
    }, [autohideTimeout, autohideFunc]);
    const toastContext = useMemo(() => ({
        onClose,
    }), [onClose]);
    const hasAnimation = !!(Transition && animation);
    const toast = (React.createElement("div", { ...props, ref: ref, className: classNames(bsPrefix, className, bg && `bg-${bg}`, !hasAnimation && (show ? 'show' : 'hide'), isSGDS && 'sgds', status && `is-${status}`), role: "alert", "aria-live": "assertive", "aria-atomic": "true" }));
    return (React.createElement(ToastContext.Provider, { value: toastContext }, hasAnimation && Transition ? (React.createElement(Transition, { in: show, unmountOnExit: true }, toast)) : (toast)));
});
Toast.propTypes = propTypes$1;
Toast.displayName = 'Toast';
var Toast$1 = Object.assign(Toast, {
    Body: ToastBody,
    Header: ToastHeader,
});

const propTypes = {
    /**
     * @default 'toast-container'
     */
    bsPrefix: PropTypes.string,
    /**Position of toasts placed within the container. */
    position: PropTypes.oneOf([
        'top-start',
        'top-center',
        'top-end',
        'middle-start',
        'middle-center',
        'middle-end',
        'bottom-start',
        'bottom-center',
        'bottom-end',
    ]),
};
const positionClasses = {
    'top-start': 'top-0 start-0',
    'top-center': 'top-0 start-50 translate-middle-x',
    'top-end': 'top-0 end-0',
    'middle-start': 'top-50 start-0 translate-middle-y',
    'middle-center': 'top-50 start-50 translate-middle',
    'middle-end': 'top-50 end-0 translate-middle-y',
    'bottom-start': 'bottom-0 start-0',
    'bottom-center': 'bottom-0 start-50 translate-middle-x',
    'bottom-end': 'bottom-0 end-0',
};
const ToastContainer = React.forwardRef(({ bsPrefix, position, className, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'div', ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'toast-container');
    return (React.createElement(SGDSWrapper, { ref: ref, ...props, className: classNames(bsPrefix, position && `position-absolute ${positionClasses[position]}`, className) }));
});
ToastContainer.displayName = 'ToastContainer';
ToastContainer.propTypes = propTypes;

export { Toast$1 as Toast, ToastBody, ToastContainer, ToastHeader };
