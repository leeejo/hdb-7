'use client';
import * as React from 'react';
import React__default, { useEffect, useState } from 'react';
import { useCallbackRef } from '@restart/hooks';
import PropTypes from 'prop-types';
import classNames from 'classnames';

class WrappedStepMetadata {
    stepMetadata;
    index;
    constructor(stepMetadata, index) {
        this.stepMetadata = stepMetadata;
        this.index = index;
    }
    get component() {
        return this.stepMetadata.component;
    }
    get title() {
        return this.stepMetadata.title;
    }
    get step() {
        return this.index + 1;
    }
    get stepHeader() {
        return this.stepMetadata.stepHeader;
    }
    async onNextStep(onDone) {
        if (this.stepMetadata.onNextStep) {
            await this.stepMetadata.onNextStep(onDone);
        }
        else {
            await onDone();
        }
    }
    async onPreviousStep(onDone) {
        if (this.stepMetadata.onPreviousStep) {
            await this.stepMetadata.onPreviousStep(onDone);
        }
        else {
            await onDone();
        }
    }
    async onArrived() {
        if (this.stepMetadata.onArrived) {
            await this.stepMetadata.onArrived();
        }
    }
}
class WrappedStepsMetadata {
    wrappedStepMetadataArr;
    constructor(wrappedStepMetadataArr) {
        this.wrappedStepMetadataArr = wrappedStepMetadataArr;
    }
    get length() {
        return this.wrappedStepMetadataArr.length;
    }
    findByStep(step) {
        return this.wrappedStepMetadataArr.find((wrappedStepMetadata) => wrappedStepMetadata.step === step);
    }
    isFirstStep(step) {
        return step === 1;
    }
    isLastStep(step) {
        return step === this.length;
    }
    isWithinStepRange(step) {
        return step >= 1 && step <= this.length + 1;
    }
    get data() {
        return this.wrappedStepMetadataArr;
    }
}
function useStep(stepsMetadata) {
    const wrappedStepsMetadata = new WrappedStepsMetadata(stepsMetadata.map((stepMetadata, index) => new WrappedStepMetadata(stepMetadata, index)));
    const getStateMethod = () => {
        return useState({
            currentStep: 1,
        });
    };
    const [state, setState] = getStateMethod();
    useEffect(() => {
        runOnArrived();
    }, [state.currentStep]);
    const runOnArrived = async () => {
        const stepData = wrappedStepsMetadata.findByStep(state.currentStep);
        if (stepData) {
            await stepData.onArrived();
        }
    };
    const setStep = async (newStep) => {
        if (newStep === state.currentStep) {
            return;
        }
        const stepData = wrappedStepsMetadata.findByStep(state.currentStep);
        if (!stepData) {
            return;
        }
        if (!wrappedStepsMetadata.isWithinStepRange(newStep)) {
            return;
        }
        const onDoneMethod = async () => {
            setState({
                ...state,
                currentStep: newStep,
            });
        };
        if (newStep > state.currentStep) {
            await stepData.onNextStep(onDoneMethod);
        }
        if (newStep < state.currentStep) {
            await stepData.onPreviousStep(onDoneMethod);
        }
    };
    const nextStep = async () => {
        await setStep(state.currentStep + 1);
    };
    const prevStep = async () => {
        await setStep(state.currentStep - 1);
    };
    const getTitle = () => {
        const stepData = wrappedStepsMetadata.findByStep(state.currentStep);
        if (stepData) {
            return stepData.title;
        }
        return '';
    };
    const getComponent = () => {
        const stepData = wrappedStepsMetadata.findByStep(state.currentStep);
        if (stepData) {
            return stepData.component;
        }
    };
    const getNextButtonTitle = () => {
        if (wrappedStepsMetadata.isLastStep(state.currentStep)) {
            return 'Submit';
        }
        else {
            return 'Next';
        }
    };
    const getBackButtonTitle = () => {
        if (wrappedStepsMetadata.isFirstStep(state.currentStep)) {
            return null;
        }
        else {
            return 'Back';
        }
    };
    const reset = async () => {
        if (state.currentStep !== 1) {
            setState({
                ...state,
                currentStep: 1,
            });
        }
        else {
            await runOnArrived();
        }
    };
    return {
        state,
        stepsMetadata: wrappedStepsMetadata,
        nextStep,
        prevStep,
        setStep,
        getTitle,
        getComponent,
        getNextButtonTitle,
        getBackButtonTitle,
        reset,
    };
}

React.createContext({ prefixes: {} });
({
    prefixes: PropTypes.object,
    dir: PropTypes.string,
});
const SGDSWrapper = React.forwardRef(({ as: Tag = 'div', ...props }, ref) => {
    return React.createElement(Tag, { ref: ref, ...props, className: classNames(props.className, 'sgds') });
});

const propTypes = {
    methods: PropTypes.shape({
        state: PropTypes.shape({ currentStep: PropTypes.number }),
        stepsMetadata: PropTypes.instanceOf(WrappedStepsMetadata),
        nextStep: PropTypes.func,
        prevStep: PropTypes.func,
        setStep: PropTypes.func,
        getTitle: PropTypes.func,
        getComponent: PropTypes.func,
        getNextButtonTitle: PropTypes.func,
        getBackButtonTitle: PropTypes.func,
        reset: PropTypes.func,
    }).isRequired,
};
const Stepper = ({ methods }) => {
    const [stepperEl, stepperRef] = useCallbackRef();
    const { state, stepsMetadata, setStep } = methods;
    useEffect(() => {
        if (!stepperEl)
            return;
        stepperEl.querySelectorAll('.stepper-item').forEach(stepperItem => {
            stepperItem.addEventListener('keydown', e => {
                const keyDown = e.key;
                if (keyDown === 'Enter') {
                    e.preventDefault();
                    stepperItem.click();
                }
            });
        });
    }, [stepperEl]);
    const getClass = (stepMetadata) => {
        if (stepMetadata.step < state.currentStep) {
            return 'is-completed is-clickable';
        }
        if (stepMetadata.step === state.currentStep) {
            return 'is-active';
        }
        return '';
    };
    const back = (stepMetadata) => {
        return () => {
            if (stepMetadata.step < state.currentStep) {
                return setStep(stepMetadata.step);
            }
            return;
        };
    };
    return (React__default.createElement(SGDSWrapper, { ref: stepperRef, className: "stepper" }, stepsMetadata.data.map((stepMetadata) => (React__default.createElement("div", { "data-testid": "sgds-step", className: `stepper-item ${getClass(stepMetadata)}`, onClick: back(stepMetadata), key: stepMetadata.step, tabIndex: 0, "aria-current": stepMetadata.step === state.currentStep ? "step" : "false", "aria-disabled": stepMetadata.step >= state.currentStep },
        React__default.createElement("div", { className: "stepper-marker" }, stepMetadata.step),
        React__default.createElement("div", { className: "stepper-detail" },
            React__default.createElement("p", null,
                React__default.createElement("b", null, stepMetadata.stepHeader))))))));
};
Stepper.displayName = 'Stepper';
Stepper.propTypes = propTypes;

export { Stepper, useStep };
