'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var hooks = require('@restart/hooks');
var PropTypes = require('prop-types');
var classNames = require('classnames');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);
var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var PropTypes__default = /*#__PURE__*/_interopDefaultLegacy(PropTypes);
var classNames__default = /*#__PURE__*/_interopDefaultLegacy(classNames);

class WrappedStepMetadata {
    stepMetadata;
    index;
    constructor(stepMetadata, index) {
        this.stepMetadata = stepMetadata;
        this.index = index;
    }
    get component() {
        return this.stepMetadata.component;
    }
    get title() {
        return this.stepMetadata.title;
    }
    get step() {
        return this.index + 1;
    }
    get stepHeader() {
        return this.stepMetadata.stepHeader;
    }
    async onNextStep(onDone) {
        if (this.stepMetadata.onNextStep) {
            await this.stepMetadata.onNextStep(onDone);
        }
        else {
            await onDone();
        }
    }
    async onPreviousStep(onDone) {
        if (this.stepMetadata.onPreviousStep) {
            await this.stepMetadata.onPreviousStep(onDone);
        }
        else {
            await onDone();
        }
    }
    async onArrived() {
        if (this.stepMetadata.onArrived) {
            await this.stepMetadata.onArrived();
        }
    }
}
class WrappedStepsMetadata {
    wrappedStepMetadataArr;
    constructor(wrappedStepMetadataArr) {
        this.wrappedStepMetadataArr = wrappedStepMetadataArr;
    }
    get length() {
        return this.wrappedStepMetadataArr.length;
    }
    findByStep(step) {
        return this.wrappedStepMetadataArr.find((wrappedStepMetadata) => wrappedStepMetadata.step === step);
    }
    isFirstStep(step) {
        return step === 1;
    }
    isLastStep(step) {
        return step === this.length;
    }
    isWithinStepRange(step) {
        return step >= 1 && step <= this.length + 1;
    }
    get data() {
        return this.wrappedStepMetadataArr;
    }
}
function useStep(stepsMetadata) {
    const wrappedStepsMetadata = new WrappedStepsMetadata(stepsMetadata.map((stepMetadata, index) => new WrappedStepMetadata(stepMetadata, index)));
    const getStateMethod = () => {
        return React.useState({
            currentStep: 1,
        });
    };
    const [state, setState] = getStateMethod();
    React.useEffect(() => {
        runOnArrived();
    }, [state.currentStep]);
    const runOnArrived = async () => {
        const stepData = wrappedStepsMetadata.findByStep(state.currentStep);
        if (stepData) {
            await stepData.onArrived();
        }
    };
    const setStep = async (newStep) => {
        if (newStep === state.currentStep) {
            return;
        }
        const stepData = wrappedStepsMetadata.findByStep(state.currentStep);
        if (!stepData) {
            return;
        }
        if (!wrappedStepsMetadata.isWithinStepRange(newStep)) {
            return;
        }
        const onDoneMethod = async () => {
            setState({
                ...state,
                currentStep: newStep,
            });
        };
        if (newStep > state.currentStep) {
            await stepData.onNextStep(onDoneMethod);
        }
        if (newStep < state.currentStep) {
            await stepData.onPreviousStep(onDoneMethod);
        }
    };
    const nextStep = async () => {
        await setStep(state.currentStep + 1);
    };
    const prevStep = async () => {
        await setStep(state.currentStep - 1);
    };
    const getTitle = () => {
        const stepData = wrappedStepsMetadata.findByStep(state.currentStep);
        if (stepData) {
            return stepData.title;
        }
        return '';
    };
    const getComponent = () => {
        const stepData = wrappedStepsMetadata.findByStep(state.currentStep);
        if (stepData) {
            return stepData.component;
        }
    };
    const getNextButtonTitle = () => {
        if (wrappedStepsMetadata.isLastStep(state.currentStep)) {
            return 'Submit';
        }
        else {
            return 'Next';
        }
    };
    const getBackButtonTitle = () => {
        if (wrappedStepsMetadata.isFirstStep(state.currentStep)) {
            return null;
        }
        else {
            return 'Back';
        }
    };
    const reset = async () => {
        if (state.currentStep !== 1) {
            setState({
                ...state,
                currentStep: 1,
            });
        }
        else {
            await runOnArrived();
        }
    };
    return {
        state,
        stepsMetadata: wrappedStepsMetadata,
        nextStep,
        prevStep,
        setStep,
        getTitle,
        getComponent,
        getNextButtonTitle,
        getBackButtonTitle,
        reset,
    };
}

React__namespace.createContext({ prefixes: {} });
({
    prefixes: PropTypes__default["default"].object,
    dir: PropTypes__default["default"].string,
});
const SGDSWrapper = React__namespace.forwardRef(({ as: Tag = 'div', ...props }, ref) => {
    return React__namespace.createElement(Tag, { ref: ref, ...props, className: classNames__default["default"](props.className, 'sgds') });
});

const propTypes = {
    methods: PropTypes__default["default"].shape({
        state: PropTypes__default["default"].shape({ currentStep: PropTypes__default["default"].number }),
        stepsMetadata: PropTypes__default["default"].instanceOf(WrappedStepsMetadata),
        nextStep: PropTypes__default["default"].func,
        prevStep: PropTypes__default["default"].func,
        setStep: PropTypes__default["default"].func,
        getTitle: PropTypes__default["default"].func,
        getComponent: PropTypes__default["default"].func,
        getNextButtonTitle: PropTypes__default["default"].func,
        getBackButtonTitle: PropTypes__default["default"].func,
        reset: PropTypes__default["default"].func,
    }).isRequired,
};
const Stepper = ({ methods }) => {
    const [stepperEl, stepperRef] = hooks.useCallbackRef();
    const { state, stepsMetadata, setStep } = methods;
    React.useEffect(() => {
        if (!stepperEl)
            return;
        stepperEl.querySelectorAll('.stepper-item').forEach(stepperItem => {
            stepperItem.addEventListener('keydown', e => {
                const keyDown = e.key;
                if (keyDown === 'Enter') {
                    e.preventDefault();
                    stepperItem.click();
                }
            });
        });
    }, [stepperEl]);
    const getClass = (stepMetadata) => {
        if (stepMetadata.step < state.currentStep) {
            return 'is-completed is-clickable';
        }
        if (stepMetadata.step === state.currentStep) {
            return 'is-active';
        }
        return '';
    };
    const back = (stepMetadata) => {
        return () => {
            if (stepMetadata.step < state.currentStep) {
                return setStep(stepMetadata.step);
            }
            return;
        };
    };
    return (React__default["default"].createElement(SGDSWrapper, { ref: stepperRef, className: "stepper" }, stepsMetadata.data.map((stepMetadata) => (React__default["default"].createElement("div", { "data-testid": "sgds-step", className: `stepper-item ${getClass(stepMetadata)}`, onClick: back(stepMetadata), key: stepMetadata.step, tabIndex: 0, "aria-current": stepMetadata.step === state.currentStep ? "step" : "false", "aria-disabled": stepMetadata.step >= state.currentStep },
        React__default["default"].createElement("div", { className: "stepper-marker" }, stepMetadata.step),
        React__default["default"].createElement("div", { className: "stepper-detail" },
            React__default["default"].createElement("p", null,
                React__default["default"].createElement("b", null, stepMetadata.stepHeader))))))));
};
Stepper.displayName = 'Stepper';
Stepper.propTypes = propTypes;

exports.Stepper = Stepper;
exports.useStep = useStep;
