'use client';
import * as React from 'react';
import { useContext, useMemo, useCallback } from 'react';
import PropTypes from 'prop-types';
import { useUncontrolled } from 'uncontrollable';
import BaseTabs from '@restart/ui/Tabs';
import classNames from 'classnames';
import BaseNav from '@restart/ui/Nav';
import createWithBsPrefix from '../utils/createWithBsPrefix';
import Anchor from '@restart/ui/Anchor';
import { useNavItem } from '@restart/ui/NavItem';
import SelectableContext, { makeEventKey } from '@restart/ui/SelectableContext';
import BaseDropdown from '@restart/ui/Dropdown';
import useEventCallback from '@restart/hooks/useEventCallback';
import { useDropdownItem } from '@restart/ui/DropdownItem';
import { useDropdownMenu } from '@restart/ui/DropdownMenu';
import useIsomorphicEffect from '@restart/hooks/useIsomorphicEffect';
import useMergedRefs from '@restart/hooks/useMergedRefs';
import warning from 'warning';
import { alignPropType, alignDirection } from '../utils/types';
import useWrappedRefWithWarning from '../utils/useWrappedRefWithWarning';
import { useDropdownToggle } from '@restart/ui/DropdownToggle';
import DropdownContext$1 from '@restart/ui/DropdownContext';
import { useButtonProps } from '@restart/ui/Button';
import TabContext from '@restart/ui/TabContext';
import { useTabPanel } from '@restart/ui/TabPanel';
import { ENTERING, ENTERED } from 'react-transition-group/Transition';
import transitionEndListener from '../utils/transitionEndListener';
import triggerBrowserReflow from '../utils/triggerBrowserReflow';
import TransitionWrapper from '../utils/TransitionWrapper';
import getTabTransitionComponent from '../utils/getTabTransitionComponent';
import { map, forEach } from '../utils/ElementChildren';

const ThemeContext = React.createContext({ prefixes: {} });
({
    prefixes: PropTypes.object,
    dir: PropTypes.string,
});
function useBootstrapPrefix(prefix, defaultPrefix) {
    const { prefixes } = useContext(ThemeContext);
    return prefix || prefixes[defaultPrefix] || `${defaultPrefix}`;
}
// `sgds-${defaultPrefix}`
function useIsRTL() {
    const { dir } = useContext(ThemeContext);
    return dir === 'rtl';
}
const SGDSWrapper = React.forwardRef(({ as: Tag = 'div', ...props }, ref) => {
    return React.createElement(Tag, { ref: ref, ...props, className: classNames(props.className, 'sgds') });
});

const context$1 = React.createContext(null);
context$1.displayName = 'NavbarContext';

const NavItem = createWithBsPrefix('nav-item', {
    Component: "li",
    displayName: 'NavItem'
});

const propTypes$c = {
    /**
     * @default 'nav-link'
     */
    bsPrefix: PropTypes.string,
    /**
     * The active state of the NavItem item.
     */
    active: PropTypes.bool,
    /**
     * The disabled state of the NavItem item.
     */
    disabled: PropTypes.bool,
    /**
     * The ARIA role for the `NavLink`, In the context of a 'tablist' parent Nav,
     * the role defaults to 'tab'
     * */
    role: PropTypes.string,
    /** The HTML href attribute for the `NavLink` */
    href: PropTypes.string,
    /**
     * Uniquely identifies the `NavItem` amongst its siblings,
     * used to determine and control the active state of the parent `Nav`
     */
    eventKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    /** @default 'a' */
    as: PropTypes.elementType,
};
const defaultProps$5 = {
    disabled: false,
};
const NavLink = React.forwardRef(({ bsPrefix, className, as: Component = Anchor, active, eventKey, 
// onClick,
...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'nav-link');
    const [navItemProps, meta] = useNavItem({
        key: makeEventKey(eventKey, props.href),
        active,
        ...props,
    });
    return (React.createElement(Component, { ...props, ...navItemProps, ref: ref, className: classNames(className, bsPrefix, props.disabled && 'disabled', meta.isActive && 'active'), "aria-current": meta.isActive ? "page" : "false" }));
});
NavLink.displayName = 'NavLink';
NavLink.propTypes = propTypes$c;
NavLink.defaultProps = defaultProps$5;

const DropdownContext = React.createContext({});
DropdownContext.displayName = 'DropdownContext';

const propTypes$b = {
    /** @default 'dropdown-item' */
    bsPrefix: PropTypes.string,
    /**
     * Highlight the menu item as active.
     */
    active: PropTypes.bool,
    /**
     * Disable the menu item, making it unselectable.
     */
    disabled: PropTypes.bool,
    /**
     * Value passed to the `onSelect` handler, useful for identifying the selected menu item.
     */
    eventKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    /**
     * HTML `href` attribute corresponding to `a.href`.
     */
    href: PropTypes.string,
    /**
     * Callback fired when the menu item is clicked.
     */
    onClick: PropTypes.func,
    as: PropTypes.elementType,
};
const DropdownItem = React.forwardRef(({ bsPrefix, className, eventKey, disabled = false, onClick, active, as: Component = Anchor, ...props }, ref) => {
    const prefix = 'dropdown-item';
    const [dropdownItemProps, meta] = useDropdownItem({
        key: eventKey,
        href: props.href,
        disabled,
        onClick,
        active,
    });
    return (React.createElement("li", null,
        React.createElement(Component, { ...props, ...dropdownItemProps, ref: ref, className: classNames(className, prefix, meta.isActive && 'active', disabled && 'disabled') })));
});
DropdownItem.displayName = 'DropdownItem';
DropdownItem.propTypes = propTypes$b;

const context = React.createContext(null);
context.displayName = 'InputGroupContext';

const propTypes$a = {
    /**
     * @default 'dropdown-menu'
     */
    bsPrefix: PropTypes.string,
    /** Controls the visibility of the Dropdown menu  */
    show: PropTypes.bool,
    /** Whether to render the dropdown menu in the DOM before the first time it is shown */
    renderOnMount: PropTypes.bool,
    /** Have the dropdown switch to it's opposite placement when necessary to stay on screen. */
    flip: PropTypes.bool,
    /**
     * Aligns the dropdown menu to the specified side of the container. You can also align
     * the menu responsively for breakpoints starting at `sm` and up. The alignment
     * direction will affect the specified breakpoint or larger.
     *
     * *Note: Using responsive alignment will disable Popper usage for positioning.*
     *
     * @type {"start"|"end"|{ sm: "start"|"end" }|{ md: "start"|"end" }|{ lg: "start"|"end" }|{ xl: "start"|"end"}|{ xxl: "start"|"end"} }
     */
    align: alignPropType,
    onSelect: PropTypes.func,
    /**
     * Which event when fired outside the component will cause it to be closed
     *
     * *Note: For custom dropdown components, you will have to pass the
     * `rootCloseEvent` to `<RootCloseWrapper>` in your custom dropdown menu
     * component ([similarly to how it is implemented in `<Dropdown.Menu>`](https://github.com/react-bootstrap/react-bootstrap/blob/v0.31.5/src/DropdownMenu.js#L115-L119)).*
     */
    rootCloseEvent: PropTypes.oneOf(['click', 'mousedown']),
    /**
     * Control the rendering of the DropdownMenu. All non-menu props
     * (listed here) are passed through to the `as` Component.
     *
     * If providing a custom, non DOM, component. the `show`, `close` and `align` props
     * are also injected and should be handled appropriately.
     */
    as: PropTypes.elementType,
    /**
     * A set of popper options and props passed directly to Popper.
     */
    popperConfig: PropTypes.object,
    /**
     * Menu color variant.
     *
     * Omitting this will use the default light color.
     */
    variant: PropTypes.string,
    /** @private Provides context when used in NavDropdown component  */
    isNav: PropTypes.bool,
};
const defaultProps$4 = {
    flip: true,
};
function getDropdownMenuPlacement(alignEnd, dropDirection, isRTL) {
    const topStart = isRTL ? 'top-end' : 'top-start';
    const topEnd = isRTL ? 'top-start' : 'top-end';
    const bottomStart = isRTL ? 'bottom-end' : 'bottom-start';
    const bottomEnd = isRTL ? 'bottom-start' : 'bottom-end';
    // const leftStart = isRTL ? 'right-start' : 'left-start';
    // const leftEnd = isRTL ? 'right-end' : 'left-end';
    const rightStart = isRTL ? 'left-start' : 'right-start';
    const rightEnd = isRTL ? 'left-end' : 'right-end';
    let placement = alignEnd ? bottomEnd : bottomStart;
    if (dropDirection === 'up')
        placement = alignEnd ? topEnd : topStart;
    else if (dropDirection === 'end')
        placement = alignEnd ? rightEnd : rightStart;
    // else if (dropDirection === 'start')
    //   placement = alignEnd ? leftEnd : leftStart;
    return placement;
}
const DropdownMenu = React.forwardRef(({ bsPrefix, className, align, rootCloseEvent, flip, show: showProps, renderOnMount, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'ul', popperConfig, variant, isNav, ...props }, ref) => {
    let alignEnd = false;
    const isNavbar = useContext(context$1);
    const prefix = 'dropdown-menu';
    const { align: contextAlign, drop, isRTL } = useContext(DropdownContext);
    align = align || contextAlign;
    const isInputGroup = useContext(context);
    const alignClasses = [];
    if (align) {
        if (typeof align === 'object') {
            const keys = Object.keys(align);
            warning(keys.length === 1, 'There should only be 1 breakpoint when passing an object to `align`');
            if (keys.length) {
                const brkPoint = keys[0];
                const direction = align[brkPoint];
                // .dropdown-menu-end is required for responsively aligning
                // left in addition to align left classes.
                alignEnd = direction === 'start';
                alignClasses.push(`${prefix}-${brkPoint}-${direction}`);
            }
        }
        else if (align === 'end') {
            alignEnd = true;
        }
    }
    const placement = getDropdownMenuPlacement(alignEnd, drop, isRTL);
    const [menuProps, { hasShown, popper, show, toggle }] = useDropdownMenu({
        flip,
        rootCloseEvent,
        show: showProps,
        usePopper: !isNavbar && alignClasses.length === 0,
        offset: !isNav ? [0, 10] : undefined,
        popperConfig,
        placement,
    });
    menuProps.ref = useMergedRefs(useWrappedRefWithWarning(ref, 'DropdownMenu'), menuProps.ref);
    useIsomorphicEffect(() => {
        // Popper's initial position for the menu is incorrect when
        // renderOnMount=true. Need to call update() to correct it.
        if (show)
            popper?.update();
    }, [show]);
    if (!hasShown && !renderOnMount && !isInputGroup)
        return null;
    // For custom components provide additional, non-DOM, props;
    if (typeof Component !== 'string') {
        menuProps.show = show;
        menuProps.close = () => toggle?.(false);
        menuProps.align = align;
    }
    let style = props.style;
    if (popper?.placement) {
        // we don't need the default popper style,
        // menus are display: none when not shown.
        style = { ...props.style, ...menuProps.style };
        //@ts-ignore
        props['x-placement'] = popper.placement;
    }
    return (React.createElement(Component, { ...props, ...menuProps, style: style, ...((alignClasses.length || isNavbar) && {
            'data-bs-popper': 'static',
        }), className: classNames(className, prefix, show && 'show', alignEnd && `${prefix}-end`, variant && `${prefix}-${variant}`, ...alignClasses) }));
});
DropdownMenu.displayName = 'DropdownMenu';
DropdownMenu.propTypes = propTypes$a;
DropdownMenu.defaultProps = defaultProps$4;

const propTypes$9 = {
    /**
     * @default 'btn'
     */
    bsPrefix: PropTypes.string,
    /**
     * One or more button variant combinations
     *
     * buttons may be one of a variety of visual variants such as:
     *
     * `'primary', 'secondary', 'success', 'danger', 'warning', 'info', 'dark', 'light', 'link'`
     *
     * as well as "outline" versions (prefixed by 'outline-*')
     *
     * `'outline-primary', 'outline-secondary', 'outline-success', 'outline-danger', 'outline-warning', 'outline-info', 'outline-dark', 'outline-light'`
     */
    variant: PropTypes.string,
    /**
     * Specifies a large or small button.
     *
     * @type ('sm'|'lg')
     */
    size: PropTypes.string,
    /** Manually set the visual state of the button to `:active` */
    active: PropTypes.bool,
    /**
     * Disables the Button, preventing mouse events,
     * even if the underlying component is an `<a>` element
     */
    disabled: PropTypes.bool,
    /** Providing a `href` will render an `<a>` element, _styled_ as a button. */
    href: PropTypes.string,
    /**
     * Defines HTML button type attribute.
     *
     * @default 'button'
     */
    type: PropTypes.oneOf(['button', 'reset', 'submit', null]),
    as: PropTypes.elementType,
};
const defaultProps$3 = {
    variant: 'primary',
    active: false,
    disabled: false,
};
const Button = React.forwardRef(({ as, bsPrefix, variant, size, active, className, ...props }, ref) => {
    const prefix = useBootstrapPrefix(bsPrefix, 'btn');
    const [buttonProps, { tagName }] = useButtonProps({
        tagName: as,
        ...props,
    });
    const Component = tagName;
    return (React.createElement(SGDSWrapper, { as: Component, ...props, ...buttonProps, ref: ref, className: classNames(className, prefix, active && 'active', variant && `${prefix}-${variant}`, size && `${prefix}-${size}`, props.href && props.disabled && 'disabled') }));
});
Button.displayName = 'Button';
Button.propTypes = propTypes$9;
Button.defaultProps = defaultProps$3;

const propTypes$8 = {
    /**
     * @default 'dropdown-toggle'
     */
    bsPrefix: PropTypes.string,
    /**
     * An html id attribute, necessary for assistive technologies, such as screen readers.
     * @type {string|number}
     */
    id: PropTypes.string,
    split: PropTypes.bool,
    as: PropTypes.elementType,
    /**
     * to passthrough to the underlying button or whatever from DropdownButton
     * @private
     */
    childBsPrefix: PropTypes.string,
};
const DropdownToggle = React.forwardRef(({ bsPrefix, split, className, childBsPrefix, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = Button, ...props }, ref) => {
    const prefix = 'dropdown-toggle';
    const dropdownContext = useContext(DropdownContext$1);
    const isInputGroup = useContext(context);
    if (childBsPrefix !== undefined) {
        props.bsPrefix = childBsPrefix;
    }
    const [toggleProps] = useDropdownToggle();
    toggleProps.ref = useMergedRefs(toggleProps.ref, useWrappedRefWithWarning(ref, 'DropdownToggle'));
    // This intentionally forwards size and variant (if set) to the
    // underlying component, to allow it to render size and style variants.
    return (React.createElement(Component, { className: classNames(className, prefix, split && `${prefix}-split`, !!isInputGroup && dropdownContext?.show && 'show'), variant: "outline-secondary", ...toggleProps, ...props, "aria-haspopup": "menu" }));
});
DropdownToggle.displayName = 'DropdownToggle';
DropdownToggle.propTypes = propTypes$8;

const DropdownHeader = createWithBsPrefix('dropdown-header', {
    defaultProps: { role: 'heading' },
});
const DropdownDivider = createWithBsPrefix('dropdown-divider', {
    Component: 'hr',
    defaultProps: { role: 'separator' },
});
const DropdownItemText = createWithBsPrefix('dropdown-item-text', {
    Component: 'span',
});

const propTypes$7 = {
    /** @default 'dropdown' */
    bsPrefix: PropTypes.string,
    /**
     * Determines the direction and location of the Menu in relation to it's Toggle.
     *
     * @type {"end"|"up"|"down" }
     */
    drop: PropTypes.oneOf(['up', 'end', 'down']),
    as: PropTypes.elementType,
    align: alignDirection,
    /**
     * Whether or not the Dropdown is visible.
     *
     * @controllable onToggle
     */
    show: PropTypes.bool,
    /**
     * Allow Dropdown to flip in case of an overlapping on the reference element. For more information refer to
     * Popper.js's flip [docs](https://popper.js.org/docs/v2/modifiers/flip/).
     *
     */
    flip: PropTypes.bool,
    /**
     * A callback fired when the Dropdown wishes to change visibility. Called with the requested
     * `show` value, the DOM event, and the source that fired it: `'click'`,`'keydown'`,`'rootClose'`, or `'select'`.
     *
     * ```js
     * function(
     *   isOpen: boolean,
     *   event: SyntheticEvent,
     *   metadata: {
     *     source: 'select' | 'click' | 'rootClose' | 'keydown'
     *   }
     * ): void
     * ```
     *
     * @controllable show
     */
    onToggle: PropTypes.func,
    /**
     * A callback fired when a menu item is selected.
     *
     * ```js
     * (eventKey: any, event: Object) => any
     * ```
     */
    onSelect: PropTypes.func,
    /**
     * Controls the focus behavior for when the Dropdown is opened. Set to
     * `true` to always focus the first menu item, `keyboard` to focus only when
     * navigating via the keyboard, or `false` to disable completely
     *
     * The Default behavior is `false` **unless** the Menu has a `role="menu"`
     * where it will default to `keyboard` to match the recommended [ARIA Authoring practices](https://www.w3.org/TR/wai-aria-practices-1.1/#menubutton).
     */
    focusFirstItemOnShow: PropTypes.oneOf([false, true, 'keyboard']),
    /** @private */
    navbar: PropTypes.bool,
    /**
     * Controls the auto close behaviour of the dropdown when clicking outside of
     * the button or the list.
     */
    autoClose: PropTypes.oneOf([true, 'outside', 'inside', false]),
};
const defaultProps$2 = {
    navbar: false,
    align: 'start',
    autoClose: true,
    focusFirstItemOnShow: 'keyboard',
};
const Dropdown = React.forwardRef((pProps, ref) => {
    const { bsPrefix, drop, show, className, align, onSelect, onToggle, focusFirstItemOnShow, 
    // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
    as: Component = 'div', navbar: _4, autoClose, ...props } = useUncontrolled(pProps, { show: 'onToggle' });
    const isInputGroup = useContext(context);
    const prefix = useBootstrapPrefix(bsPrefix, 'dropdown');
    const isRTL = useIsRTL();
    const isClosingPermitted = (source) => {
        // autoClose=false only permits close on button click
        if (autoClose === false)
            return source === 'click';
        // autoClose=inside doesn't permit close on rootClose
        if (autoClose === 'inside')
            return source !== 'rootClose';
        // autoClose=outside doesn't permit close on select
        if (autoClose === 'outside')
            return source !== 'select';
        return true;
    };
    const handleToggle = useEventCallback((nextShow, meta) => {
        if (meta.originalEvent.currentTarget === document &&
            (meta.source !== 'keydown' ||
                meta.originalEvent.key === 'Escape'))
            meta.source = 'rootClose';
        if (isClosingPermitted(meta.source))
            onToggle?.(nextShow, meta);
    });
    const alignEnd = align === 'end';
    const placement = getDropdownMenuPlacement(alignEnd, drop, isRTL);
    const contextValue = useMemo(() => ({
        align,
        drop,
        isRTL,
    }), [align, drop, isRTL]);
    return (React.createElement(DropdownContext.Provider, { value: contextValue },
        React.createElement(BaseDropdown, { placement: placement, show: show, onSelect: onSelect, onToggle: handleToggle, focusFirstItemOnShow: focusFirstItemOnShow, itemSelector: `.${prefix}-item:not(.disabled):not(:disabled)` }, isInputGroup ? (props.children) : (React.createElement(SGDSWrapper, { as: Component, ...props, ref: ref, className: classNames(className, show && 'show', prefix, drop === 'up' && 'dropup', drop === 'end' && 'dropend') })))));
});
Dropdown.displayName = 'Dropdown';
Dropdown.propTypes = propTypes$7;
Dropdown.defaultProps = defaultProps$2;
var Dropdown$1 = Object.assign(Dropdown, {
    Toggle: DropdownToggle,
    Menu: DropdownMenu,
    Item: DropdownItem,
    ItemText: DropdownItemText,
    Divider: DropdownDivider,
    Header: DropdownHeader,
});

const NavContext = React.createContext(null);
NavContext.displayName = 'NavContext';

const propTypes$6 = {
    /**
     * An html id attribute for the Toggle button, necessary for assistive technologies, such as screen readers.
     * @type {string}
     */
    id: PropTypes.string,
    /** An `onClick` handler passed to the Toggle component */
    onClick: PropTypes.func,
    /** The content of the non-toggle Button.  */
    title: PropTypes.node.isRequired,
    /** Disables the toggle NavLink  */
    disabled: PropTypes.bool,
    /** Style the toggle NavLink as active  */
    active: PropTypes.bool,
    /** An ARIA accessible role applied to the Menu component. When set to 'menu', The dropdown */
    menuRole: PropTypes.string,
    /** Whether to render the dropdown menu in the DOM before the first time it is shown */
    renderMenuOnMount: PropTypes.bool,
    /**
     *  Which event when fired outside the component will cause it to be closed.
     *
     * _see [DropdownMenu](#menu-props) for more details_
     */
    rootCloseEvent: PropTypes.string,
    /**
     * Menu color variant.
     *
     * Omitting this will use the default light color.
     */
    menuVariant: PropTypes.oneOf(['dark']),
    /** @ignore */
    bsPrefix: PropTypes.string,
    /** When true, applies mega menu stylings */
    isMegaMenu: PropTypes.bool,
    eventKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
};
const NavDropdown = React.forwardRef(({ id, title, children, bsPrefix, className, rootCloseEvent, menuRole, disabled, active, renderMenuOnMount, menuVariant, isMegaMenu, eventKey, align, ...props }, ref) => {
    /* NavItem has no additional logic, it's purely presentational. Can set nav item class here to support "as" */
    const navContext = useContext(NavContext);
    const navItemPrefix = useBootstrapPrefix(undefined, 'nav-item');
    const dropDownClass = classNames(className, navItemPrefix, isMegaMenu ? 'has-megamenu' : undefined);
    return (React.createElement(Dropdown$1, { ref: ref, as: "li", ...props, className: dropDownClass, align: align },
        React.createElement(Dropdown$1.Toggle, { id: id, eventKey: null, active: active || navContext?.activeKey === eventKey, disabled: disabled, childBsPrefix: bsPrefix, as: NavLink },
            title,
            React.createElement("i", { className: "bi bi-chevron-down" })),
        React.createElement(Dropdown$1.Menu, { role: menuRole, renderOnMount: renderMenuOnMount, rootCloseEvent: rootCloseEvent, variant: menuVariant, isNav: true, align: align, as: isMegaMenu ? 'div' : undefined, className: isMegaMenu ? 'mega-menu' : undefined }, children)));
});
NavDropdown.displayName = 'NavDropdown';
NavDropdown.propTypes = propTypes$6;
var NavDropdown$1 = Object.assign(NavDropdown, {
    Item: Dropdown$1.Item,
    ItemText: Dropdown$1.ItemText,
    Divider: Dropdown$1.Divider,
    Header: Dropdown$1.Header,
});

const propTypes$5 = {
    /**
     * @default 'nav'
     */
    bsPrefix: PropTypes.string,
    /** @private */
    // navbarBsPrefix: PropTypes.string,
    /** @private */
    // cardHeaderBsPrefix: PropTypes.string,
    /**
     * The visual variant of the nav items.
     *
     * @type {('tabs-basic-toggle' | 'tabs-info-toggle')}
     */
    variant: PropTypes.string,
    /**
     * The default active key that is selected on start.
     */
    defaultActiveKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    /**
     * Marks the NavItem with a matching `eventKey` (or `href` if present) as active.
     */
    activeKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    /**
     * A callback fired when a NavItem is selected.
     *
     * ```js
     * function (
     *  Any eventKey,
     *  SyntheticEvent event?
     * )
     * ```
     */
    onSelect: PropTypes.func,
    /**
     * ARIA role for the Nav, in the context of a TabContainer, the default will
     * be set to "tablist", but can be overridden by the Nav when set explicitly.
     *
     * When the role is "tablist", NavLink focus is managed according to
     * the ARIA authoring practices for tabs:
     * https://www.w3.org/TR/2013/WD-wai-aria-practices-20130307/#tabpanel
     */
    role: PropTypes.string,
    /**
     * Apply styling an alignment for use in a Navbar. This prop will be set
     * automatically when the Nav is used inside a Navbar.
     */
    // navbar: PropTypes.bool,
    /**
     * Enable vertical scrolling within the toggleable contents of a collapsed Navbar.
     */
    navbarScroll: PropTypes.bool,
    as: PropTypes.elementType,
    /** @private */
    onKeyDown: PropTypes.func,
};
const Nav = React.forwardRef((uncontrolledProps, ref) => {
    const { as = 'ul', bsPrefix: initialBsPrefix, navbarScroll, className, activeKey, ...props } = useUncontrolled(uncontrolledProps, { activeKey: 'onSelect' });
    const bsPrefix = useBootstrapPrefix(initialBsPrefix, 'nav');
    const contextValue = useMemo(() => ({
        activeKey,
    }), [activeKey]);
    const navbarContext = useContext(context$1);
    return (React.createElement(NavContext.Provider, { value: contextValue },
        React.createElement(BaseNav, { as: as, ref: ref, activeKey: activeKey, className: classNames(className, {
                [bsPrefix]: !navbarContext,
                [`${navbarContext?.bsPrefix}-nav`]: navbarContext,
                [`${navbarContext?.bsPrefix}-nav-scroll`]: navbarContext && navbarScroll,
                ['sgds']: !navbarContext,
                ['nav-tabs']: !navbarContext,
            }), ...props })));
});
Nav.displayName = 'Nav';
Nav.propTypes = propTypes$5;
var Nav$1 = Object.assign(Nav, {
    Item: NavItem,
    Link: NavLink,
    Dropdown: NavDropdown$1,
});

const TabContent = createWithBsPrefix('sgds tab-content');

const propTypes$4 = {
    /**
     * Show the component; triggers the fade in or fade out animation
     */
    in: PropTypes.bool,
    /**
     * Wait until the first "enter" transition to mount the component (add it to the DOM)
     */
    mountOnEnter: PropTypes.bool,
    /**
     * Unmount the component (remove it from the DOM) when it is faded out
     */
    unmountOnExit: PropTypes.bool,
    /**
     * Run the fade in animation when the component mounts, if it is initially
     * shown
     */
    appear: PropTypes.bool,
    /**
     * Duration of the fade animation in milliseconds, to ensure that finishing
     * callbacks are fired even if the original browser transition end events are
     * canceled
     */
    timeout: PropTypes.number,
    /**
     * Callback fired before the component fades in
     */
    onEnter: PropTypes.func,
    /**
     * Callback fired after the component starts to fade in
     */
    onEntering: PropTypes.func,
    /**
     * Callback fired after the has component faded in
     */
    onEntered: PropTypes.func,
    /**
     * Callback fired before the component fades out
     */
    onExit: PropTypes.func,
    /**
     * Callback fired after the component starts to fade out
     */
    onExiting: PropTypes.func,
    /**
     * Callback fired after the component has faded out
     */
    onExited: PropTypes.func,
    /**
     * You must provide a single JSX child element to this component and that element cannot be a \<React.Fragment\>
     */
    children: PropTypes.element.isRequired,
    /**
     * Applies additional specified classes during the transition. Takes an object
     * where the keys correspond to the Transition status
     */
    transitionClasses: PropTypes.object,
};
const defaultProps$1 = {
    in: false,
    timeout: 300,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
};
const fadeStyles = {
    [ENTERING]: 'show',
    [ENTERED]: 'show',
};
const Fade = React.forwardRef(({ className, children, transitionClasses = {}, ...props }, ref) => {
    const handleEnter = useCallback((node, isAppearing) => {
        triggerBrowserReflow(node);
        props.onEnter?.(node, isAppearing);
    }, [props]);
    return (React.createElement(TransitionWrapper, { ref: ref, addEndListener: transitionEndListener, ...props, onEnter: handleEnter, childRef: children.ref }, (status, innerProps) => React.cloneElement(children, {
        ...innerProps,
        className: classNames('fade', className, children.props.className, 
        //@ts-ignore
        fadeStyles[status], transitionClasses[status]),
    })));
});
Fade.propTypes = propTypes$4;
Fade.defaultProps = defaultProps$1;
Fade.displayName = 'Fade';

const propTypes$3 = {
    /**
     * @default 'tab-pane'
     */
    bsPrefix: PropTypes.string,
    as: PropTypes.elementType,
    /**
     * A key that associates the `TabPane` with it's controlling `NavLink`.
     */
    eventKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    /**
     * Toggles the active state of the TabPane, this is generally controlled by a
     * TabContainer.
     */
    active: PropTypes.bool,
    /**
     * Use animation when showing or hiding `<TabPane>`s. Defaults to `<Fade>`
     * animation, else use `false` to disable or a react-transition-group
     * `<Transition/>` component.
     */
    transition: PropTypes.oneOfType([PropTypes.bool, PropTypes.elementType]),
    /**
     * Transition onEnter callback when animation is not `false`
     */
    onEnter: PropTypes.func,
    /**
     * Transition onEntering callback when animation is not `false`
     */
    onEntering: PropTypes.func,
    /**
     * Transition onEntered callback when animation is not `false`
     */
    onEntered: PropTypes.func,
    /**
     * Transition onExit callback when animation is not `false`
     */
    onExit: PropTypes.func,
    /**
     * Transition onExiting callback when animation is not `false`
     */
    onExiting: PropTypes.func,
    /**
     * Transition onExited callback when animation is not `false`
     */
    onExited: PropTypes.func,
    /**
     * Wait until the first "enter" transition to mount the tab (add it to the DOM)
     */
    mountOnEnter: PropTypes.bool,
    /**
     * Unmount the tab (remove it from the DOM) when it is no longer visible
     */
    unmountOnExit: PropTypes.bool,
    /** @ignore * */
    id: PropTypes.string,
    /** @ignore * */
    'aria-labelledby': PropTypes.string,
};
const TabPane = React.forwardRef(({ bsPrefix, transition, ...props }, ref) => {
    const [{ className, 
    // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
    as: Component = 'div', ...rest }, { isActive, onEnter, onEntering, onEntered, onExit, onExiting, onExited, mountOnEnter, unmountOnExit, transition: Transition = Fade, },] = useTabPanel({
        ...props,
        transition: getTabTransitionComponent(transition),
    });
    const { mdxType, originalType, contentLeft, contentRight, contentBottom, variant, ...attrs } = rest;
    const prefix = useBootstrapPrefix(bsPrefix, 'tab-pane');
    // We provide an empty the TabContext so `<Nav>`s in `<TabPanel>`s don't
    // conflict with the top level one.
    return (React.createElement(TabContext.Provider, { value: null },
        React.createElement(SelectableContext.Provider, { value: null },
            React.createElement(Transition, { in: isActive, onEnter: onEnter, onEntering: onEntering, onEntered: onEntered, onExit: onExit, onExiting: onExiting, onExited: onExited, mountOnEnter: mountOnEnter, unmountOnExit: unmountOnExit },
                React.createElement(Component, { ...attrs, ref: ref, className: classNames(className, prefix, isActive && 'active') })))));
});
TabPane.displayName = 'TabPane';
TabPane.propTypes = propTypes$3;

const propTypes$2 = {
    /**
     * Mark the Tab with a matching `eventKey` as active.
     *
     * @controllable onSelect
     */
    activeKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    /** The default active key that is selected on start */
    defaultActiveKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    /**
     * Navigation style
     *
     * @type {('tabs-basic-toggle'| 'tabs-info-toggle')}
     */
    variant: PropTypes.string,
    /**
     * Sets a default animation strategy for all children `<TabPane>`s.<tbcont
     *
     * Defaults to `<Fade>` animation, else use `false` to disable or a
     * react-transition-group `<Transition/>` component.
     *
     * @type {Transition | false}
     * @default {Fade}
     */
    transition: PropTypes.oneOfType([
        PropTypes.oneOf([false]),
        PropTypes.elementType,
    ]),
    /**
     * HTML id attribute, required if no `generateChildId` prop
     * is specified.
     *
     * @type {string}
     */
    id: PropTypes.string,
    /**
     * Callback fired when a Tab is selected.
     *
     * ```js
     * function (
     *   Any eventKey,
     *   SyntheticEvent event?
     * )
     * ```
     *
     * @controllable activeKey
     */
    onSelect: PropTypes.func,
    /**
     * Wait until the first "enter" transition to mount tabs (add them to the DOM)
     */
    mountOnEnter: PropTypes.bool,
    /**
     * Unmount tabs (remove it from the DOM) when it is no longer visible
     */
    unmountOnExit: PropTypes.bool,
};
const defaultProps = {
    // variant: 'tabs',
    mountOnEnter: false,
    unmountOnExit: false,
};
function getDefaultActiveKey(children) {
    let defaultActiveKey;
    forEach(children, (child) => {
        if (defaultActiveKey == null) {
            defaultActiveKey = child.props.eventKey;
        }
    });
    return defaultActiveKey;
}
function renderTab(variant) {
    return (child) => {
        const { title, eventKey, disabled, tabClassName, tabAttrs, id, contentLeft, contentRight, contentBottom, } = child.props;
        if (title == null) {
            return null;
        }
        const tabsBasic = (React.createElement(React.Fragment, null,
            contentLeft,
            title,
            contentRight));
        const tabsInfo = (React.createElement(React.Fragment, null,
            React.createElement("div", { className: `tabs-info-label ${contentLeft ? 'has-icon' : ''}` },
                contentLeft,
                title),
            React.createElement("div", { className: "tabs-info-count" }, contentBottom)));
        return (React.createElement(NavItem, { as: "li", role: "presentation" },
            React.createElement(NavLink, { as: "button", type: "button", eventKey: eventKey, disabled: disabled, id: id, className: tabClassName, ...tabAttrs }, variant === 'tabs-info-toggle' ? tabsInfo : tabsBasic)));
    };
}
const Tabs = (props) => {
    const { id, variant, onSelect, transition, mountOnEnter, unmountOnExit, children, activeKey = getDefaultActiveKey(children), ...controlledProps } = useUncontrolled(props, {
        activeKey: 'onSelect',
    });
    return (React.createElement(BaseTabs, { id: id, activeKey: activeKey, onSelect: onSelect, transition: getTabTransitionComponent(transition), mountOnEnter: mountOnEnter, unmountOnExit: unmountOnExit },
        React.createElement(Nav$1, { ...controlledProps, role: "tablist", as: "ul", variant: props.variant }, map(children, renderTab(variant))),
        React.createElement(TabContent, null, map(children, (child) => {
            const childProps = { ...child.props };
            delete childProps.title;
            delete childProps.disabled;
            delete childProps.tabClassName;
            delete childProps.tabAttrs;
            return React.createElement(TabPane, { ...childProps });
        }))));
};
Tabs.propTypes = propTypes$2;
Tabs.defaultProps = defaultProps;
Tabs.displayName = 'Tabs';

const propTypes$1 = {
    /**
     * HTML id attribute, required if no `generateChildId` prop
     * is specified.
     *
     * @type {string}
     */
    id: PropTypes.string,
    /**
     * Sets a default animation strategy for all children `<TabPane>`s.
     * Defaults to `<Fade>` animation; else, use `false` to disable, or a
     * custom react-transition-group `<Transition/>` component.
     *
     * @type {{Transition | false}}
     * @default {Fade}
     */
    transition: PropTypes.oneOfType([
        PropTypes.oneOf([false]),
        PropTypes.elementType,
    ]),
    /**
     * Wait until the first "enter" transition to mount tabs (add them to the DOM)
     */
    mountOnEnter: PropTypes.bool,
    /**
     * Unmount tabs (remove it from the DOM) when they are no longer visible
     */
    unmountOnExit: PropTypes.bool,
    /**
     * A function that takes an `eventKey` and `type` and returns a unique id for
     * child tab `<NavItem>`s and `<TabPane>`s. The function _must_ be a pure
     * function, meaning it should always return the _same_ id for the same set
     * of inputs. The default value requires that an `id` to be set for the
     * `<TabContainer>`.
     *
     * The `type` argument will either be `"tab"` or `"pane"`.
     *
     * @defaultValue (eventKey, type) => `${props.id}-${type}-${eventKey}`
     */
    generateChildId: PropTypes.func,
    /**
     * A callback fired when a tab is selected.
     *
     * @controllable activeKey
     */
    onSelect: PropTypes.func,
    /**
     * The `eventKey` of the currently active tab.
     *
     * @controllable onSelect
     */
    activeKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
};
const TabContainer = ({ transition, ...props }) => (React.createElement(BaseTabs, { ...props, transition: getTabTransitionComponent(transition) }));
TabContainer.propTypes = propTypes$1;
TabContainer.displayName = 'TabContainer';

/* eslint-disable react/no-unused-prop-types */
const propTypes = {
    eventKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    /**
     * Content for the tab title.
     */
    title: PropTypes.node.isRequired,
    /**
     * The disabled state of the tab.
     */
    disabled: PropTypes.bool,
    /**
     * Class to pass to the underlying nav link.
     */
    tabClassName: PropTypes.string,
    /**
     * Object containing attributes to pass to underlying nav link.
     */
    tabAttrs: PropTypes.object,
    /**
    * Content to the left of title.
    */
    contentLeft: PropTypes.node,
    /**
    * Content to the right of title. Not applicable to tabs-info-toggle variant.
    */
    contentRight: PropTypes.node,
    /**
     * Content to the bottom of title. Applicable to tabs-info-toggle variant only.
     */
    contentBottom: PropTypes.node,
};
const Tab = () => {
    throw new Error('ReactBootstrap: The `Tab` component is not meant to be rendered! ' +
        "It's an abstract component that is only valid as a direct Child of the `Tabs` Component. " +
        'For custom tabs components use TabPane and TabsContainer directly');
};
Tab.propTypes = propTypes;
var Tab$1 = Object.assign(Tab, {
    Container: TabContainer,
    Content: TabContent,
    Pane: TabPane,
});

export { Tab$1 as Tab, TabContainer, TabContent, TabPane, Tabs };
