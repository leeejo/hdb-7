'use client';
import classNames from 'classnames';
import * as React from 'react';
import React__default, { useContext, useMemo } from 'react';
import PropTypes from 'prop-types';
import { useUncontrolled } from 'uncontrollable';
import { useButtonProps } from '@restart/ui/Button';
import useMergedRefs from '@restart/hooks/useMergedRefs';
import css from 'dom-helpers/css';
import { EXITED, EXITING, ENTERING, ENTERED } from 'react-transition-group/Transition';
import transitionEndListener from '../utils/transitionEndListener';
import createChainedFunction from '../utils/createChainedFunction';
import triggerBrowserReflow from '../utils/triggerBrowserReflow';
import TransitionWrapper from '../utils/TransitionWrapper';
import Anchor from '@restart/ui/Anchor';
import { useNavItem } from '@restart/ui/NavItem';
import { makeEventKey } from '@restart/ui/SelectableContext';

const ThemeContext = React.createContext({ prefixes: {} });
({
    prefixes: PropTypes.object,
    dir: PropTypes.string,
});
function useBootstrapPrefix(prefix, defaultPrefix) {
    const { prefixes } = useContext(ThemeContext);
    return prefix || prefixes[defaultPrefix] || `${defaultPrefix}`;
}
const SGDSWrapper = React.forwardRef(({ as: Tag = 'div', ...props }, ref) => {
    return React.createElement(Tag, { ref: ref, ...props, className: classNames(props.className, 'sgds') });
});

function isSideNavItemSelected(activeEventKey, eventKey) {
    return Array.isArray(activeEventKey)
        ? activeEventKey.includes(eventKey)
        : activeEventKey === eventKey;
}
const context$1 = React.createContext({});
context$1.displayName = 'SideNavContext';

const context = React.createContext({
    eventKey: '',
});
context.displayName = 'SideNavItemContext';

const propTypes$7 = {
    /**
     * @default 'btn'
     */
    bsPrefix: PropTypes.string,
    /**
     * One or more button variant combinations
     *
     * buttons may be one of a variety of visual variants such as:
     *
     * `'primary', 'secondary', 'success', 'danger', 'warning', 'info', 'dark', 'light', 'link'`
     *
     * as well as "outline" versions (prefixed by 'outline-*')
     *
     * `'outline-primary', 'outline-secondary', 'outline-success', 'outline-danger', 'outline-warning', 'outline-info', 'outline-dark', 'outline-light'`
     */
    variant: PropTypes.string,
    /**
     * Specifies a large or small button.
     *
     * @type ('sm'|'lg')
     */
    size: PropTypes.string,
    /** Manually set the visual state of the button to `:active` */
    active: PropTypes.bool,
    /**
     * Disables the Button, preventing mouse events,
     * even if the underlying component is an `<a>` element
     */
    disabled: PropTypes.bool,
    /** Providing a `href` will render an `<a>` element, _styled_ as a button. */
    href: PropTypes.string,
    /**
     * Defines HTML button type attribute.
     *
     * @default 'button'
     */
    type: PropTypes.oneOf(['button', 'reset', 'submit', null]),
    as: PropTypes.elementType,
};
const defaultProps$2 = {
    variant: 'primary',
    active: false,
    disabled: false,
};
const Button = React.forwardRef(({ as, bsPrefix, variant, size, active, className, ...props }, ref) => {
    const prefix = useBootstrapPrefix(bsPrefix, 'btn');
    const [buttonProps, { tagName }] = useButtonProps({
        tagName: as,
        ...props,
    });
    const Component = tagName;
    return (React.createElement(SGDSWrapper, { as: Component, ...props, ...buttonProps, ref: ref, className: classNames(className, prefix, active && 'active', variant && `${prefix}-${variant}`, size && `${prefix}-${size}`, props.href && props.disabled && 'disabled') }));
});
Button.displayName = 'Button';
Button.propTypes = propTypes$7;
Button.defaultProps = defaultProps$2;

const propTypes$6 = {
    /** Set a custom element for this component */
    as: PropTypes.elementType,
    /** @default 'sidenav-button' */
    bsPrefix: PropTypes.string,
    /** A callback function for when this component is clicked */
    onClick: PropTypes.func,
    /** Providing a `href` will render an `<a>` element, _styled_ as a button. */
    href: PropTypes.string,
};
function useSideNavButton(eventKey, onClick) {
    const { activeEventKey, onSelect, alwaysOpen } = useContext(context$1);
    return (e) => {
        /*
          Compare the event key in context with the given event key.
          If they are the same, then collapse the component.
        */
        let eventKeyPassed = eventKey === activeEventKey ? null : eventKey;
        if (alwaysOpen) {
            if (Array.isArray(activeEventKey)) {
                if (activeEventKey.includes(eventKey)) {
                    eventKeyPassed = activeEventKey.filter((k) => k !== eventKey);
                }
                else {
                    eventKeyPassed = [...activeEventKey, eventKey];
                }
            }
            else {
                // activeEventKey is undefined.
                eventKeyPassed = [eventKey];
            }
        }
        onSelect?.(eventKeyPassed, e);
        onClick?.(e);
    };
}
const setCollapseCSS = (activeEventKey, eventKey) => {
    if (Array.isArray(activeEventKey)) {
        return !activeEventKey.includes(eventKey) && 'collapsed';
    }
    if (typeof activeEventKey === 'string') {
        return activeEventKey !== eventKey && 'collapsed';
    }
    return 'collapsed';
};
const SideNavButton = React.forwardRef(({ 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = Button, bsPrefix, className, onClick, children, ...props }, ref) => {
    const btnRef = React.useRef(null);
    const mergedRef = useMergedRefs(ref, btnRef);
    const { eventKey } = useContext(context);
    const sideNavOnClick = useSideNavButton(eventKey, onClick);
    const { activeEventKey } = useContext(context$1);
    if (Component === 'button') {
        props.type = 'button';
    }
    return (React.createElement(Component, { ref: mergedRef, variant: '', onClick: sideNavOnClick, ...props, "aria-expanded": eventKey === activeEventKey, "aria-haspopup": "menu", className: classNames(className, setCollapseCSS(activeEventKey, eventKey)) },
        children,
        !props.href && React.createElement("i", { className: "bi bi-chevron-down" })));
});
SideNavButton.propTypes = propTypes$6;
SideNavButton.displayName = 'SideNavButton';

const MARGINS = {
    height: ['marginTop', 'marginBottom'],
    width: ['marginLeft', 'marginRight'],
};
function getDefaultDimensionValue(dimension, elem) {
    const offset = `offset${dimension[0].toUpperCase()}${dimension.slice(1)}`;
    const value = elem[offset];
    const margins = MARGINS[dimension];
    return (value +
        // @ts-ignore
        parseInt(css(elem, margins[0]), 10) +
        // @ts-ignore
        parseInt(css(elem, margins[1]), 10));
}
const collapseStyles = {
    [EXITED]: 'collapse',
    [EXITING]: 'collapsing',
    [ENTERING]: 'collapsing',
    [ENTERED]: 'collapse show',
};
const propTypes$5 = {
    /**
     * Show the component; triggers the expand or collapse animation
     */
    in: PropTypes.bool,
    /**
     * Wait until the first "enter" transition to mount the component (add it to the DOM)
     */
    mountOnEnter: PropTypes.bool,
    /**
     * Unmount the component (remove it from the DOM) when it is collapsed
     */
    unmountOnExit: PropTypes.bool,
    /**
     * Run the expand animation when the component mounts, if it is initially
     * shown
     */
    appear: PropTypes.bool,
    /**
     * Duration of the collapse animation in milliseconds, to ensure that
     * finishing callbacks are fired even if the original browser transition end
     * events are canceled
     */
    timeout: PropTypes.number,
    /**
     * Callback fired before the component expands
     */
    onEnter: PropTypes.func,
    /**
     * Callback fired after the component starts to expand
     */
    onEntering: PropTypes.func,
    /**
     * Callback fired after the component has expanded
     */
    onEntered: PropTypes.func,
    /**
     * Callback fired before the component collapses
     */
    onExit: PropTypes.func,
    /**
     * Callback fired after the component starts to collapse
     */
    onExiting: PropTypes.func,
    /**
     * Callback fired after the component has collapsed
     */
    onExited: PropTypes.func,
    /**
     * The dimension used when collapsing, or a function that returns the
     * dimension
     */
    dimension: PropTypes.oneOfType([
        PropTypes.oneOf(['height', 'width']),
        PropTypes.func,
    ]),
    /**
     * Function that returns the height or width of the animating DOM node
     *
     * Allows for providing some custom logic for how much the Collapse component
     * should animate in its specified dimension. Called with the current
     * dimension prop value and the DOM node.
     *
     * @default element.offsetWidth | element.offsetHeight
     */
    getDimensionValue: PropTypes.func,
    /**
     * ARIA role of collapsible element
     */
    role: PropTypes.string,
    /**
     * You must provide a single JSX child element to this component and that element cannot be a \<React.Fragment\>
     */
    children: PropTypes.element.isRequired,
};
const defaultProps$1 = {
    in: false,
    timeout: 300,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
    getDimensionValue: getDefaultDimensionValue,
};
const Collapse = React__default.forwardRef(({ onEnter, onEntering, onEntered, onExit, onExiting, className, children, dimension = 'height', getDimensionValue = getDefaultDimensionValue, ...props }, ref) => {
    /* Compute dimension */
    const computedDimension = typeof dimension === 'function' ? dimension() : dimension;
    /* -- Expanding -- */
    const handleEnter = useMemo(() => createChainedFunction((elem) => {
        elem.style[computedDimension] = '0';
    }, onEnter), [computedDimension, onEnter]);
    const handleEntering = useMemo(() => createChainedFunction((elem) => {
        const scroll = `scroll${computedDimension[0].toUpperCase()}${computedDimension.slice(1)}`;
        elem.style[computedDimension] = `${elem[scroll]}px`;
    }, onEntering), [computedDimension, onEntering]);
    const handleEntered = useMemo(() => createChainedFunction((elem) => {
        elem.style[computedDimension] = null;
    }, onEntered), [computedDimension, onEntered]);
    /* -- Collapsing -- */
    const handleExit = useMemo(() => createChainedFunction((elem) => {
        elem.style[computedDimension] = `${getDimensionValue(computedDimension, elem)}px`;
        triggerBrowserReflow(elem);
    }, onExit), [onExit, getDimensionValue, computedDimension]);
    const handleExiting = useMemo(() => createChainedFunction((elem) => {
        elem.style[computedDimension] = null;
    }, onExiting), [computedDimension, onExiting]);
    return (React__default.createElement(TransitionWrapper, { ref: ref, addEndListener: transitionEndListener, ...props, "aria-expanded": props.role ? props.in : null, onEnter: handleEnter, onEntering: handleEntering, onEntered: handleEntered, onExit: handleExit, onExiting: handleExiting, childRef: children.ref }, (state, innerProps) => React__default.cloneElement(children, {
        ...innerProps,
        className: classNames(className, children.props.className, collapseStyles[state], computedDimension === 'width' && 'collapse-horizontal'),
    })));
});
// @ts-ignore
Collapse.propTypes = propTypes$5;
// @ts-ignore
Collapse.defaultProps = defaultProps$1;

const propTypes$4 = {
    /** Set a custom element for this component */
    as: PropTypes.elementType,
    /** Children prop should only contain a single child, and is enforced as such */
    children: PropTypes.node,
};
const SideNavCollapse = React.forwardRef(({ as: Component = 'div', bsPrefix, className, children, ...props }, ref) => {
    const { activeEventKey } = useContext(context$1);
    const { eventKey: itemEventKey } = useContext(context);
    bsPrefix = useBootstrapPrefix(bsPrefix, 'sidenav-collapse');
    return (React.createElement(Collapse, { ref: ref, in: isSideNavItemSelected(activeEventKey, itemEventKey), ...props, className: classNames(className, bsPrefix) },
        React.createElement(Component, null,
            React.createElement("ul", { className: "list-unstyled" }, React.Children.map(children, child => (React.createElement("li", null, React.cloneElement(child))))))));
});
SideNavCollapse.propTypes = propTypes$4;
SideNavCollapse.displayName = 'SideNavCollapse';

const propTypes$3 = {
    /** Set a custom element for this component */
    as: PropTypes.elementType,
    /** @default 'accordion-item' */
    bsPrefix: PropTypes.string,
    /**
     * A unique key used to control this item's collapse/expand.
     * @required
     */
    eventKey: PropTypes.string.isRequired,
};
const SideNavItem = React.forwardRef(({ 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'li', bsPrefix, className, eventKey, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'sidenav-item');
    const contextValue = useMemo(() => ({
        eventKey,
    }), [eventKey]);
    return (React.createElement(context.Provider, { value: contextValue },
        React.createElement(Component, { ref: ref, ...props, className: classNames(className, bsPrefix) })));
});
SideNavItem.propTypes = propTypes$3;
SideNavItem.displayName = 'SideNavItem';

const propTypes$2 = {
    /**
     * @default 'nav-link'
     */
    bsPrefix: PropTypes.string,
    /**
     * The active state of the NavItem item.
     */
    active: PropTypes.bool,
    /**
     * The disabled state of the NavItem item.
     */
    disabled: PropTypes.bool,
    /**
     * The ARIA role for the `NavLink`, In the context of a 'tablist' parent Nav,
     * the role defaults to 'tab'
     * */
    role: PropTypes.string,
    /** The HTML href attribute for the `NavLink` */
    href: PropTypes.string,
    /**
     * Uniquely identifies the `NavItem` amongst its siblings,
     * used to determine and control the active state of the parent `Nav`
     */
    eventKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    /** @default 'a' */
    as: PropTypes.elementType,
};
const defaultProps = {
    disabled: false,
};
const NavLink = React.forwardRef(({ bsPrefix, className, as: Component = Anchor, active, eventKey, 
// onClick,
...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'nav-link');
    const [navItemProps, meta] = useNavItem({
        key: makeEventKey(eventKey, props.href),
        active,
        ...props,
    });
    return (React.createElement(Component, { ...props, ...navItemProps, ref: ref, className: classNames(className, bsPrefix, props.disabled && 'disabled', meta.isActive && 'active'), "aria-current": meta.isActive ? "page" : "false" }));
});
NavLink.displayName = 'NavLink';
NavLink.propTypes = propTypes$2;
NavLink.defaultProps = defaultProps;

const propTypes$1 = {
    eventKey: PropTypes.string.isRequired
};
const SideNavLink = React.forwardRef(({ eventKey, ...props }, ref) => {
    const { activeLinkKey } = React.useContext(context$1);
    return (React.createElement(NavLink, { ...props, ref: ref, eventKey: eventKey, active: activeLinkKey === eventKey }));
});
SideNavLink.displayName = 'SideNavLink';
SideNavLink.propTypes = propTypes$1;

const propTypes = {
    /** Set a custom element for this component */
    as: PropTypes.elementType,
    /** @default 'sidenav' */
    bsPrefix: PropTypes.string,
    /** The current active key that corresponds to the currently expanded card */
    activeKey: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),
    /** The default active key that is expanded on start */
    defaultActiveKey: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),
    /** Allow accordion items to stay open when another item is opened */
    alwaysOpen: PropTypes.bool,
    /** The current active NavLink that corresponds to the currently expanded card */
    activeNavLinkKey: PropTypes.string,
};
const SideNav = React.forwardRef((props, ref) => {
    const { 
    // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
    as: Component = 'ul', activeKey, bsPrefix, className, onSelect, alwaysOpen, activeNavLinkKey = '', ...controlledProps } = useUncontrolled(props, {
        activeKey: 'onSelect',
    });
    const prefix = useBootstrapPrefix(bsPrefix, 'sidenav');
    const contextValue = useMemo(() => ({
        activeEventKey: activeKey,
        onSelect,
        alwaysOpen,
        activeLinkKey: activeNavLinkKey,
    }), [activeKey, onSelect, alwaysOpen, activeNavLinkKey]);
    return (React.createElement(context$1.Provider, { value: contextValue },
        React.createElement(SGDSWrapper, { as: Component, ref: ref, ...controlledProps, className: classNames(className, prefix, 'list-unstyled') })));
});
SideNav.displayName = 'SideNav';
SideNav.propTypes = propTypes;
var SideNav$1 = Object.assign(SideNav, {
    Button: SideNavButton,
    Collapse: SideNavCollapse,
    Item: SideNavItem,
    Link: SideNavLink,
});

export { SideNav$1 as SideNav, SideNavButton, SideNavCollapse, SideNavItem, SideNavLink };
