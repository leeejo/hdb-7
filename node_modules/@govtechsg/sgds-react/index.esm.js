'use client';
import classNames from 'classnames';
import * as React from 'react';
import React__default, { useMemo, useContext, useRef, useCallback, useState, forwardRef, cloneElement, useEffect } from 'react';
import PropTypes from 'prop-types';
import { useUncontrolled, useUncontrolledProp } from 'uncontrollable';
import css from 'dom-helpers/css';
import Transition, { EXITED, EXITING, ENTERING, ENTERED } from 'react-transition-group/Transition';
import transitionEnd from 'dom-helpers/transitionEnd';
import useMergedRefs from '@restart/hooks/useMergedRefs';
import ReactDOM from 'react-dom';
import { elementType, componentOrElement } from 'prop-types-extra';
import useEventCallback from '@restart/hooks/useEventCallback';
import camelize from 'dom-helpers/camelize';
import Anchor from '@restart/ui/Anchor';
import { useButtonProps } from '@restart/ui/Button';
import warning from 'warning';
import { useDropdownToggle } from '@restart/ui/DropdownToggle';
import DropdownContext$1 from '@restart/ui/DropdownContext';
import 'invariant';
import BaseDropdown from '@restart/ui/Dropdown';
import { useDropdownItem } from '@restart/ui/DropdownItem';
import { useDropdownMenu } from '@restart/ui/DropdownMenu';
import useIsomorphicEffect from '@restart/hooks/useIsomorphicEffect';
import addEventListener from 'dom-helpers/addEventListener';
import canUseDOM from 'dom-helpers/canUseDOM';
import ownerDocument from 'dom-helpers/ownerDocument';
import removeEventListener from 'dom-helpers/removeEventListener';
import getScrollbarSize from 'dom-helpers/scrollbarSize';
import useCallbackRef from '@restart/hooks/useCallbackRef';
import useWillUnmount from '@restart/hooks/useWillUnmount';
import BaseModal from '@restart/ui/Modal';
import addClass from 'dom-helpers/addClass';
import qsa from 'dom-helpers/querySelectorAll';
import removeClass from 'dom-helpers/removeClass';
import ModalManager from '@restart/ui/ModalManager';
import BaseNav from '@restart/ui/Nav';
import { useNavItem } from '@restart/ui/NavItem';
import SelectableContext, { makeEventKey } from '@restart/ui/SelectableContext';
import BaseOverlay from '@restart/ui/Overlay';
import hasClass from 'dom-helpers/hasClass';
import contains from 'dom-helpers/contains';
import useTimeout from '@restart/hooks/useTimeout';
import { useCallbackRef as useCallbackRef$1 } from '@restart/hooks';
import BaseTabs from '@restart/ui/Tabs';
import TabContext from '@restart/ui/TabContext';
import { useTabPanel } from '@restart/ui/TabPanel';
import NoopTransition from '@restart/ui/NoopTransition';

const ThemeContext = React.createContext({ prefixes: {} });
const { Consumer, Provider } = ThemeContext;
function ThemeProvider({ prefixes = {}, dir, children }) {
    const contextValue = useMemo(() => ({
        prefixes: { ...prefixes },
        dir,
    }), [prefixes, dir]);
    return React.createElement(Provider, { value: contextValue }, children);
}
ThemeProvider.propTypes = {
    prefixes: PropTypes.object,
    dir: PropTypes.string,
};
function useBootstrapPrefix(prefix, defaultPrefix) {
    const { prefixes } = useContext(ThemeContext);
    return prefix || prefixes[defaultPrefix] || `${defaultPrefix}`;
}
// `sgds-${defaultPrefix}`
function useIsRTL() {
    const { dir } = useContext(ThemeContext);
    return dir === 'rtl';
}
const SGDSWrapper = React.forwardRef(({ as: Tag = 'div', ...props }, ref) => {
    return React.createElement(Tag, { ref: ref, ...props, className: classNames(props.className, 'sgds') });
});

function parseDuration(node, property) {
    const str = css(node, property) || '';
    const mult = str.indexOf('ms') === -1 ? 1000 : 1;
    return parseFloat(str) * mult;
}
function transitionEndListener(element, handler) {
    const duration = parseDuration(element, 'transitionDuration');
    const delay = parseDuration(element, 'transitionDelay');
    const remove = transitionEnd(element, (e) => {
        if (e.target === element) {
            remove();
            handler(e);
        }
    }, duration + delay);
}

/**
 * Safe chained function
 *
 * Will only create a new function if needed,
 * otherwise will pass back existing functions or null.
 *
 * @param {function} functions to chain
 * @returns {function|null}
 */
function createChainedFunction(...funcs) {
    return funcs
        .filter((f) => f != null)
        .reduce((acc, f) => {
        if (typeof f !== 'function') {
            throw new Error('Invalid Argument Type, must only provide functions, undefined, or null.');
        }
        if (acc === null)
            return f;
        return function chainedFunction(...args) {
            // @ts-ignore
            acc.apply(this, args);
            // @ts-ignore
            f.apply(this, args);
        };
    }, null);
}

// reading a dimension prop will cause the browser to recalculate,
// which will let our animations work
function triggerBrowserReflow(node) {
    // eslint-disable-next-line @typescript-eslint/no-unused-expressions
    node.offsetHeight;
}

function safeFindDOMNode(componentOrElement) {
    if (componentOrElement && 'setState' in componentOrElement) {
        return ReactDOM.findDOMNode(componentOrElement);
    }
    return (componentOrElement ?? null);
}

// Normalizes Transition callbacks when nodeRef is used.
const TransitionWrapper = React__default.forwardRef(({ onEnter, onEntering, onEntered, onExit, onExiting, onExited, addEndListener, children, childRef, ...props }, ref) => {
    const nodeRef = useRef(null);
    const mergedRef = useMergedRefs(nodeRef, childRef);
    const attachRef = (r) => {
        mergedRef(safeFindDOMNode(r));
    };
    const normalize = (callback) => (param) => {
        if (callback && nodeRef.current) {
            callback(nodeRef.current, param);
        }
    };
    /* eslint-disable react-hooks/exhaustive-deps */
    const handleEnter = useCallback(normalize(onEnter), [onEnter]);
    const handleEntering = useCallback(normalize(onEntering), [onEntering]);
    const handleEntered = useCallback(normalize(onEntered), [onEntered]);
    const handleExit = useCallback(normalize(onExit), [onExit]);
    const handleExiting = useCallback(normalize(onExiting), [onExiting]);
    const handleExited = useCallback(normalize(onExited), [onExited]);
    const handleAddEndListener = useCallback(normalize(addEndListener), [
        addEndListener,
    ]);
    /* eslint-enable react-hooks/exhaustive-deps */
    return (React__default.createElement(Transition, { ref: ref, ...props, onEnter: handleEnter, onEntered: handleEntered, onEntering: handleEntering, onExit: handleExit, onExited: handleExited, onExiting: handleExiting, addEndListener: handleAddEndListener, nodeRef: nodeRef }, typeof children === 'function'
        ? (status, innerProps) => children(status, {
            ...innerProps,
            ref: attachRef,
        })
        : React__default.cloneElement(children, {
            ref: attachRef,
        })));
});

const MARGINS = {
    height: ['marginTop', 'marginBottom'],
    width: ['marginLeft', 'marginRight'],
};
function getDefaultDimensionValue(dimension, elem) {
    const offset = `offset${dimension[0].toUpperCase()}${dimension.slice(1)}`;
    const value = elem[offset];
    const margins = MARGINS[dimension];
    return (value +
        // @ts-ignore
        parseInt(css(elem, margins[0]), 10) +
        // @ts-ignore
        parseInt(css(elem, margins[1]), 10));
}
const collapseStyles = {
    [EXITED]: 'collapse',
    [EXITING]: 'collapsing',
    [ENTERING]: 'collapsing',
    [ENTERED]: 'collapse show',
};
const propTypes$1k = {
    /**
     * Show the component; triggers the expand or collapse animation
     */
    in: PropTypes.bool,
    /**
     * Wait until the first "enter" transition to mount the component (add it to the DOM)
     */
    mountOnEnter: PropTypes.bool,
    /**
     * Unmount the component (remove it from the DOM) when it is collapsed
     */
    unmountOnExit: PropTypes.bool,
    /**
     * Run the expand animation when the component mounts, if it is initially
     * shown
     */
    appear: PropTypes.bool,
    /**
     * Duration of the collapse animation in milliseconds, to ensure that
     * finishing callbacks are fired even if the original browser transition end
     * events are canceled
     */
    timeout: PropTypes.number,
    /**
     * Callback fired before the component expands
     */
    onEnter: PropTypes.func,
    /**
     * Callback fired after the component starts to expand
     */
    onEntering: PropTypes.func,
    /**
     * Callback fired after the component has expanded
     */
    onEntered: PropTypes.func,
    /**
     * Callback fired before the component collapses
     */
    onExit: PropTypes.func,
    /**
     * Callback fired after the component starts to collapse
     */
    onExiting: PropTypes.func,
    /**
     * Callback fired after the component has collapsed
     */
    onExited: PropTypes.func,
    /**
     * The dimension used when collapsing, or a function that returns the
     * dimension
     */
    dimension: PropTypes.oneOfType([
        PropTypes.oneOf(['height', 'width']),
        PropTypes.func,
    ]),
    /**
     * Function that returns the height or width of the animating DOM node
     *
     * Allows for providing some custom logic for how much the Collapse component
     * should animate in its specified dimension. Called with the current
     * dimension prop value and the DOM node.
     *
     * @default element.offsetWidth | element.offsetHeight
     */
    getDimensionValue: PropTypes.func,
    /**
     * ARIA role of collapsible element
     */
    role: PropTypes.string,
    /**
     * You must provide a single JSX child element to this component and that element cannot be a \<React.Fragment\>
     */
    children: PropTypes.element.isRequired,
};
const defaultProps$x = {
    in: false,
    timeout: 300,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
    getDimensionValue: getDefaultDimensionValue,
};
const Collapse = React__default.forwardRef(({ onEnter, onEntering, onEntered, onExit, onExiting, className, children, dimension = 'height', getDimensionValue = getDefaultDimensionValue, ...props }, ref) => {
    /* Compute dimension */
    const computedDimension = typeof dimension === 'function' ? dimension() : dimension;
    /* -- Expanding -- */
    const handleEnter = useMemo(() => createChainedFunction((elem) => {
        elem.style[computedDimension] = '0';
    }, onEnter), [computedDimension, onEnter]);
    const handleEntering = useMemo(() => createChainedFunction((elem) => {
        const scroll = `scroll${computedDimension[0].toUpperCase()}${computedDimension.slice(1)}`;
        elem.style[computedDimension] = `${elem[scroll]}px`;
    }, onEntering), [computedDimension, onEntering]);
    const handleEntered = useMemo(() => createChainedFunction((elem) => {
        elem.style[computedDimension] = null;
    }, onEntered), [computedDimension, onEntered]);
    /* -- Collapsing -- */
    const handleExit = useMemo(() => createChainedFunction((elem) => {
        elem.style[computedDimension] = `${getDimensionValue(computedDimension, elem)}px`;
        triggerBrowserReflow(elem);
    }, onExit), [onExit, getDimensionValue, computedDimension]);
    const handleExiting = useMemo(() => createChainedFunction((elem) => {
        elem.style[computedDimension] = null;
    }, onExiting), [computedDimension, onExiting]);
    return (React__default.createElement(TransitionWrapper, { ref: ref, addEndListener: transitionEndListener, ...props, "aria-expanded": props.role ? props.in : null, onEnter: handleEnter, onEntering: handleEntering, onEntered: handleEntered, onExit: handleExit, onExiting: handleExiting, childRef: children.ref }, (state, innerProps) => React__default.cloneElement(children, {
        ...innerProps,
        className: classNames(className, children.props.className, collapseStyles[state], computedDimension === 'width' && 'collapse-horizontal'),
    })));
});
// @ts-ignore
Collapse.propTypes = propTypes$1k;
// @ts-ignore
Collapse.defaultProps = defaultProps$x;

function isAccordionItemSelected(activeEventKey, eventKey) {
    return Array.isArray(activeEventKey)
        ? activeEventKey.includes(eventKey)
        : activeEventKey === eventKey;
}
const context$8 = React.createContext({});
context$8.displayName = 'AccordionContext';

const propTypes$1j = {
    /** Set a custom element for this component */
    as: PropTypes.elementType,
    /**
     * A key that corresponds to the toggler that triggers this collapse's expand or collapse.
     */
    eventKey: PropTypes.string.isRequired,
    /** Children prop should only contain a single child, and is enforced as such */
    children: PropTypes.element.isRequired,
};
const AccordionCollapse = React.forwardRef(({ as: Component = 'div', bsPrefix, className, children, eventKey, ...props }, ref) => {
    const { activeEventKey } = useContext(context$8);
    bsPrefix = useBootstrapPrefix(bsPrefix, 'accordion-collapse');
    return (React.createElement(Collapse, { ref: ref, in: isAccordionItemSelected(activeEventKey, eventKey), ...props, className: classNames(className, bsPrefix) },
        React.createElement(Component, null, React.Children.only(children))));
});
AccordionCollapse.propTypes = propTypes$1j;
AccordionCollapse.displayName = 'AccordionCollapse';

const context$7 = React.createContext({
    eventKey: '',
});
context$7.displayName = 'AccordionItemContext';

const propTypes$1i = {
    /** Set a custom element for this component */
    as: PropTypes.elementType,
    /** @default 'accordion-body' */
    bsPrefix: PropTypes.string,
};
const AccordionBody = React.forwardRef(({ 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'div', bsPrefix, className, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'accordion-body');
    const { eventKey } = useContext(context$7);
    return (React.createElement(AccordionCollapse, { eventKey: eventKey },
        React.createElement(Component, { ref: ref, ...props, className: classNames(className, bsPrefix) })));
});
AccordionBody.propTypes = propTypes$1i;
AccordionBody.displayName = 'AccordionBody';

const propTypes$1h = {
    /** Set a custom element for this component */
    as: PropTypes.elementType,
    /** @default 'accordion-button' */
    bsPrefix: PropTypes.string,
    /** A callback function for when this component is clicked */
    onClick: PropTypes.func,
};
function useAccordionButton(eventKey, onClick) {
    const { activeEventKey, onSelect, alwaysOpen } = useContext(context$8);
    return (e) => {
        /*
          Compare the event key in context with the given event key.
          If they are the same, then collapse the component.
        */
        let eventKeyPassed = eventKey === activeEventKey ? null : eventKey;
        if (alwaysOpen) {
            if (Array.isArray(activeEventKey)) {
                if (activeEventKey.includes(eventKey)) {
                    eventKeyPassed = activeEventKey.filter((k) => k !== eventKey);
                }
                else {
                    eventKeyPassed = [...activeEventKey, eventKey];
                }
            }
            else {
                // activeEventKey is undefined.
                eventKeyPassed = [eventKey];
            }
        }
        onSelect?.(eventKeyPassed, e);
        onClick?.(e);
    };
}
const AccordionButton = React.forwardRef(({ 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'button', bsPrefix, className, onClick, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'accordion-button');
    const { eventKey } = useContext(context$7);
    const accordionOnClick = useAccordionButton(eventKey, onClick);
    const { activeEventKey } = useContext(context$8);
    if (Component === 'button') {
        props.type = 'button';
    }
    return (React.createElement(Component, { ref: ref, onClick: accordionOnClick, ...props, "aria-expanded": eventKey === activeEventKey, className: classNames(className, bsPrefix, eventKey !== activeEventKey && 'collapsed') }));
});
AccordionButton.propTypes = propTypes$1h;
AccordionButton.displayName = 'AccordionButton';

const propTypes$1g = {
    /** Set a custom element for this component */
    as: PropTypes.elementType,
    /** @default 'accordion-header' */
    bsPrefix: PropTypes.string,
    /** Click handler for the `AccordionButton` element */
    onClick: PropTypes.func,
};
const AccordionHeader = React.forwardRef(({ 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'h2', bsPrefix, className, children, onClick, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'accordion-header');
    return (React.createElement(Component, { ref: ref, ...props, className: classNames(className, bsPrefix) },
        React.createElement(AccordionButton, { onClick: onClick }, children)));
});
AccordionHeader.propTypes = propTypes$1g;
AccordionHeader.displayName = 'AccordionHeader';

const propTypes$1f = {
    /** Set a custom element for this component */
    as: PropTypes.elementType,
    /** @default 'accordion-item' */
    bsPrefix: PropTypes.string,
    /**
     * A unique key used to control this item's collapse/expand.
     * @required
     */
    eventKey: PropTypes.string.isRequired,
};
const AccordionItem = React.forwardRef(({ 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'div', bsPrefix, className, eventKey, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'accordion-item');
    const contextValue = useMemo(() => ({
        eventKey,
    }), [eventKey]);
    return (React.createElement(context$7.Provider, { value: contextValue },
        React.createElement(Component, { ref: ref, ...props, className: classNames(className, bsPrefix) })));
});
AccordionItem.propTypes = propTypes$1f;
AccordionItem.displayName = 'AccordionItem';

const propTypes$1e = {
    /** Set a custom element for this component */
    as: PropTypes.elementType,
    /** @default 'accordion' */
    bsPrefix: PropTypes.string,
    /** The current active key that corresponds to the currently expanded card */
    activeKey: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),
    /** The default active key that is expanded on start */
    defaultActiveKey: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),
    /** Renders accordion edge-to-edge with its parent container */
    flush: PropTypes.bool,
    /** Allow accordion items to stay open when another item is opened */
    alwaysOpen: PropTypes.bool,
};
const Accordion = React.forwardRef((props, ref) => {
    const { 
    // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
    as: Component = 'div', activeKey, bsPrefix, className, onSelect, flush, alwaysOpen, ...controlledProps } = useUncontrolled(props, {
        activeKey: 'onSelect',
    });
    const prefix = useBootstrapPrefix(bsPrefix, 'accordion');
    const contextValue = useMemo(() => ({
        activeEventKey: activeKey,
        onSelect,
        alwaysOpen,
    }), [activeKey, onSelect, alwaysOpen]);
    return (React.createElement(context$8.Provider, { value: contextValue },
        React.createElement(SGDSWrapper, { as: Component, ref: ref, ...controlledProps, className: classNames(className, prefix, flush && `${prefix}-flush`) })));
});
Accordion.displayName = 'Accordion';
Accordion.propTypes = propTypes$1e;
var Accordion$1 = Object.assign(Accordion, {
    Button: AccordionButton,
    Collapse: AccordionCollapse,
    Item: AccordionItem,
    Header: AccordionHeader,
    Body: AccordionBody,
});

const propTypes$1d = {
    /**
     * Show the component; triggers the fade in or fade out animation
     */
    in: PropTypes.bool,
    /**
     * Wait until the first "enter" transition to mount the component (add it to the DOM)
     */
    mountOnEnter: PropTypes.bool,
    /**
     * Unmount the component (remove it from the DOM) when it is faded out
     */
    unmountOnExit: PropTypes.bool,
    /**
     * Run the fade in animation when the component mounts, if it is initially
     * shown
     */
    appear: PropTypes.bool,
    /**
     * Duration of the fade animation in milliseconds, to ensure that finishing
     * callbacks are fired even if the original browser transition end events are
     * canceled
     */
    timeout: PropTypes.number,
    /**
     * Callback fired before the component fades in
     */
    onEnter: PropTypes.func,
    /**
     * Callback fired after the component starts to fade in
     */
    onEntering: PropTypes.func,
    /**
     * Callback fired after the has component faded in
     */
    onEntered: PropTypes.func,
    /**
     * Callback fired before the component fades out
     */
    onExit: PropTypes.func,
    /**
     * Callback fired after the component starts to fade out
     */
    onExiting: PropTypes.func,
    /**
     * Callback fired after the component has faded out
     */
    onExited: PropTypes.func,
    /**
     * You must provide a single JSX child element to this component and that element cannot be a \<React.Fragment\>
     */
    children: PropTypes.element.isRequired,
    /**
     * Applies additional specified classes during the transition. Takes an object
     * where the keys correspond to the Transition status
     */
    transitionClasses: PropTypes.object,
};
const defaultProps$w = {
    in: false,
    timeout: 300,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
};
const fadeStyles$1 = {
    [ENTERING]: 'show',
    [ENTERED]: 'show',
};
const Fade = React.forwardRef(({ className, children, transitionClasses = {}, ...props }, ref) => {
    const handleEnter = useCallback((node, isAppearing) => {
        triggerBrowserReflow(node);
        props.onEnter?.(node, isAppearing);
    }, [props]);
    return (React.createElement(TransitionWrapper, { ref: ref, addEndListener: transitionEndListener, ...props, onEnter: handleEnter, childRef: children.ref }, (status, innerProps) => React.cloneElement(children, {
        ...innerProps,
        className: classNames('fade', className, children.props.className, 
        //@ts-ignore
        fadeStyles$1[status], transitionClasses[status]),
    })));
});
Fade.propTypes = propTypes$1d;
Fade.defaultProps = defaultProps$w;
Fade.displayName = 'Fade';

const propTypes$1c = {
    'aria-label': PropTypes.string,
    onClick: PropTypes.func,
    /**
     * Render different color variant for the button.
     *
     * Omitting this will render the default dark color.
     */
    variant: PropTypes.oneOf(['white']),
};
const defaultProps$v = {
    'aria-label': 'Close',
};
const CloseButton = React.forwardRef(({ className, variant, ...props }, ref) => (React.createElement("button", { ref: ref, type: "button", className: classNames('btn-close', variant && `btn-close-${variant}`, className), ...props })));
CloseButton.displayName = 'CloseButton';
CloseButton.propTypes = propTypes$1c;
CloseButton.defaultProps = defaultProps$v;

const pascalCase = (str) => str[0].toUpperCase() + camelize(str).slice(1);
// TODO: emstricten & fix the typing here! `createWithBsPrefix<TElementType>...`
function createWithBsPrefix(prefix, { displayName = pascalCase(prefix), Component, defaultProps, propTypes } = {}) {
    const BsComponent = React.forwardRef(({ className, bsPrefix, as: Tag = Component || 'div', ...props }, ref) => {
        const resolvedPrefix = useBootstrapPrefix(bsPrefix, prefix);
        return (React.createElement(Tag, { ref: ref, className: classNames(className, resolvedPrefix), ...props }));
    });
    BsComponent.defaultProps = defaultProps;
    BsComponent.propTypes = propTypes;
    BsComponent.displayName = displayName;
    return BsComponent;
}

const AlertLink = createWithBsPrefix('alert-link', {
    Component: 'a',
});

var divWithClassName = (className) => React.forwardRef((p, ref) => (React.createElement("div", { ...p, ref: ref, className: classNames(p.className, className) })));

const DivStyledAsH4 = divWithClassName('h4');
const AlertHeading = createWithBsPrefix('alert-heading', {
    Component: DivStyledAsH4,
});

const propTypes$1b = {
    /**
     * @default 'alert'
     */
    bsPrefix: PropTypes.string,
    /**
     * The Alert visual variant
     *
     * @type {'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'light'}
     */
    variant: PropTypes.string,
    /**
     * Renders a properly aligned dismiss button, as well as
     * adding extra horizontal padding to the Alert.
     */
    dismissible: PropTypes.bool,
    /**
     * Controls the visual state of the Alert.
     *
     * @controllable onClose
     */
    show: PropTypes.bool,
    /**
     * Callback fired when alert is closed.
     *
     * @controllable show
     */
    onClose: PropTypes.func,
    /**
     * Sets the text for alert close button.
     */
    closeLabel: PropTypes.string,
    /**
     * Animate the alert dismissal. Defaults to using `<Fade>` animation or use
     * `false` to disable. A custom `react-transition-group` Transition can also
     * be provided.
     */
    transition: PropTypes.oneOfType([PropTypes.bool, elementType]),
};
const defaultProps$u = {
    variant: 'primary',
    show: true,
    transition: Fade,
    closeLabel: 'Close alert',
};
const Alert = React.forwardRef((uncontrolledProps, ref) => {
    const { bsPrefix, show, as: Component = 'div', closeLabel, className, children, variant, onClose, dismissible, transition, ...props } = useUncontrolled(uncontrolledProps, {
        show: 'onClose',
    });
    const prefix = useBootstrapPrefix(bsPrefix, 'alert');
    const handleClose = useEventCallback((e) => {
        if (onClose) {
            onClose(false, e);
        }
    });
    const Transition = transition === true ? Fade : transition;
    const alert = (React.createElement(SGDSWrapper, { as: Component, role: "alert", ...(!Transition ? props : undefined), ref: ref, className: classNames(className, prefix, variant && `${prefix}-${variant}`, dismissible && `${prefix}-dismissible`) },
        children,
        dismissible && (React.createElement(CloseButton, { onClick: handleClose, "aria-label": closeLabel, className: `btn-sm` }))));
    if (!Transition)
        return show ? alert : null;
    return (React.createElement(Transition, { unmountOnExit: true, ...props, ref: undefined, in: show }, alert));
});
Alert.displayName = 'Alert';
Alert.defaultProps = defaultProps$u;
Alert.propTypes = propTypes$1b;
var Alert$1 = Object.assign(Alert, {
    Link: AlertLink,
    Heading: AlertHeading,
});

const propTypes$1a = {
    /** @default 'badge' */
    bsPrefix: PropTypes.string,
    /**
     * The visual style of the badge
     *
     * @type {('primary'|'secondary'|'success'|'danger'|'warning'|'info'|'light'|'dark')}
     */
    bg: PropTypes.string,
    /**
     * Add the `pill` modifier to make badges more rounded with
     * some additional horizontal padding
     */
    pill: PropTypes.bool,
    /**
     * Sets badge text color
     *
     * @type {('primary'|'secondary'|'success'|'danger'|'warning'|'info'|'light'|'dark')}
     */
    text: PropTypes.string,
    /** @default span */
    as: PropTypes.elementType,
    textIndicator: PropTypes.bool,
    dotIndicator: PropTypes.bool,
};
const defaultProps$t = {
    bg: 'primary',
    pill: false,
    textIndicator: false,
    dotIndicator: false
};
const Badge = React.forwardRef(({ bsPrefix, bg, pill, text, className, textIndicator, dotIndicator, as: Component = 'span', ...props }, ref) => {
    const prefix = useBootstrapPrefix(bsPrefix, 'badge');
    return (React.createElement(SGDSWrapper, { as: Component, ref: ref, ...props, className: classNames(className, prefix, pill && `rounded-pill`, text && `text-${text}`, bg && `bg-${bg}`, (textIndicator || dotIndicator) && 'position-absolute top-0 start-100 translate-middle', dotIndicator && 'p-2 border border-light rounded-circle') },
        dotIndicator && React.createElement("span", { className: 'visually-hidden' }, "New alerts"),
        props.children));
});
Badge.displayName = 'Badge';
Badge.propTypes = propTypes$1a;
Badge.defaultProps = defaultProps$t;

const propTypes$19 = {
    /**
     * @default 'breadcrumb-item'
     */
    bsPrefix: PropTypes.string,
    /**
     * Adds a visual "active" state to a Breadcrumb
     * Item and disables the link.
     */
    active: PropTypes.bool,
    /**
     * `href` attribute for the inner `a` element
     */
    href: PropTypes.string,
    /**
     * You can use a custom element type for this component's inner link.
     */
    linkAs: PropTypes.elementType,
    /**
     * `title` attribute for the inner `a` element
     */
    title: PropTypes.node,
    /**
     * `target` attribute for the inner `a` element
     */
    target: PropTypes.string,
    /**
     * Additional props passed as-is to the underlying link for non-active items.
     */
    linkProps: PropTypes.object,
    as: PropTypes.elementType,
};
const defaultProps$s = {
    active: false,
    linkProps: {},
};
const BreadcrumbItem = React.forwardRef(({ bsPrefix, active, children, className, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'li', linkAs: LinkComponent = Anchor, linkProps, href, title, target, ...props }, ref) => {
    const prefix = useBootstrapPrefix(bsPrefix, 'breadcrumb-item');
    return (React.createElement(Component, { ref: ref, ...props, className: classNames(prefix, className, { active }), "aria-current": active ? 'page' : undefined }, active ? (children) : (React.createElement(LinkComponent, { ...linkProps, href: href, title: title, target: target }, children))));
});
BreadcrumbItem.displayName = 'BreadcrumbItem';
BreadcrumbItem.propTypes = propTypes$19;
BreadcrumbItem.defaultProps = defaultProps$s;

const propTypes$18 = {
    /**
     * @default 'breadcrumb'
     */
    bsPrefix: PropTypes.string,
    /**
     * ARIA label for the nav element
     * https://www.w3.org/TR/wai-aria-practices/#breadcrumb
     */
    ariaLabel: PropTypes.string,
    /**
     * Additional props passed as-is to the underlying `<ol>` element
     */
    listProps: PropTypes.object,
    as: PropTypes.elementType,
};
const defaultProps$r = {
    ariaLabel: 'breadcrumb',
    listProps: {},
};
const Breadcrumb = React.forwardRef(({ bsPrefix, className, listProps, children, ariaLabel, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as = 'nav', ...props }, ref) => {
    const prefix = useBootstrapPrefix(bsPrefix, 'breadcrumb');
    return (React.createElement(SGDSWrapper, { as: as, "aria-label": ariaLabel, className: className, ref: ref, ...props },
        React.createElement("ol", { ...listProps, className: classNames(prefix, listProps?.className) }, children)));
});
Breadcrumb.displayName = 'Breadcrumb';
Breadcrumb.propTypes = propTypes$18;
Breadcrumb.defaultProps = defaultProps$r;
var Breadcrumb$1 = Object.assign(Breadcrumb, {
    Item: BreadcrumbItem,
});

const propTypes$17 = {
    /**
     * @default 'btn'
     */
    bsPrefix: PropTypes.string,
    /**
     * One or more button variant combinations
     *
     * buttons may be one of a variety of visual variants such as:
     *
     * `'primary', 'secondary', 'success', 'danger', 'warning', 'info', 'dark', 'light', 'link'`
     *
     * as well as "outline" versions (prefixed by 'outline-*')
     *
     * `'outline-primary', 'outline-secondary', 'outline-success', 'outline-danger', 'outline-warning', 'outline-info', 'outline-dark', 'outline-light'`
     */
    variant: PropTypes.string,
    /**
     * Specifies a large or small button.
     *
     * @type ('sm'|'lg')
     */
    size: PropTypes.string,
    /** Manually set the visual state of the button to `:active` */
    active: PropTypes.bool,
    /**
     * Disables the Button, preventing mouse events,
     * even if the underlying component is an `<a>` element
     */
    disabled: PropTypes.bool,
    /** Providing a `href` will render an `<a>` element, _styled_ as a button. */
    href: PropTypes.string,
    /**
     * Defines HTML button type attribute.
     *
     * @default 'button'
     */
    type: PropTypes.oneOf(['button', 'reset', 'submit', null]),
    as: PropTypes.elementType,
};
const defaultProps$q = {
    variant: 'primary',
    active: false,
    disabled: false,
};
const Button = React.forwardRef(({ as, bsPrefix, variant, size, active, className, ...props }, ref) => {
    const prefix = useBootstrapPrefix(bsPrefix, 'btn');
    const [buttonProps, { tagName }] = useButtonProps({
        tagName: as,
        ...props,
    });
    const Component = tagName;
    return (React.createElement(SGDSWrapper, { as: Component, ...props, ...buttonProps, ref: ref, className: classNames(className, prefix, active && 'active', variant && `${prefix}-${variant}`, size && `${prefix}-${size}`, props.href && props.disabled && 'disabled') }));
});
Button.displayName = 'Button';
Button.propTypes = propTypes$17;
Button.defaultProps = defaultProps$q;

const propTypes$16 = {
    /**
     * @default 'btn-group'
     */
    bsPrefix: PropTypes.string,
    /**
     * Sets the size for all Buttons in the group.
     *
     * @type ('sm'|'lg')
     */
    size: PropTypes.string,
    /** Make the set of Buttons appear vertically stacked. */
    vertical: PropTypes.bool,
    /**
     * An ARIA role describing the button group. Usually the default
     * "group" role is fine. An `aria-label` or `aria-labelledby`
     * prop is also recommended.
     */
    role: PropTypes.string,
    as: PropTypes.elementType,
};
const defaultProps$p = {
    vertical: false,
    role: 'group',
};
const ButtonGroup = React.forwardRef(({ bsPrefix, size, vertical, className, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'div', ...rest }, ref) => {
    const prefix = useBootstrapPrefix(bsPrefix, 'btn-group');
    let baseClass = prefix;
    if (vertical)
        baseClass = `${prefix}-vertical`;
    return (React.createElement(Component, { ...rest, ref: ref, className: classNames(className, baseClass, size && `${prefix}-${size}`) }));
});
ButtonGroup.displayName = 'ButtonGroup';
ButtonGroup.propTypes = propTypes$16;
ButtonGroup.defaultProps = defaultProps$p;

const propTypes$15 = {
    /**
     * @default 'card-img'
     */
    bsPrefix: PropTypes.string,
    /**
     * Defines image position inside
     * the card.
     *
     * @type {('top'|'bottom')}
     */
    variant: PropTypes.oneOf(['top', 'bottom']),
    as: PropTypes.elementType,
};
const CardImg = React.forwardRef(
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
({ bsPrefix, className, variant, as: Component = 'img', ...props }, ref) => {
    const prefix = useBootstrapPrefix(bsPrefix, 'card-img');
    return (React.createElement(Component, { ref: ref, className: classNames(variant ? `${prefix}-${variant}` : prefix, className), ...props }));
});
CardImg.displayName = 'CardImg';
CardImg.propTypes = propTypes$15;

const context$6 = React.createContext(null);
context$6.displayName = 'CardHeaderContext';

const propTypes$14 = {
    /**
     * @default 'card-header'
     */
    bsPrefix: PropTypes.string,
    as: PropTypes.elementType,
};
const CardHeader = React.forwardRef(({ bsPrefix, className, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'div', ...props }, ref) => {
    const prefix = useBootstrapPrefix(bsPrefix, 'card-header');
    const contextValue = useMemo(() => ({
        cardHeaderBsPrefix: prefix,
    }), [prefix]);
    return (React.createElement(context$6.Provider, { value: contextValue },
        React.createElement(Component, { ref: ref, ...props, className: classNames(className, prefix) })));
});
CardHeader.displayName = 'CardHeader';
CardHeader.propTypes = propTypes$14;

const CardTitle = createWithBsPrefix('card-title', {
    Component: 'h3',
});
const DivStyledAsH6 = divWithClassName('h6');
const CardSubtitle = createWithBsPrefix('card-subtitle', {
    Component: DivStyledAsH6,
});
const CardLink = createWithBsPrefix('card-link', { Component: 'a' });
const CardStretchedLink = createWithBsPrefix('card-link stretched-link', {
    Component: 'a',
});
const CardText = createWithBsPrefix('card-text', { Component: 'p' });
const CardFooter = createWithBsPrefix('card-footer');
const CardImgOverlay = createWithBsPrefix('card-img-overlay');
const CardUnit = createWithBsPrefix('card-unit', { Component: 'div' });
const CardBody = createWithBsPrefix('card-body');

const propTypes$13 = {
    /**
     * @default 'card'
     */
    bsPrefix: PropTypes.string,
    /**
     * Sets card background
     *
     * @type {('primary'|'secondary'|'success'|'danger'|'warning'|'info'|'dark'|'light')}
     */
    bg: PropTypes.string,
    /**
     * Sets card text color
     *
     * @type {('primary'|'secondary'|'success'|'danger'|'warning'|'info'|'dark'|'light'|'white'|'muted')}
     */
    text: PropTypes.string,
    /**
     * Sets card border color
     *
     * @type {('primary'|'secondary'|'success'|'danger'|'warning'|'info'|'dark'|'light')}
     */
    border: PropTypes.string,
    as: PropTypes.elementType,
    variant: PropTypes.oneOf([
        'card-action',
        'card-action-quantity-toggle',
    ]),
};
const Card = React.forwardRef(({ bsPrefix, className, bg, text, border, children, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'div', ...props }, ref) => {
    const prefix = useBootstrapPrefix(bsPrefix, 'card');
    return (React.createElement(SGDSWrapper, { as: Component, ref: ref, ...props, className: classNames(className, prefix, bg && `bg-${bg}`, text && `text-${text}`, border && `border-${border}`) }, children));
});
Card.displayName = 'Card';
Card.propTypes = propTypes$13;
var Card$1 = Object.assign(Card, {
    Img: CardImg,
    Title: CardTitle,
    Subtitle: CardSubtitle,
    Body: CardBody,
    Link: CardLink,
    StretchedLink: CardStretchedLink,
    Text: CardText,
    Header: CardHeader,
    Footer: CardFooter,
    ImgOverlay: CardImgOverlay,
    Unit: CardUnit,
});

const propTypes$12 = {
    /**
     * Specify whether the feedback is for valid or invalid fields
     *
     * @type {('valid'|'invalid')}
     */
    type: PropTypes.string,
    as: PropTypes.elementType,
};
const Feedback = React.forwardRef(
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
({ as: Component = 'div', className, type = 'valid', ...props }, ref) => {
    return (React.createElement(Component, { ...props, ref: ref, className: classNames(className, `${type}-feedback`) }));
});
Feedback.displayName = 'Feedback';
Feedback.propTypes = propTypes$12;

const FormContext = React.createContext({});

const propTypes$11 = {
    /**
     * @default 'form-check-input'
     */
    bsPrefix: PropTypes.string,
    /**
     * The underlying HTML element to use when rendering the FormCheckInput.
     *
     * @type {('input'|elementType)}
     */
    as: PropTypes.elementType,
    /** A HTML id attribute, necessary for proper form accessibility. */
    id: PropTypes.string,
    /** The type of checkable. */
    type: PropTypes.oneOf(['radio', 'checkbox']).isRequired,
    /** Manually style the input as valid */
    isValid: PropTypes.bool,
    /** Manually style the input as invalid */
    isInvalid: PropTypes.bool,
};
const FormCheckInput = React.forwardRef(({ id, bsPrefix, className, type = 'checkbox', isValid = false, isInvalid = false, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'input', ...props }, ref) => {
    const { controlId } = useContext(FormContext);
    bsPrefix = useBootstrapPrefix(bsPrefix, 'form-check-input');
    return (React.createElement(Component, { ...props, ref: ref, type: type, id: id || controlId, className: classNames(className, bsPrefix, isValid && 'is-valid', isInvalid && 'is-invalid') }));
});
FormCheckInput.displayName = 'FormCheckInput';
FormCheckInput.propTypes = propTypes$11;

const propTypes$10 = {
    /**
     * @default 'form-check-label'
     */
    bsPrefix: PropTypes.string,
    /** The HTML for attribute for associating the label with an input */
    htmlFor: PropTypes.string,
};
const FormCheckLabel = React.forwardRef(({ bsPrefix, className, htmlFor, ...props }, ref) => {
    const { controlId } = useContext(FormContext);
    bsPrefix = useBootstrapPrefix(bsPrefix, 'form-check-label');
    return (React.createElement("label", { ...props, ref: ref, htmlFor: htmlFor || controlId, className: classNames(className, bsPrefix) }));
});
FormCheckLabel.displayName = 'FormCheckLabel';
FormCheckLabel.propTypes = propTypes$10;

const propTypes$$ = {
    /**
     * @default 'form-check'
     */
    bsPrefix: PropTypes.string,
    /**
     * bsPrefix override for the base switch class.
     *
     * @default 'form-switch'
     */
    bsSwitchPrefix: PropTypes.string,
    /**
     * The FormCheck `ref` will be forwarded to the underlying input element,
     * which means it will be a DOM node, when resolved.
     *
     * @type {ReactRef}
     * @alias ref
     */
    _ref: PropTypes.any,
    /**
     * The underlying HTML element to use when rendering the FormCheck.
     *
     * @type {('input'|elementType)}
     */
    as: PropTypes.elementType,
    /**
     * A HTML id attribute, necessary for proper form accessibility.
     * An id is recommended for allowing label clicks to toggle the check control.
     *
     * This is **required** when `type="switch"` due to how they are rendered.
     */
    id: PropTypes.string,
    /**
     * Groups controls horizontally with other `FormCheck`s.
     */
    inline: PropTypes.bool,
    /**
     * Disables the control.
     */
    disabled: PropTypes.bool,
    /**
     * `title` attribute for the underlying `FormCheckLabel`.
     */
    title: PropTypes.string,
    /**
     * Label for the control.
     */
    label: PropTypes.node,
    /**
     * aria-label for label element.
     */
    ariaLabel: PropTypes.string,
    /**
     * The type of checkable.
     * @type {('radio' | 'checkbox' | 'switch')}
     */
    type: PropTypes.oneOf(['radio', 'checkbox', 'switch']),
    /** Manually style the input as valid */
    isValid: PropTypes.bool,
    /** Manually style the input as invalid */
    isInvalid: PropTypes.bool,
    /** A message to display when the input is in a validation state */
    feedback: PropTypes.node,
    feedbackType: PropTypes.oneOf(['invalid', 'valid'])
};
const FormCheck = React.forwardRef(({ id, bsPrefix, bsSwitchPrefix, inline = false, disabled = false, isValid = false, isInvalid = false, feedback, feedbackType, className, style, title = '', type = 'checkbox', label, ariaLabel, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as = 'input', ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'form-check');
    bsSwitchPrefix = useBootstrapPrefix(bsSwitchPrefix, 'form-switch');
    const { controlId } = useContext(FormContext);
    const innerFormContext = useMemo(() => ({
        controlId: id || controlId,
    }), [controlId, id]);
    const input = (React.createElement(FormCheckInput, { ...props, type: type === 'switch' ? 'checkbox' : type, ref: ref, isValid: isValid, isInvalid: isInvalid, disabled: disabled, as: as }));
    return (React.createElement(FormContext.Provider, { value: innerFormContext },
        React.createElement("div", { style: style, className: classNames(className, label && bsPrefix, inline && `${bsPrefix}-inline`, type === 'switch' && bsSwitchPrefix) },
            input,
            React.createElement(FormCheckLabel, { title: title, "aria-label": ariaLabel }, label),
            feedback && React.createElement(Feedback, { type: feedbackType }, feedback))));
});
FormCheck.displayName = 'FormCheck';
FormCheck.propTypes = propTypes$$;
var FormCheck$1 = Object.assign(FormCheck, {
    Input: FormCheckInput,
    Label: FormCheckLabel,
});

const propTypes$_ = {
    /**
     * The type of checkable.
     * @type {('radio' | 'checkbox' | 'switch')}
     */
    type: PropTypes.oneOf(['radio', 'checkbox', 'switch']),
    /**
     * Disables the control.
     */
    disabled: PropTypes.bool,
    /**
     * Sets card background
     *
     * @type {('primary'|'secondary'|'success'|'danger'|'warning'|'info'|'dark'|'light')}
     */
    bg: PropTypes.string,
    /**
     * Sets card text color
     *
     * @type {('primary'|'secondary'|'success'|'danger'|'warning'|'info'|'dark'|'light'|'white'|'muted')}
     */
    text: PropTypes.string,
    /**
     * Sets card border color
     *
     * @type {('primary'|'secondary'|'success'|'danger'|'warning'|'info'|'dark'|'light')}
     */
    border: PropTypes.string,
    /** Category title of the Card */
    categoryTitle: PropTypes.node
};
const defaultProps$o = {
    disabled: false,
    type: 'checkbox',
};
const SelectableCard = ({ children, bg, text, border, categoryTitle, ...props }) => {
    const formCheckRef = React.useRef(null);
    const cardRef = React.useRef(null);
    const formCheckProps = props;
    const cardProps = { bg, text, border };
    const handleSelect = () => {
        formCheckRef?.current?.click();
    };
    return (React.createElement(Card$1, { ref: cardRef, onClick: handleSelect, tabIndex: 0, variant: "card-action", className: props.checked && !props.disabled
            ? 'is-active'
            : undefined, ...cardProps },
        React.createElement(Card$1.Body, null,
            React.createElement(Card$1.Subtitle, { as: "h6", className: "text-muted" },
                React.createElement("div", null, categoryTitle),
                React.createElement("div", { className: "card-input" },
                    React.createElement(FormCheck$1, { ref: formCheckRef, ...formCheckProps, onClick: handleSelect }))),
            children)));
};
SelectableCard.displayName = 'SelectableCard';
SelectableCard.defaultProps = defaultProps$o;
SelectableCard.propTypes = propTypes$_;

var CardGroup = createWithBsPrefix('card-group');

const DEVICE_SIZES$1 = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];
const colSize = PropTypes.oneOfType([
    PropTypes.bool,
    PropTypes.number,
    PropTypes.string,
    PropTypes.oneOf(['auto']),
]);
const stringOrNumber = PropTypes.oneOfType([
    PropTypes.number,
    PropTypes.string,
]);
const column = PropTypes.oneOfType([
    colSize,
    PropTypes.shape({
        size: colSize,
        order: stringOrNumber,
        offset: stringOrNumber,
    }),
]);
const propTypes$Z = {
    /**
     * @default 'col'
     */
    bsPrefix: PropTypes.string,
    as: PropTypes.elementType,
    /**
     * The number of columns to span on extra small devices (<576px)
     *
     * @type {(boolean|"auto"|number|{ span: boolean|"auto"|number, offset: number, order: "first"|"last"|number })}
     */
    xs: column,
    /**
     * The number of columns to span on small devices (≥576px)
     *
     * @type {(boolean|"auto"|number|{ span: boolean|"auto"|number, offset: number, order: "first"|"last"|number })}
     */
    sm: column,
    /**
     * The number of columns to span on medium devices (≥768px)
     *
     * @type {(boolean|"auto"|number|{ span: boolean|"auto"|number, offset: number, order: "first"|"last"|number })}
     */
    md: column,
    /**
     * The number of columns to span on large devices (≥992px)
     *
     * @type {(boolean|"auto"|number|{ span: boolean|"auto"|number, offset: number, order: "first"|"last"|number })}
     */
    lg: column,
    /**
     * The number of columns to span on extra large devices (≥1200px)
     *
     * @type {(boolean|"auto"|number|{ span: boolean|"auto"|number, offset: number, order: "first"|"last"|number })}
     */
    xl: column,
    /**
     * The number of columns to span on extra extra large devices (≥1400px)
     *
     * @type {(boolean|"auto"|number|{ span: boolean|"auto"|number, offset: number, order: "first"|"last"|number })}
     */
    xxl: column,
};
function useCol({ as, bsPrefix, className, ...props }) {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'col');
    const spans = [];
    const classes = [];
    DEVICE_SIZES$1.forEach((brkPoint) => {
        const propValue = props[brkPoint];
        delete props[brkPoint];
        let span;
        let offset;
        let order;
        if (typeof propValue === 'object' && propValue != null) {
            ({ span, offset, order } = propValue);
        }
        else {
            span = propValue;
        }
        const infix = brkPoint !== 'xs' ? `-${brkPoint}` : '';
        if (span)
            spans.push(span === true ? `${bsPrefix}${infix}` : `${bsPrefix}${infix}-${span}`);
        if (order != null)
            classes.push(`order${infix}-${order}`);
        if (offset != null)
            classes.push(`offset${infix}-${offset}`);
    });
    return [
        { ...props, className: classNames(className, ...spans, ...classes) },
        {
            as,
            bsPrefix,
            spans,
        },
    ];
}
const Col = React.forwardRef(
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
(props, ref) => {
    const [{ className, ...colProps }, { as: Component = 'div', bsPrefix, spans },] = useCol(props);
    return (React.createElement(Component, { ...colProps, ref: ref, className: classNames(className, !spans.length && bsPrefix) }));
});
Col.displayName = 'Col';
Col.propTypes = propTypes$Z;

const DAY_LABELS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const setTimeToNoon = (date) => {
    const newDate = new Date(date);
    newDate.setHours(12);
    newDate.setMinutes(0);
    newDate.setSeconds(0);
    newDate.setMilliseconds(0);
    return newDate;
};
const Calendar = React.forwardRef((props, ref) => {
    const handleClick = (e) => {
        const day = e.currentTarget.getAttribute('data-day');
        const displayDateClone = new Date(props.displayDate);
        const newSelectedDate = setTimeToNoon(displayDateClone);
        newSelectedDate.setDate(parseInt(day));
        props.changeDate(newSelectedDate);
    };
    /**
     * Change the time of all dates in selectedDate to noon.
     * @returns The processed selectedDate.
     */
    const getProcessedSelectedDate = () => {
        if (props.selectedDate instanceof Date) {
            return setTimeToNoon(props.selectedDate);
        }
        else if (props.selectedDate) {
            // selectedDate is of type RangeSelectionValue
            const { start, end } = props.selectedDate;
            const processedStart = start ? setTimeToNoon(start) : undefined;
            const processedEnd = end ? setTimeToNoon(end) : undefined;
            return { start: processedStart, end: processedEnd };
        }
        else {
            return undefined;
        }
    };
    /**
     * Checks if a given date is selected.
     * @param date The given date.
     * @param selectedDate The selected date or date range.
     * @returns true if the given date is selected, false if otherwise.
     */
    const isSelectedDate = (date, selectedDate) => {
        if (selectedDate instanceof Date) {
            return Date.parse(date.toISOString()) === Date.parse(selectedDate.toISOString());
        }
        let { start, end } = selectedDate;
        if (start && end) {
            // if selected end date is before selected start date --> swap
            if (new Date(start).getTime() > new Date(end).getTime()) {
                const temp = start;
                start = end;
                end = temp;
            }
            return Date.parse(date.toISOString()) >= Date.parse(start.toISOString())
                && Date.parse(date.toISOString()) <= Date.parse(end.toISOString());
        }
        else if (start) {
            return Date.parse(date.toISOString()) === Date.parse(start.toISOString());
        }
        else if (end) {
            Date.parse(date.toISOString()) === Date.parse(end.toISOString());
        }
        else {
            return false;
        }
        return false;
    };
    const currentDate = setTimeToNoon(new Date());
    const processedSelectedDate = getProcessedSelectedDate();
    const minimumDate = props.minDate
        ? setTimeToNoon(new Date(props.minDate))
        : null;
    const maximumDate = props.maxDate
        ? setTimeToNoon(new Date(props.maxDate))
        : null;
    const year = props.displayDate.getFullYear();
    const month = props.displayDate.getMonth();
    const firstDay = new Date(year, month, 1);
    const startingDay = firstDay.getDay();
    let monthLength = daysInMonth[month];
    if (month === 1) {
        if ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0) {
            monthLength = 29;
        }
    }
    const weeks = [];
    let day = 1;
    for (let i = 0; i < 9; i++) {
        const week = [];
        for (let j = 0; j <= 6; j++) {
            if (day <= monthLength && (i > 0 || j >= startingDay)) {
                let className = undefined;
                const date = new Date(year, month, day, 12, 0, 0, 0);
                const dateString = date.toISOString();
                const beforeMinDate = minimumDate &&
                    Date.parse(dateString) < Date.parse(minimumDate.toISOString());
                const afterMinDate = maximumDate &&
                    Date.parse(dateString) > Date.parse(maximumDate.toISOString());
                let clickHandler = handleClick;
                const style = {
                    cursor: 'pointer',
                    borderRadius: 0,
                };
                if (Date.parse(dateString) === Date.parse(currentDate.toISOString())) {
                    // if date is the current Date
                    className = 'text-primary';
                }
                if (beforeMinDate || afterMinDate) {
                    className = 'text-muted';
                    clickHandler = undefined;
                    style.cursor = 'default';
                }
                if (processedSelectedDate && isSelectedDate(date, processedSelectedDate)) {
                    className = 'bg-primary-100';
                }
                week.push(React.createElement("td", { key: j, "data-day": day, onClick: clickHandler, style: style, className: className }, day));
                day++;
            }
            else {
                week.push(React.createElement("td", { key: j }));
            }
        }
        weeks.push(React.createElement("tr", { key: i }, week));
        if (day > monthLength) {
            break;
        }
    }
    return (React.createElement("table", { className: "text-center", role: "grid", ref: ref },
        React.createElement("thead", null,
            React.createElement("tr", null, DAY_LABELS.map((label, index) => {
                return (React.createElement("th", { key: index, abbr: label, scope: "col" },
                    React.createElement("small", null, label.slice(0, 3))));
            }))),
        React.createElement("tbody", null, weeks)));
});

const context$5 = React.createContext({
    view: 'day',
    setView: () => { }
});
context$5.displayName = 'DatePickerContext';

const MONTH_LABELS$1 = [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December',
];
const CalendarHeader = ({ ...props }) => {
    const { view, setView } = useContext(context$5);
    const handleClickPrevious = () => {
        const newDisplayDate = new Date(props.displayDate);
        newDisplayDate.setDate(1);
        if (view === 'month') {
            newDisplayDate.setFullYear(newDisplayDate.getFullYear() - 1);
            return props.onChange(newDisplayDate);
        }
        else if (view === 'year') {
            newDisplayDate.setFullYear(newDisplayDate.getFullYear() - 10);
            return props.onChange(newDisplayDate);
        }
        else {
            newDisplayDate.setMonth(newDisplayDate.getMonth() - 1);
            return props.onChange(newDisplayDate);
        }
    };
    const handleClickNext = () => {
        const newDisplayDate = new Date(props.displayDate);
        newDisplayDate.setDate(1);
        if (view === 'month') {
            newDisplayDate.setFullYear(newDisplayDate.getFullYear() + 1);
            return props.onChange(newDisplayDate);
        }
        else if (view === 'year') {
            newDisplayDate.setFullYear(newDisplayDate.getFullYear() + 10);
            return props.onChange(newDisplayDate);
        }
        else {
            newDisplayDate.setMonth(newDisplayDate.getMonth() + 1);
            return props.onChange(newDisplayDate);
        }
    };
    const changeView = () => {
        switch (view) {
            case 'day':
                setView('month');
                break;
            case 'month':
                setView('year');
                break;
        }
    };
    const renderHeader = () => {
        if (view === 'month') {
            return `${props.displayDate.getFullYear()}`;
        }
        if (view === 'year')
            return `${props.displayDate.getFullYear() - 5} - ${props.displayDate.getFullYear() + 6}`;
        return `${MONTH_LABELS$1[props.displayDate.getMonth()]} ${props.displayDate.getFullYear()}`;
    };
    return (React.createElement("div", { className: "text-center d-flex justify-content-between" },
        React.createElement("button", { onClick: handleClickPrevious, "aria-label": `previous ${view}` },
            React.createElement("i", { className: "bi bi-chevron-left" })),
        React.createElement("button", { onClick: changeView, disabled: view === 'year', "aria-live": 'polite' }, renderHeader()),
        React.createElement("button", { onClick: handleClickNext, "aria-label": `next ${view}` },
            React.createElement("i", { className: "bi bi-chevron-right" }))));
};

const MONTH_LABELS = [
    'Jan',
    'Feb',
    'Mar',
    'Apr',
    'May',
    'Jun',
    'Jul',
    'Aug',
    'Sep',
    'Oct',
    'Nov',
    'Dec',
];
const MonthView = React.forwardRef(({ displayDate, onClickMonth, ...props }, ref) => {
    const displayMonth = MONTH_LABELS[displayDate.getMonth()];
    return (React.createElement("div", { className: "sgds monthpicker", ref: ref, ...props }, MONTH_LABELS.map((m, idx) => (React.createElement("button", { className: classNames(displayMonth === m && 'active', 'month'), key: m, onClick: () => onClickMonth(idx) }, m)))));
});

const YearView = React.forwardRef(({ displayDate, onClickYear, ...props }, ref) => {
    const displayYear = displayDate.getFullYear();
    const startLimit = displayYear - 5;
    const endLimit = displayYear + 6;
    const yearArray = [];
    for (let i = startLimit; i < endLimit + 1; i++) {
        yearArray.push(i);
    }
    return (React.createElement("div", { className: "sgds yearpicker", ref: ref, ...props }, yearArray.map((y) => (React.createElement("button", { className: classNames(displayYear === y && 'active', 'year'), key: y, onClick: () => onClickYear(y) }, y)))));
});

const context$4 = React.createContext(null);
context$4.displayName = 'InputGroupContext';

function useWrappedRefWithWarning(ref, componentName) {
    // @ts-ignore
    return ref;
}

const propTypes$Y = {
    as: PropTypes.elementType,
    icon: PropTypes.element,
};
const FormControlGroup = React.forwardRef(({ icon, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'div', bsPrefix, children, className, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'form-control-group');
    return (React.createElement(SGDSWrapper, { className: classNames(bsPrefix, className), ...props, ref: ref },
        icon &&
            React.cloneElement(icon, {
                className: classNames(icon.props.className, 'form-control-icon'),
            }),
        children));
});
FormControlGroup.displayName = 'FormControlGroup';
FormControlGroup.propTypes = propTypes$Y;

const propTypes$X = {
    /**
     * @default {'form-control'}
     */
    bsPrefix: PropTypes.string,
    /**
     * The FormControl `ref` will be forwarded to the underlying input element,
     * which means unless `as` is a composite component,
     * it will be a DOM node, when resolved.
     *
     * @type {ReactRef}
     * @alias ref
     */
    _ref: PropTypes.any,
    /**
     * Input size variants
     *
     * @type {('sm'|'lg')}
     */
    size: PropTypes.string,
    /**
     * The underlying HTML element to use when rendering the FormControl.
     *
     * @type {('input'|'textarea'|elementType)}
     */
    as: PropTypes.elementType,
    /**
     * Render the input as plain text. Generally used along side `readOnly`.
     */
    plaintext: PropTypes.bool,
    /** Make the control readonly */
    readOnly: PropTypes.bool,
    /** Make the control disabled */
    disabled: PropTypes.bool,
    /**
     * The `value` attribute of underlying input
     *
     * @controllable onChange
     * */
    value: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.arrayOf(PropTypes.string),
        PropTypes.number,
    ]),
    /** A callback fired when the `value` prop changes */
    onChange: PropTypes.func,
    /**
     * The HTML input `type`, which is only relevant if `as` is `'input'` (the default).
     */
    type: PropTypes.string,
    /**
     * Uses `controlId` from `<FormGroup>` if not explicitly specified.
     */
    id: PropTypes.string,
    /** Add "valid" validation styles to the control */
    isValid: PropTypes.bool,
    /** Add "invalid" validation styles to the control and accompanying label */
    isInvalid: PropTypes.bool,
};
const FormControl = React.forwardRef(({ bsPrefix, type, size, id, className, isValid = false, isInvalid = false, plaintext, readOnly, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'input', ...props }, ref) => {
    const { controlId } = useContext(FormContext);
    bsPrefix = useBootstrapPrefix(bsPrefix, 'form-control');
    let classes;
    if (plaintext) {
        classes = { [`${bsPrefix}-plaintext`]: true };
    }
    else {
        classes = {
            [bsPrefix]: true,
            [`${bsPrefix}-${size}`]: size,
        };
    }
    warning(controlId == null || !id, '`controlId` is ignored on `<FormControl>` when `id` is specified.');
    return (React.createElement(Component, { ...props, type: type, ref: ref, readOnly: readOnly, id: id || controlId, className: classNames(className, classes, isValid && `is-valid`, isInvalid && `is-invalid`, type === 'color' && `${bsPrefix}-color`) }));
});
FormControl.displayName = 'FormControl';
FormControl.propTypes = propTypes$X;
var FormControl$1 = Object.assign(FormControl, { Feedback, Group: FormControlGroup });

const propTypes$W = {
    /**
     * @default 'dropdown-toggle'
     */
    bsPrefix: PropTypes.string,
    /**
     * An html id attribute, necessary for assistive technologies, such as screen readers.
     * @type {string|number}
     */
    id: PropTypes.string,
    split: PropTypes.bool,
    as: PropTypes.elementType,
    /**
     * to passthrough to the underlying button or whatever from DropdownButton
     * @private
     */
    childBsPrefix: PropTypes.string,
    setIsMenuOpen: PropTypes.func
};
const FormControlToggle = React.forwardRef(({ bsPrefix, className, childBsPrefix, setIsMenuOpen, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = FormControl$1, ...props }, ref) => {
    const prefix = 'dropdown-toggle';
    const dropdownContext = useContext(DropdownContext$1);
    const isInputGroup = useContext(context$4);
    if (childBsPrefix !== undefined) {
        props.bsPrefix = childBsPrefix;
    }
    const [toggleProps] = useDropdownToggle();
    toggleProps.ref = useMergedRefs(toggleProps.ref, useWrappedRefWithWarning(ref));
    const { "aria-expanded": ariaExpanded, id, ...newToggleProps } = toggleProps;
    if (setIsMenuOpen) {
        React.useEffect(() => {
            setIsMenuOpen(dropdownContext?.show);
        }, [dropdownContext?.show]);
    }
    // This intentionally forwards size and variant (if set) to the
    // underlying component, to allow it to render size and style variants.
    return (React.createElement(Component, { className: classNames(className, prefix, !!isInputGroup && dropdownContext?.show && 'show'), ...newToggleProps, ...props }));
});
FormControlToggle.displayName = 'FormToggle';
FormControlToggle.propTypes = propTypes$W;

const DropdownContext = React.createContext({});
DropdownContext.displayName = 'DropdownContext';

const propTypes$V = {
    /** @default 'dropdown-item' */
    bsPrefix: PropTypes.string,
    /**
     * Highlight the menu item as active.
     */
    active: PropTypes.bool,
    /**
     * Disable the menu item, making it unselectable.
     */
    disabled: PropTypes.bool,
    /**
     * Value passed to the `onSelect` handler, useful for identifying the selected menu item.
     */
    eventKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    /**
     * HTML `href` attribute corresponding to `a.href`.
     */
    href: PropTypes.string,
    /**
     * Callback fired when the menu item is clicked.
     */
    onClick: PropTypes.func,
    as: PropTypes.elementType,
};
const DropdownItem = React.forwardRef(({ bsPrefix, className, eventKey, disabled = false, onClick, active, as: Component = Anchor, ...props }, ref) => {
    const prefix = 'dropdown-item';
    const [dropdownItemProps, meta] = useDropdownItem({
        key: eventKey,
        href: props.href,
        disabled,
        onClick,
        active,
    });
    return (React.createElement("li", null,
        React.createElement(Component, { ...props, ...dropdownItemProps, ref: ref, className: classNames(className, prefix, meta.isActive && 'active', disabled && 'disabled') })));
});
DropdownItem.displayName = 'DropdownItem';
DropdownItem.propTypes = propTypes$V;

const context$3 = React.createContext(null);
context$3.displayName = 'NavbarContext';

const alignDirection = PropTypes.oneOf(['start', 'end']);
const alignPropType = PropTypes.oneOfType([
    alignDirection,
    PropTypes.shape({ sm: alignDirection }),
    PropTypes.shape({ md: alignDirection }),
    PropTypes.shape({ lg: alignDirection }),
    PropTypes.shape({ xl: alignDirection }),
    PropTypes.shape({ xxl: alignDirection }),
]);

const propTypes$U = {
    /**
     * @default 'dropdown-menu'
     */
    bsPrefix: PropTypes.string,
    /** Controls the visibility of the Dropdown menu  */
    show: PropTypes.bool,
    /** Whether to render the dropdown menu in the DOM before the first time it is shown */
    renderOnMount: PropTypes.bool,
    /** Have the dropdown switch to it's opposite placement when necessary to stay on screen. */
    flip: PropTypes.bool,
    /**
     * Aligns the dropdown menu to the specified side of the container. You can also align
     * the menu responsively for breakpoints starting at `sm` and up. The alignment
     * direction will affect the specified breakpoint or larger.
     *
     * *Note: Using responsive alignment will disable Popper usage for positioning.*
     *
     * @type {"start"|"end"|{ sm: "start"|"end" }|{ md: "start"|"end" }|{ lg: "start"|"end" }|{ xl: "start"|"end"}|{ xxl: "start"|"end"} }
     */
    align: alignPropType,
    onSelect: PropTypes.func,
    /**
     * Which event when fired outside the component will cause it to be closed
     *
     * *Note: For custom dropdown components, you will have to pass the
     * `rootCloseEvent` to `<RootCloseWrapper>` in your custom dropdown menu
     * component ([similarly to how it is implemented in `<Dropdown.Menu>`](https://github.com/react-bootstrap/react-bootstrap/blob/v0.31.5/src/DropdownMenu.js#L115-L119)).*
     */
    rootCloseEvent: PropTypes.oneOf(['click', 'mousedown']),
    /**
     * Control the rendering of the DropdownMenu. All non-menu props
     * (listed here) are passed through to the `as` Component.
     *
     * If providing a custom, non DOM, component. the `show`, `close` and `align` props
     * are also injected and should be handled appropriately.
     */
    as: PropTypes.elementType,
    /**
     * A set of popper options and props passed directly to Popper.
     */
    popperConfig: PropTypes.object,
    /**
     * Menu color variant.
     *
     * Omitting this will use the default light color.
     */
    variant: PropTypes.string,
    /** @private Provides context when used in NavDropdown component  */
    isNav: PropTypes.bool,
};
const defaultProps$n = {
    flip: true,
};
function getDropdownMenuPlacement(alignEnd, dropDirection, isRTL) {
    const topStart = isRTL ? 'top-end' : 'top-start';
    const topEnd = isRTL ? 'top-start' : 'top-end';
    const bottomStart = isRTL ? 'bottom-end' : 'bottom-start';
    const bottomEnd = isRTL ? 'bottom-start' : 'bottom-end';
    // const leftStart = isRTL ? 'right-start' : 'left-start';
    // const leftEnd = isRTL ? 'right-end' : 'left-end';
    const rightStart = isRTL ? 'left-start' : 'right-start';
    const rightEnd = isRTL ? 'left-end' : 'right-end';
    let placement = alignEnd ? bottomEnd : bottomStart;
    if (dropDirection === 'up')
        placement = alignEnd ? topEnd : topStart;
    else if (dropDirection === 'end')
        placement = alignEnd ? rightEnd : rightStart;
    // else if (dropDirection === 'start')
    //   placement = alignEnd ? leftEnd : leftStart;
    return placement;
}
const DropdownMenu = React.forwardRef(({ bsPrefix, className, align, rootCloseEvent, flip, show: showProps, renderOnMount, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'ul', popperConfig, variant, isNav, ...props }, ref) => {
    let alignEnd = false;
    const isNavbar = useContext(context$3);
    const prefix = 'dropdown-menu';
    const { align: contextAlign, drop, isRTL } = useContext(DropdownContext);
    align = align || contextAlign;
    const isInputGroup = useContext(context$4);
    const alignClasses = [];
    if (align) {
        if (typeof align === 'object') {
            const keys = Object.keys(align);
            warning(keys.length === 1, 'There should only be 1 breakpoint when passing an object to `align`');
            if (keys.length) {
                const brkPoint = keys[0];
                const direction = align[brkPoint];
                // .dropdown-menu-end is required for responsively aligning
                // left in addition to align left classes.
                alignEnd = direction === 'start';
                alignClasses.push(`${prefix}-${brkPoint}-${direction}`);
            }
        }
        else if (align === 'end') {
            alignEnd = true;
        }
    }
    const placement = getDropdownMenuPlacement(alignEnd, drop, isRTL);
    const [menuProps, { hasShown, popper, show, toggle }] = useDropdownMenu({
        flip,
        rootCloseEvent,
        show: showProps,
        usePopper: !isNavbar && alignClasses.length === 0,
        offset: !isNav ? [0, 10] : undefined,
        popperConfig,
        placement,
    });
    menuProps.ref = useMergedRefs(useWrappedRefWithWarning(ref), menuProps.ref);
    useIsomorphicEffect(() => {
        // Popper's initial position for the menu is incorrect when
        // renderOnMount=true. Need to call update() to correct it.
        if (show)
            popper?.update();
    }, [show]);
    if (!hasShown && !renderOnMount && !isInputGroup)
        return null;
    // For custom components provide additional, non-DOM, props;
    if (typeof Component !== 'string') {
        menuProps.show = show;
        menuProps.close = () => toggle?.(false);
        menuProps.align = align;
    }
    let style = props.style;
    if (popper?.placement) {
        // we don't need the default popper style,
        // menus are display: none when not shown.
        style = { ...props.style, ...menuProps.style };
        //@ts-ignore
        props['x-placement'] = popper.placement;
    }
    return (React.createElement(Component, { ...props, ...menuProps, style: style, ...((alignClasses.length || isNavbar) && {
            'data-bs-popper': 'static',
        }), className: classNames(className, prefix, show && 'show', alignEnd && `${prefix}-end`, variant && `${prefix}-${variant}`, ...alignClasses) }));
});
DropdownMenu.displayName = 'DropdownMenu';
DropdownMenu.propTypes = propTypes$U;
DropdownMenu.defaultProps = defaultProps$n;

const propTypes$T = {
    /**
     * @default 'dropdown-toggle'
     */
    bsPrefix: PropTypes.string,
    /**
     * An html id attribute, necessary for assistive technologies, such as screen readers.
     * @type {string|number}
     */
    id: PropTypes.string,
    split: PropTypes.bool,
    as: PropTypes.elementType,
    /**
     * to passthrough to the underlying button or whatever from DropdownButton
     * @private
     */
    childBsPrefix: PropTypes.string,
};
const DropdownToggle = React.forwardRef(({ bsPrefix, split, className, childBsPrefix, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = Button, ...props }, ref) => {
    const prefix = 'dropdown-toggle';
    const dropdownContext = useContext(DropdownContext$1);
    const isInputGroup = useContext(context$4);
    if (childBsPrefix !== undefined) {
        props.bsPrefix = childBsPrefix;
    }
    const [toggleProps] = useDropdownToggle();
    toggleProps.ref = useMergedRefs(toggleProps.ref, useWrappedRefWithWarning(ref));
    // This intentionally forwards size and variant (if set) to the
    // underlying component, to allow it to render size and style variants.
    return (React.createElement(Component, { className: classNames(className, prefix, split && `${prefix}-split`, !!isInputGroup && dropdownContext?.show && 'show'), variant: "outline-secondary", ...toggleProps, ...props, "aria-haspopup": "menu" }));
});
DropdownToggle.displayName = 'DropdownToggle';
DropdownToggle.propTypes = propTypes$T;

const DropdownHeader = createWithBsPrefix('dropdown-header', {
    defaultProps: { role: 'heading' },
});
const DropdownDivider = createWithBsPrefix('dropdown-divider', {
    Component: 'hr',
    defaultProps: { role: 'separator' },
});
const DropdownItemText = createWithBsPrefix('dropdown-item-text', {
    Component: 'span',
});

const propTypes$S = {
    /** @default 'dropdown' */
    bsPrefix: PropTypes.string,
    /**
     * Determines the direction and location of the Menu in relation to it's Toggle.
     *
     * @type {"end"|"up"|"down" }
     */
    drop: PropTypes.oneOf(['up', 'end', 'down']),
    as: PropTypes.elementType,
    align: alignDirection,
    /**
     * Whether or not the Dropdown is visible.
     *
     * @controllable onToggle
     */
    show: PropTypes.bool,
    /**
     * Allow Dropdown to flip in case of an overlapping on the reference element. For more information refer to
     * Popper.js's flip [docs](https://popper.js.org/docs/v2/modifiers/flip/).
     *
     */
    flip: PropTypes.bool,
    /**
     * A callback fired when the Dropdown wishes to change visibility. Called with the requested
     * `show` value, the DOM event, and the source that fired it: `'click'`,`'keydown'`,`'rootClose'`, or `'select'`.
     *
     * ```js
     * function(
     *   isOpen: boolean,
     *   event: SyntheticEvent,
     *   metadata: {
     *     source: 'select' | 'click' | 'rootClose' | 'keydown'
     *   }
     * ): void
     * ```
     *
     * @controllable show
     */
    onToggle: PropTypes.func,
    /**
     * A callback fired when a menu item is selected.
     *
     * ```js
     * (eventKey: any, event: Object) => any
     * ```
     */
    onSelect: PropTypes.func,
    /**
     * Controls the focus behavior for when the Dropdown is opened. Set to
     * `true` to always focus the first menu item, `keyboard` to focus only when
     * navigating via the keyboard, or `false` to disable completely
     *
     * The Default behavior is `false` **unless** the Menu has a `role="menu"`
     * where it will default to `keyboard` to match the recommended [ARIA Authoring practices](https://www.w3.org/TR/wai-aria-practices-1.1/#menubutton).
     */
    focusFirstItemOnShow: PropTypes.oneOf([false, true, 'keyboard']),
    /** @private */
    navbar: PropTypes.bool,
    /**
     * Controls the auto close behaviour of the dropdown when clicking outside of
     * the button or the list.
     */
    autoClose: PropTypes.oneOf([true, 'outside', 'inside', false]),
};
const defaultProps$m = {
    navbar: false,
    align: 'start',
    autoClose: true,
    focusFirstItemOnShow: 'keyboard',
};
const Dropdown = React.forwardRef((pProps, ref) => {
    const { bsPrefix, drop, show, className, align, onSelect, onToggle, focusFirstItemOnShow, 
    // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
    as: Component = 'div', navbar: _4, autoClose, ...props } = useUncontrolled(pProps, { show: 'onToggle' });
    const isInputGroup = useContext(context$4);
    const prefix = useBootstrapPrefix(bsPrefix, 'dropdown');
    const isRTL = useIsRTL();
    const isClosingPermitted = (source) => {
        // autoClose=false only permits close on button click
        if (autoClose === false)
            return source === 'click';
        // autoClose=inside doesn't permit close on rootClose
        if (autoClose === 'inside')
            return source !== 'rootClose';
        // autoClose=outside doesn't permit close on select
        if (autoClose === 'outside')
            return source !== 'select';
        return true;
    };
    const handleToggle = useEventCallback((nextShow, meta) => {
        if (meta.originalEvent.currentTarget === document &&
            (meta.source !== 'keydown' ||
                meta.originalEvent.key === 'Escape'))
            meta.source = 'rootClose';
        if (isClosingPermitted(meta.source))
            onToggle?.(nextShow, meta);
    });
    const alignEnd = align === 'end';
    const placement = getDropdownMenuPlacement(alignEnd, drop, isRTL);
    const contextValue = useMemo(() => ({
        align,
        drop,
        isRTL,
    }), [align, drop, isRTL]);
    return (React.createElement(DropdownContext.Provider, { value: contextValue },
        React.createElement(BaseDropdown, { placement: placement, show: show, onSelect: onSelect, onToggle: handleToggle, focusFirstItemOnShow: focusFirstItemOnShow, itemSelector: `.${prefix}-item:not(.disabled):not(:disabled)` }, isInputGroup ? (props.children) : (React.createElement(SGDSWrapper, { as: Component, ...props, ref: ref, className: classNames(className, show && 'show', prefix, drop === 'up' && 'dropup', drop === 'end' && 'dropend') })))));
});
Dropdown.displayName = 'Dropdown';
Dropdown.propTypes = propTypes$S;
Dropdown.defaultProps = defaultProps$m;
var Dropdown$1 = Object.assign(Dropdown, {
    Toggle: DropdownToggle,
    Menu: DropdownMenu,
    Item: DropdownItem,
    ItemText: DropdownItemText,
    Divider: DropdownDivider,
    Header: DropdownHeader,
});

const propTypes$R = {
    /**
     * An html id attribute for the Toggle button, necessary for assistive technologies, such as screen readers.
     * @type {string}
     */
    id: PropTypes.string,
    /** An `href` passed to the Toggle component */
    href: PropTypes.string,
    /** An `onClick` handler passed to the Toggle component */
    onClick: PropTypes.func,
    /** The content of the non-toggle Button.  */
    title: PropTypes.node.isRequired,
    /** Disables both Buttons  */
    disabled: PropTypes.bool,
    /**
     * Aligns the dropdown menu.
     *
     * _see [DropdownMenu](#dropdown-menu-props) for more details_
     *
     * @type {"start"|"end"|{ sm: "start"|"end" }|{ md: "start"|"end" }|{ lg: "start"|"end" }|{ xl: "start"|"end"}|{ xxl: "start"|"end"} }
     */
    align: alignPropType,
    /** An ARIA accessible role applied to the Menu component. When set to 'menu', The dropdown */
    menuRole: PropTypes.string,
    /** Whether to render the dropdown menu in the DOM before the first time it is shown */
    renderMenuOnMount: PropTypes.bool,
    /**
     *  Which event when fired outside the component will cause it to be closed.
     *
     * _see [DropdownMenu](#dropdown-menu-props) for more details_
     */
    rootCloseEvent: PropTypes.string,
    /**
     * Menu color variant.
     *
     * Omitting this will use the default light color.
     */
    menuVariant: PropTypes.oneOf(['dark']),
    /** @ignore */
    bsPrefix: PropTypes.string,
    /** @ignore */
    variant: PropTypes.string,
    /** @ignore */
    size: PropTypes.string,
};
/**
 * A convenience component for simple or general use dropdowns. Renders a `Button` toggle and all `children`
 * are passed directly to the default `Dropdown.Menu`. This component accepts all of
 * [`Dropdown`'s props](#dropdown-props).
 *
 * _All unknown props are passed through to the `Dropdown` component._ Only
 * the Button `variant`, `size` and `bsPrefix` props are passed to the toggle,
 * along with menu-related props are passed to the `Dropdown.Menu`
 */
const DropdownButton = React.forwardRef(({ title, children, bsPrefix, rootCloseEvent, variant, size, menuRole, renderMenuOnMount, disabled, href, id, menuVariant, ...props }, ref) => (React.createElement(Dropdown$1, { ref: ref, ...props },
    React.createElement(DropdownToggle, { id: id, href: href, size: size, variant: variant, disabled: disabled, childBsPrefix: bsPrefix },
        title,
        React.createElement("i", { className: "bi bi-chevron-down" })),
    React.createElement(DropdownMenu, { role: menuRole, renderOnMount: renderMenuOnMount, rootCloseEvent: rootCloseEvent, variant: menuVariant }, children))));
DropdownButton.displayName = 'DropdownButton';
DropdownButton.propTypes = propTypes$R;

function generateId (componentName = "", elementName = "") {
    return `id-${Math.random().toString().substring(2, 6)}-sgds-${componentName}-${elementName}`;
}

const propTypes$Q = {
    initialValue: PropTypes.oneOfType([
        PropTypes.instanceOf(Date),
        PropTypes.shape({
            start: PropTypes.instanceOf(Date),
            end: PropTypes.instanceOf(Date),
        }),
    ]),
    required: PropTypes.bool,
    className: PropTypes.string,
    minDate: PropTypes.string,
    maxDate: PropTypes.string,
    displayDate: PropTypes.instanceOf(Date),
    placeholder: PropTypes.string,
    onChangeDate: PropTypes.func,
    onClear: PropTypes.func,
    onBlur: PropTypes.func,
    onFocus: PropTypes.func,
    autoFocus: PropTypes.bool,
    disabled: PropTypes.bool,
    calendarPlacement: PropTypes.oneOf(['up', 'down']),
    /**
     * dateFormat variants
     *
     * @type {('MM/DD/YYYY'|'DD/MM/YYYY'|'YYYY/MM/DD')}
     */
    dateFormat: PropTypes.string,
    id: PropTypes.string,
    /**
     * mode variants
     *
     * @type {('single'|'range')}
     */
    mode: PropTypes.string,
    flip: PropTypes.bool,
    clearBtnVariant: PropTypes.string
};
const SEPARATOR = '/';
const makeInputValueString = (date, dateFormat) => {
    if (date === undefined)
        return '';
    const month = date.getMonth() + 1;
    const day = date.getDate();
    //this method is executed during intialState setup... handle a missing state properly
    const separator = SEPARATOR;
    if (dateFormat.match(/MM.DD.YYYY/)) {
        return ((month > 9 ? month : `0${month}`) +
            separator +
            (day > 9 ? day : `0${day}`) +
            separator +
            date.getFullYear());
    }
    else if (dateFormat.match(/DD.MM.YYYY/)) {
        return ((day > 9 ? day : `0${day}`) +
            separator +
            (month > 9 ? month : `0${month}`) +
            separator +
            date.getFullYear());
    }
    else {
        return (date.getFullYear() +
            separator +
            (month > 9 ? month : `0${month}`) +
            separator +
            (day > 9 ? day : `0${day}`));
    }
};
const defaultProps$l = {
    dateFormat: 'DD/MM/YYYY',
    calendarPlacement: 'down',
    mode: 'single',
    displayDate: new Date(),
    flip: true,
};
const DatePicker = React.forwardRef(({ dateFormat = 'DD/MM/YYYY', calendarPlacement = 'down', mode = 'single', displayDate = new Date(), flip = true, clearBtnVariant = "primary", ...props }, ref) => {
    const isRange = mode === 'range';
    const formControlRef = useRef(null);
    const inputRef = useMergedRefs(ref, formControlRef);
    const initialState = {
        displayDate: displayDate,
        selectedDate: props.initialValue && ((isRange && !(props.initialValue instanceof Date))
            || (!isRange && props.initialValue instanceof Date))
            ? props.initialValue
            : (isRange ? { start: undefined, end: undefined } : undefined),
        invalid: false,
    };
    const [state, setState] = useState(initialState);
    const [view, setView] = useState('day');
    const contextValue = useMemo(() => ({
        view,
        setView,
    }), [view]);
    const onChangeMonth = (newDisplayDate) => {
        setState({ ...state, displayDate: newDisplayDate });
    };
    const clear = () => {
        setState({
            ...initialState,
            selectedDate: isRange ? { start: undefined, end: undefined } : undefined,
            displayDate: new Date(),
        });
        props.onClear?.();
        props.onChangeDate?.(undefined);
    };
    //triggered only when clicking dates
    const onChangeDateSingle = (newSelectedDate) => {
        setState({
            ...state,
            selectedDate: newSelectedDate,
            displayDate: newSelectedDate,
        });
        formControlRef?.current?.click();
        props.onChangeDate?.(newSelectedDate);
    };
    const onChangeDateRange = (newSelectedDate) => {
        let { start, end } = state.selectedDate;
        if ((!start && !end) || (start && end)) {
            // Selecting start date
            start = newSelectedDate;
            end = undefined;
        }
        else if (start && !end) {
            // Selecting end date
            // if selected end date is before selected start date --> swap
            if (new Date(start).getTime() > newSelectedDate.getTime()) {
                end = start;
                start = newSelectedDate;
            }
            else {
                end = newSelectedDate;
            }
        }
        const newSelectedDates = { start: start, end: end };
        setState({
            ...state,
            selectedDate: newSelectedDates,
            displayDate: newSelectedDate,
        });
        if (newSelectedDates.end) {
            formControlRef?.current?.click();
        }
        props.onChangeDate?.(newSelectedDates);
    };
    const calendarHeader = (React.createElement(CalendarHeader, { displayDate: state.displayDate, onChange: onChangeMonth }));
    const computeInputValue = () => {
        if (isRange && state.selectedDate) {
            const { start, end } = state.selectedDate;
            const separator = start ? ' - ' : '';
            return (makeInputValueString(start, dateFormat) +
                separator +
                makeInputValueString(end, dateFormat));
        }
        return makeInputValueString(state.selectedDate, dateFormat);
    };
    const defaultPlaceHolder = isRange
        ? `${dateFormat.toLowerCase()} - ${dateFormat.toLowerCase()}`
        : `${dateFormat.toLowerCase()}`;
    const controlProps = {
        value: computeInputValue(),
        required: props.required,
        placeholder: props.placeholder || defaultPlaceHolder,
        ref: inputRef,
        disabled: props.disabled,
        readOnly: true,
        className: props.className,
        isInvalid: state.invalid,
        id: props.id,
    };
    const BodyContent = () => {
        const onClickMonth = (month) => {
            const newDisplayDate = new Date(state.displayDate);
            newDisplayDate.setMonth(month);
            setView('day');
            setState({
                ...state,
                displayDate: newDisplayDate,
            });
        };
        const onClickYear = (year) => {
            const newDisplayDate = new Date(state.displayDate);
            newDisplayDate.setFullYear(year);
            setView('month');
            setState({
                ...state,
                displayDate: newDisplayDate,
            });
        };
        if (view === 'month')
            return (React.createElement(MonthView, { onClickMonth: onClickMonth, displayDate: state.displayDate }));
        if (view === 'year')
            return (React.createElement(YearView, { displayDate: state.displayDate, onClickYear: onClickYear }));
        return (React.createElement(Calendar, { selectedDate: state.selectedDate, displayDate: state.displayDate, changeDate: isRange ? onChangeDateRange : onChangeDateSingle, minDate: props.minDate, maxDate: props.maxDate, mode: mode }));
    };
    const warningCondition = () => {
        const displayDateStr = makeInputValueString(displayDate, dateFormat);
        if (isRange) {
            const { start, end } = props.initialValue;
            return (makeInputValueString(start, dateFormat) === displayDateStr ||
                makeInputValueString(end, dateFormat) === displayDateStr);
        }
        else {
            const initialValue = props.initialValue;
            return (makeInputValueString(initialValue, dateFormat) === displayDateStr);
        }
    };
    if (props.initialValue) {
        warning(warningCondition(), 'In DatePicker `single` mode, `initialValue` is `Date` type and `displayDate` prop must be of same value. In range mode, `initialValue` should be of object {start: Date, end: Date} and `displayDate` prop must be of same value as either `start` or `end`');
        if (isRange) {
            const { start, end } = props.initialValue;
            start &&
                end &&
                warning(start.getTime() <= end.getTime(), '`end` Date cannot be earlier than `start` Date');
        }
    }
    // Generation of unique id soley on client side 
    const [datepickerMenuId, setDatepickerMenuId] = useState("");
    React.useEffect(() => {
        setDatepickerMenuId(generateId('datepicker', 'ul'));
    }, []);
    return (React.createElement(context$5.Provider, { value: contextValue },
        React.createElement(Dropdown$1, { drop: calendarPlacement, className: "form-control-group input-group" },
            React.createElement(FormControlToggle, { ...controlProps, ref: formControlRef, role: "combobox", "aria-haspopup": "dialog", "aria-controls": datepickerMenuId, "aria-label": "Choose Date" }),
            React.createElement(Button, { onClick: clear, disabled: props.disabled, variant: clearBtnVariant, "aria-label": "Clear Selection" },
                React.createElement("i", { className: "bi bi-x" }),
                React.createElement("span", { className: "visually-hidden" }, "clear")),
            React.createElement("i", { className: "bi bi-calendar form-control-icon" }),
            React.createElement(Dropdown$1.Menu, { id: datepickerMenuId, className: "sgds datepicker", as: 'div', role: "dialog", "aria-modal": "true", "aria-label": "Choose Date" },
                React.createElement(Dropdown$1.Header, { className: "datepicker-header", role: "none" }, calendarHeader),
                React.createElement("div", { className: "datepicker-body" }, BodyContent())))));
});
DatePicker.displayName = 'DatePicker';
DatePicker.propTypes = propTypes$Q;
DatePicker.defaultProps = defaultProps$l;

const propTypes$P = {
    as: PropTypes.elementType,
    /**
     * Sets `id` on `<FormControl>` and `htmlFor` on `<FormGroup.Label>`.
     */
    controlId: PropTypes.string,
    /**
     * The FormGroup `ref` will be forwarded to the underlying element.
     * Unless the FormGroup is rendered `as` a composite component,
     * it will be a DOM node, when resolved.
     *
     * @type {ReactRef}
     * @alias ref
     */
    _ref: PropTypes.any,
};
const FormGroup = React.forwardRef(({ controlId, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'div', ...props }, ref) => {
    const context = useMemo(() => ({ controlId }), [controlId]);
    return (React.createElement(FormContext.Provider, { value: context },
        React.createElement(Component, { ...props, ref: ref })));
});
FormGroup.displayName = 'FormGroup';
FormGroup.propTypes = propTypes$P;

const propTypes$O = {
    /**
     * @default 'form-label'
     */
    bsPrefix: PropTypes.string,
    /**
     * Uses `controlId` from `<FormGroup>` if not explicitly specified.
     */
    htmlFor: PropTypes.string,
    /**
     * Renders the FormLabel as a `<Col>` component (accepting all the same props),
     * as well as adding additional styling for horizontal forms.
     */
    column: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['sm', 'lg'])]),
    /**
     * The FormLabel `ref` will be forwarded to the underlying element.
     * Unless the FormLabel is rendered `as` a composite component,
     * it will be a DOM node, when resolved.
     *
     * @type {ReactRef}
     * @alias ref
     */
    _ref: PropTypes.any,
    /**
     * Hides the label visually while still allowing it to be
     * read by assistive technologies.
     */
    visuallyHidden: PropTypes.bool,
    /** Set a custom element for this component */
    as: PropTypes.elementType,
};
const defaultProps$k = {
    column: false,
    visuallyHidden: false,
};
const FormLabel = React.forwardRef(({ 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'label', bsPrefix, column, visuallyHidden, className, htmlFor, ...props }, ref) => {
    const { controlId } = useContext(FormContext);
    bsPrefix = useBootstrapPrefix(bsPrefix, 'form-label');
    let columnClass = 'col-form-label';
    if (typeof column === 'string')
        columnClass = `${columnClass} ${columnClass}-${column}`;
    const classes = classNames(className, bsPrefix, visuallyHidden && 'visually-hidden', column && columnClass);
    warning(controlId == null || !htmlFor, '`controlId` is ignored on `<FormLabel>` when `htmlFor` is specified.');
    htmlFor = htmlFor || controlId;
    if (column)
        return (React.createElement(Col, { ref: ref, as: "label", className: classes, htmlFor: htmlFor, ...props }));
    return (
    // eslint-disable-next-line jsx-a11y/label-has-for, jsx-a11y/label-has-associated-control
    React.createElement(Component, { ref: ref, className: classes, htmlFor: htmlFor, ...props }));
});
FormLabel.displayName = 'FormLabel';
FormLabel.propTypes = propTypes$O;
FormLabel.defaultProps = defaultProps$k;

const propTypes$N = {
    /**
     * @default {'form-select'}
     */
    bsPrefix: PropTypes.string,
    /**
     * Size variants
     *
     * @type {('sm'|'lg')}
     */
    size: PropTypes.string,
    /** Make the control disabled */
    disabled: PropTypes.bool,
    /**
     * The `value` attribute of underlying input
     *
     * @controllable onChange
     * */
    value: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.arrayOf(PropTypes.string),
        PropTypes.number,
    ]),
    /** A callback fired when the `value` prop changes */
    onChange: PropTypes.func,
    /** Add "valid" validation styles to the control */
    isValid: PropTypes.bool,
    /** Add "invalid" validation styles to the control and accompanying label */
    isInvalid: PropTypes.bool,
};
const FormSelect = React.forwardRef(({ bsPrefix, size, className, isValid = false, isInvalid = false, id, ...props }, ref) => {
    const { controlId } = useContext(FormContext);
    bsPrefix = useBootstrapPrefix(bsPrefix, 'form-select');
    return (React.createElement("select", { ...props, ref: ref, className: classNames(className, bsPrefix, size && `${bsPrefix}-${size}`, isValid && `is-valid`, isInvalid && `is-invalid`), id: id || controlId }));
});
FormSelect.displayName = 'FormSelect';
FormSelect.propTypes = propTypes$N;

const propTypes$M = {
    /** @default 'form-text' */
    bsPrefix: PropTypes.string,
    /**
     * The FormText `ref` will be forwarded to the underlying element.
     * Unless the FormText is rendered `as` a composite component,
     * it will be a DOM node, when resolved.
     *
     * @type {ReactRef}
     * @alias ref
     */
    _ref: PropTypes.any,
    /**
     * A convenience prop for add the `text-muted` class,
     * since it's so commonly used here.
     */
    muted: PropTypes.bool,
    as: PropTypes.elementType,
};
const FormText = React.forwardRef(
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
({ bsPrefix, className, as: Component = 'small', muted, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'form-text');
    return (React.createElement(Component, { ...props, ref: ref, className: classNames(className, bsPrefix, muted && 'text-muted') }));
});
FormText.displayName = 'FormText';
FormText.propTypes = propTypes$M;

const Switch = React.forwardRef((props, ref) => (React.createElement(FormCheck$1, { ...props, ref: ref, type: "switch" })));
Switch.displayName = 'Switch';
var Switch$1 = Object.assign(Switch, {
    Input: FormCheck$1.Input,
    Label: FormCheck$1.Label,
});

const propTypes$L = {
    /**
     * The Form `ref` will be forwarded to the underlying element,
     * which means, unless it's rendered `as` a composite component,
     * it will be a DOM node, when resolved.
     *
     * @type {ReactRef}
     * @alias ref
     */
    _ref: PropTypes.any,
    /**
     * Mark a form as having been validated. Setting it to `true` will
     * toggle any validation styles on the forms elements.
     */
    validated: PropTypes.bool,
    as: PropTypes.elementType,
};
const Form = React.forwardRef(({ className, validated, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'form', ...props }, ref) => (React.createElement(Component, { ...props, ref: ref, className: classNames(className, validated && 'was-validated') })));
Form.displayName = 'Form';
Form.propTypes = propTypes$L;
var Form$1 = Object.assign(Form, {
    Group: FormGroup,
    Control: FormControl$1,
    Check: FormCheck$1,
    Switch: Switch$1,
    Label: FormLabel,
    Text: FormText,
    // Range: FormRange,
    Select: FormSelect,
});

const propTypes$K = {
    /**
     * One or more button variant combinations
     *
     * buttons may be one of a variety of visual variants such as:
     *
     * `'primary', 'secondary', 'success', 'danger', 'warning', 'info', 'dark', 'light', 'link'`
     *
     * as well as "outline" versions (prefixed by 'outline-*')
     *
     * `'outline-primary', 'outline-secondary', 'outline-success', 'outline-danger', 'outline-warning', 'outline-info', 'outline-dark', 'outline-light'`
     */
    variant: PropTypes.string,
    /**
     * Specifies a large or small button.
     *
     * @type ('sm'|'lg')
     */
    size: PropTypes.oneOf(['sm', 'lg']),
    /**
     * Disables the Button, preventing mouse events,
     * even if the underlying component is an `<a>` element
     */
    disabled: PropTypes.bool,
    controlId: PropTypes.string.isRequired,
    onChangeFile: PropTypes.func.isRequired,
    selectedFile: PropTypes.oneOfType([PropTypes.object]),
    checkedIcon: PropTypes.element,
    cancelIcon: PropTypes.element,
    multiple: PropTypes.bool,
    accept: PropTypes.string,
    buttonClassName: PropTypes.string,
};
const CHECKED_ICON = React.createElement("i", { className: "bi bi-check-lg check-icon" });
const CANCEL_ICON = React.createElement("i", { className: "bi bi-x-circle x-circle-icon" });
// const defaultProps = {
//   variant: 'primary',
//   disabled: false,
//   checkedIcon: CHECKED_ICON,
//   cancelIcon: CANCEL_ICON,
//   multiple: false,
// };
const FileUpload = ({ controlId, variant = "primary", onChangeFile, selectedFile, disabled = false, size, children, checkedIcon = CHECKED_ICON, cancelIcon = CANCEL_ICON, multiple = false, accept, buttonClassName }) => {
    const inputRef = useRef(null);
    const fileNames = selectedFile ? Object.entries(selectedFile).map((e) => e[1].name) : [];
    const inputOnChangeHandler = (e) => {
        let fileList = e.target.files;
        //instead if using event object, instantiate a new dataTransfer obj to standardize with removeFile() data obj
        var dt = new DataTransfer();
        for (let i = 0; i < fileList.length; i++) {
            dt.items.add(fileList[i]);
        }
        onChangeFile(dt.files);
    };
    const handleUpload = () => {
        inputRef?.current?.click();
    };
    const removeFileHandler = (index, e) => {
        e.preventDefault();
        const attachments = document.getElementById(controlId).files; // <-- reference your file input here
        let fileBuffer = new DataTransfer();
        // append the file list to an array iteratively
        for (let i = 0; i < attachments.length; i++) {
            // Exclude file in specified index
            if (index !== i)
                fileBuffer.items.add(attachments[i]);
        }
        // Assign buffer to file input
        document.getElementById(controlId).files =
            fileBuffer.files; // <-- according to your file input reference
        onChangeFile(fileBuffer.files);
    };
    const listItems = fileNames.map((item, index) => {
        return (React.createElement("li", { key: index, className: "fileupload-list-item" },
            React.cloneElement(checkedIcon, {
                className: classNames(checkedIcon.props.className, 'me-2'),
            }),
            React.createElement("span", { id: item?.split(' ').join(''), className: "filename" }, item),
            React.createElement("button", { onClick: (e) => removeFileHandler(index, e), "aria-label": "remove file", "aria-describedby": item?.split(' ').join(''), className: "bg-transparent border-0 ms-2" }, React.cloneElement(cancelIcon, {
                className: classNames(cancelIcon.props.className),
            }))));
    });
    return (React.createElement(React.Fragment, null,
        React.createElement(Form$1.Group, { controlId: controlId },
            React.createElement(Form$1.Control, { onChange: inputOnChangeHandler, ref: inputRef, type: "file", multiple: multiple, className: "d-none", accept: accept }),
            React.createElement(Button, { onClick: handleUpload, size: size, variant: variant, disabled: disabled, className: buttonClassName }, children)),
        React.createElement(SGDSWrapper, { as: "ul", className: "fileupload-list" }, listItems)));
};
FileUpload.displayName = 'FileUpload';
FileUpload.propTypes = propTypes$K;
// FileUpload.defaultProps = defaultProps;

const propTypes$J = {
    as: PropTypes.elementType,
    bsPrefix: PropTypes.string,
};
const FooterBottomCopyrights = React.forwardRef(({ as: Component = 'div', children, className, bsPrefix, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'footer-copyrights');
    return (React.createElement(Component, { ref: ref, className: classNames(className, bsPrefix, 'row'), ...props },
        React.createElement("div", { className: "col" },
            React.createElement("div", { className: "d-flex justify-content-lg-end" }, children))));
});
FooterBottomCopyrights.propTypes = propTypes$J;
FooterBottomCopyrights.displayName = 'FooterBottomCopyrights';

const propTypes$I = {
    as: PropTypes.elementType,
    bsPrefix: PropTypes.string
};
const FooterBottomLinks = React.forwardRef(({ as: Component = 'div', children, className, bsPrefix, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'footer-mandatory-links');
    return (React.createElement(Component, { ref: ref, className: classNames(className, bsPrefix, 'row'), ...props },
        React.createElement("div", { className: "col" },
            React.createElement("ul", null, React.Children.map(children, (child) => (React.createElement("li", null, React.cloneElement(child))))))));
});
FooterBottomLinks.propTypes = propTypes$I;
FooterBottomLinks.displayName = 'FooterBottomLinks';

const FooterBottom = React.forwardRef(({ as: Component = 'section', children, bsPrefix, className, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'footer-bottom');
    return (React.createElement(Component, { ref: ref, className: classNames(className, bsPrefix), ...props },
        React.createElement("div", { className: "container-fluid" }, children)));
});
var FooterBottom$1 = Object.assign(FooterBottom, {
    Links: FooterBottomLinks,
    Copyrights: FooterBottomCopyrights
});

const FooterTopContactLinks = React.forwardRef(({ as: Component = 'div', children, bsPrefix, className, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'footer-contact-links');
    return (React.createElement(Component, { className: classNames(bsPrefix, 'row', className), ref: ref, ...props },
        React.createElement("div", { className: "col" },
            React.createElement("div", { className: "d-flex justify-content-lg-end" },
                React.createElement("ul", null,
                    " ",
                    React.Children.map(children, (child) => (React.createElement("li", null, React.cloneElement(child)))))))));
});

const propTypes$H = {
    headerTitle: PropTypes.node,
    titleClass: PropTypes.string,
    descriptionClass: PropTypes.string,
    columnClass: PropTypes.string,
    as: PropTypes.elementType,
    bsPrefix: PropTypes.string
};
const defaultProps$j = {
    columnClass: 'col-lg-6',
};
const FooterTopHeader = forwardRef(({ as: Component = 'div', headerTitle, children, bsPrefix, className, titleClass, descriptionClass, columnClass = 'col-lg-6', ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'footer-header');
    return (React.createElement(Component, { className: classNames(bsPrefix, className, 'row'), ref: ref, ...props },
        React.createElement("div", { className: classNames('col', columnClass) },
            React.createElement("div", { className: classNames('title', titleClass) }, headerTitle),
            React.createElement("div", { className: classNames('description', descriptionClass) }, children))));
});
FooterTopHeader.defaultProps = defaultProps$j;
FooterTopHeader.propTypes = propTypes$H;
FooterTopHeader.displayName = 'FooterTopHeader';

const context$2 = React.createContext({
    noOfItem: 0
});
context$2.displayName = 'FooterTopItemGrpContext';

const propTypes$G = {
    itemTitle: PropTypes.node,
    titleClass: PropTypes.string,
    linksClass: PropTypes.string,
    as: PropTypes.elementType,
};
const FooterTopItem = React.forwardRef(({ as: Component = 'div', itemTitle, children, className, titleClass, linksClass, ...props }, ref) => {
    const { noOfItem } = React.useContext(context$2);
    const colSize = noOfItem < 5 ? 'col-lg-3' : 'col-lg-2';
    return (React.createElement(Component, { className: classNames(colSize, className), ref: ref, ...props },
        React.createElement("div", { className: classNames('title', titleClass) }, itemTitle),
        React.createElement("ul", { className: classNames('links', linksClass) }, React.Children.map(children, (child) => (React.createElement("li", null, React.cloneElement(child)))))));
});
FooterTopItem.displayName = 'FooterTopItem';
FooterTopItem.propTypes = propTypes$G;

const propTypes$F = {
    as: PropTypes.elementType,
    bsPrefix: PropTypes.string,
};
const FooterTopItemGroup = React.forwardRef(({ as: Component = 'div', children, className, bsPrefix, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'footer-items');
    const noOfChildren = React.Children.count(children);
    const contextValue = React.useMemo(() => ({ noOfItem: noOfChildren }), [noOfChildren]);
    warning(noOfChildren <= 6, 'Number of Footer Items should not exceed 6');
    return (React.createElement(context$2.Provider, { value: contextValue },
        React.createElement(Component, { className: classNames(bsPrefix, className, 'row'), ref: ref, ...props }, children)));
});
FooterTopItemGroup.displayName = 'FooterTopItemGroup';
FooterTopItemGroup.propTypes = propTypes$F;

const FooterTop = React.forwardRef(({ as: Component = 'section', children, className, bsPrefix, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'footer-top');
    return (React.createElement(Component, { ref: ref, className: classNames(bsPrefix, className), ...props },
        React.createElement("div", { className: "container-fluid" }, children)));
});
var FooterSection = Object.assign(FooterTop, {
    Header: FooterTopHeader,
    ItemGroup: FooterTopItemGroup,
    Item: FooterTopItem,
    ContactLinks: FooterTopContactLinks,
});

const propTypes$E = {
    as: PropTypes.elementType,
    bsPrefix: PropTypes.string,
};
const Footer = React.forwardRef(({ as: Component = 'footer', bsPrefix, className, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'footer');
    return (React.createElement(SGDSWrapper, { as: Component, ref: ref, className: classNames(className, bsPrefix), ...props }));
});
Footer.displayName = 'Footer';
Footer.propTypes = propTypes$E;
var Footer$1 = Object.assign(Footer, {
    Top: FooterSection,
    Bottom: FooterBottom$1,
});

const containerSizes = PropTypes.oneOfType([
    PropTypes.bool,
    PropTypes.oneOf(['sm', 'md', 'lg', 'xl', 'xxl']),
]);
const propTypes$D = {
    /**
     * @default 'container'
     */
    bsPrefix: PropTypes.string,
    /**
     * Allow the Container to fill all of its available horizontal space.
     * @type {(true|"sm"|"md"|"lg"|"xl"|"xxl")}
     */
    fluid: containerSizes,
    /**
     * You can use a custom element for this component
     */
    as: PropTypes.elementType,
};
const defaultProps$i = {
    fluid: false,
};
const Container = React.forwardRef(({ bsPrefix, fluid, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'div', className, ...props }, ref) => {
    const prefix = useBootstrapPrefix(bsPrefix, 'container');
    const suffix = typeof fluid === 'string' ? `-${fluid}` : '-fluid';
    return (React.createElement(Component, { ref: ref, ...props, className: classNames(className, fluid ? `${prefix}${suffix}` : prefix) }));
});
Container.displayName = 'Container';
Container.propTypes = propTypes$D;
Container.defaultProps = defaultProps$i;

const InputGroupText = createWithBsPrefix('input-group-text', {
    Component: 'span',
});

const InputGroupCheckbox = (props) => (React.createElement(InputGroupText, null,
    React.createElement(FormCheckInput, { type: "checkbox", ...props })));
const InputGroupRadio = (props) => (React.createElement(InputGroupText, null,
    React.createElement(FormCheckInput, { type: "radio", ...props })));

const propTypes$C = {
    /** @default 'input-group' */
    bsPrefix: PropTypes.string,
    /**
     * Control the size of buttons and form elements from the top-level.
     *
     * @type {('sm'|'lg')}
     */
    size: PropTypes.string,
    /**
     * Handles the input's rounded corners when using form validation.
     *
     * Use this when your input group contains both an input and feedback element.
     */
    hasValidation: PropTypes.bool,
    as: PropTypes.elementType,
    variant: PropTypes.oneOf(['quantity-toggle'])
};
/**
 *
 * @property {InputGroupText} Text
 * @property {InputGroupRadio} Radio
 * @property {InputGroupCheckbox} Checkbox
 */
const InputGroup = React.forwardRef(({ bsPrefix, size, hasValidation, className, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'div', ...InputGroupProps }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'input-group');
    // Intentionally an empty object. Used in detecting if a dropdown
    // exists under an input group.
    const contextValue = useMemo(() => ({}), []);
    return (React.createElement(context$4.Provider, { value: contextValue },
        React.createElement(SGDSWrapper, { as: Component, ref: ref, ...InputGroupProps, className: classNames(className, bsPrefix, size && `${bsPrefix}-${size}`, hasValidation && 'has-validation') })));
});
InputGroup.propTypes = propTypes$C;
InputGroup.displayName = 'InputGroup';
var InputGroup$1 = Object.assign(InputGroup, {
    Text: InputGroupText,
    Radio: InputGroupRadio,
    Checkbox: InputGroupCheckbox,
});

const Selector = {
    FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',
    STICKY_CONTENT: '.sticky-top',
    NAVBAR_TOGGLER: '.navbar-toggler',
};
class BootstrapModalManager extends ModalManager {
    adjustAndStore(prop, element, adjust) {
        const actual = element.style[prop];
        // TODO: DOMStringMap and CSSStyleDeclaration aren't strictly compatible
        // @ts-ignore
        element.dataset[prop] = actual;
        css(element, {
            [prop]: `${parseFloat(css(element, prop)) + adjust}px`,
        });
    }
    restore(prop, element) {
        const value = element.dataset[prop];
        if (value !== undefined) {
            delete element.dataset[prop];
            css(element, { [prop]: value });
        }
    }
    setContainerStyle(containerState) {
        super.setContainerStyle(containerState);
        const container = this.getElement();
        addClass(container, 'modal-open');
        if (!containerState.scrollBarWidth)
            return;
        const paddingProp = this.isRTL ? 'paddingLeft' : 'paddingRight';
        const marginProp = this.isRTL ? 'marginLeft' : 'marginRight';
        qsa(container, Selector.FIXED_CONTENT).forEach((el) => this.adjustAndStore(paddingProp, el, containerState.scrollBarWidth));
        qsa(container, Selector.STICKY_CONTENT).forEach((el) => this.adjustAndStore(marginProp, el, -containerState.scrollBarWidth));
        qsa(container, Selector.NAVBAR_TOGGLER).forEach((el) => this.adjustAndStore(marginProp, el, containerState.scrollBarWidth));
    }
    removeContainerStyle(containerState) {
        super.removeContainerStyle(containerState);
        const container = this.getElement();
        removeClass(container, 'modal-open');
        const paddingProp = this.isRTL ? 'paddingLeft' : 'paddingRight';
        const marginProp = this.isRTL ? 'marginLeft' : 'marginRight';
        qsa(container, Selector.FIXED_CONTENT).forEach((el) => this.restore(paddingProp, el));
        qsa(container, Selector.STICKY_CONTENT).forEach((el) => this.restore(marginProp, el));
        qsa(container, Selector.NAVBAR_TOGGLER).forEach((el) => this.restore(marginProp, el));
    }
}
let sharedManager;
function getSharedManager(options) {
    if (!sharedManager)
        sharedManager = new BootstrapModalManager(options);
    return sharedManager;
}

const ModalBody = createWithBsPrefix('modal-body');

const ModalContext = React.createContext({
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    onHide() { },
});

const propTypes$B = {
    /** @default 'modal' */
    bsPrefix: PropTypes.string,
    contentClassName: PropTypes.string,
    /**
     * Render a large, extra large or small modal.
     *
     * @type ('sm'|'lg','xl')
     */
    size: PropTypes.string,
    /**
     * Renders a fullscreen modal. Specifying a breakpoint will render the modal
     * as fullscreen __below__ the breakpoint size.
     *
     * @type (true|'sm-down'|'md-down'|'lg-down'|'xl-down'|'xxl-down')
     */
    fullscreen: PropTypes.oneOfType([PropTypes.bool, PropTypes.string]),
    /**
     * Specify whether the Component should be vertically centered
     */
    centered: PropTypes.bool,
    /**
     * Allows scrolling the `<Modal.Body>` instead of the entire Modal when overflowing.
     */
    scrollable: PropTypes.bool,
};
const ModalDialog = React.forwardRef(({ bsPrefix, className, contentClassName, centered, size, fullscreen, children, scrollable, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'modal');
    const dialogClass = `${bsPrefix}-dialog`;
    const fullScreenClass = typeof fullscreen === 'string'
        ? `${bsPrefix}-fullscreen-${fullscreen}`
        : `${bsPrefix}-fullscreen`;
    return (React.createElement("div", { ...props, ref: ref, className: classNames(dialogClass, className, size && `${bsPrefix}-${size}`, centered && `${dialogClass}-centered`, scrollable && `${dialogClass}-scrollable`, fullscreen && fullScreenClass) },
        React.createElement("div", { className: classNames(`${bsPrefix}-content`, contentClassName) }, children)));
});
ModalDialog.displayName = 'ModalDialog';
ModalDialog.propTypes = propTypes$B;

const ModalFooter = createWithBsPrefix('modal-footer');

const propTypes$A = {
    /**
     * Provides an accessible label for the close
     * button. It is used for Assistive Technology when the label text is not
     * readable.
     */
    closeLabel: PropTypes.string,
    /**
     * Sets the variant for close button.
     */
    closeVariant: PropTypes.oneOf(['white']),
    /**
     * Specify whether the Component should contain a close button
     */
    closeButton: PropTypes.bool,
    /**
     * A Callback fired when the close button is clicked. If used directly inside
     * a ModalContext, the onHide will automatically be propagated up
     * to the parent `onHide`.
     */
    onHide: PropTypes.func,
};
const defaultProps$h = {
    closeLabel: 'Close',
    closeButton: false,
};
const AbstractModalHeader = React.forwardRef(({ closeLabel, closeVariant, closeButton, onHide, children, ...props }, ref) => {
    const context = useContext(ModalContext);
    const handleClick = useEventCallback(() => {
        context?.onHide();
        onHide?.();
    });
    return (React.createElement("div", { ref: ref, ...props },
        children,
        closeButton && (React.createElement(CloseButton, { "aria-label": closeLabel, variant: closeVariant, onClick: handleClick }))));
});
AbstractModalHeader.propTypes = propTypes$A;
AbstractModalHeader.defaultProps = defaultProps$h;

const propTypes$z = {
    /**
     * @default 'modal-header'
     */
    bsPrefix: PropTypes.string,
    /**
     * Provides an accessible label for the close
     * button. It is used for Assistive Technology when the label text is not
     * readable.
     */
    closeLabel: PropTypes.string,
    /**
     * Sets the variant for close button.
     */
    closeVariant: PropTypes.oneOf(['white']),
    /**
     * Specify whether the Component should contain a close button
     */
    closeButton: PropTypes.bool,
    /**
     * A Callback fired when the close button is clicked. If used directly inside
     * a Modal component, the onHide will automatically be propagated up to the
     * parent Modal `onHide`.
     */
    onHide: PropTypes.func,
};
const defaultProps$g = {
    closeLabel: 'Close',
    closeButton: false,
};
const ModalHeader = React.forwardRef(({ bsPrefix, className, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'modal-header');
    return (React.createElement(AbstractModalHeader, { ref: ref, ...props, className: classNames(className, bsPrefix) }));
});
ModalHeader.displayName = 'ModalHeader';
ModalHeader.propTypes = propTypes$z;
ModalHeader.defaultProps = defaultProps$g;

const ModalTitle = createWithBsPrefix('modal-title', {
    Component: 'h3',
});

const propTypes$y = {
    /**
     * @default 'modal'
     */
    bsPrefix: PropTypes.string,
    /**
     * Render a large, extra large or small modal.
     * When not provided, the modal is rendered with medium (default) size.
     * @type ('sm'|'lg'|'xl')
     */
    size: PropTypes.string,
    /**
     * Renders a fullscreen modal. Specifying a breakpoint will render the modal
     * as fullscreen __below__ the breakpoint size.
     *
     * @type (true|'sm-down'|'md-down'|'lg-down'|'xl-down'|'xxl-down')
     */
    fullscreen: PropTypes.oneOfType([PropTypes.bool, PropTypes.string]),
    /**
     * vertically center the Dialog in the window
     */
    centered: PropTypes.bool,
    /**
     * Include a backdrop component. Specify 'static' for a backdrop that doesn't
     * trigger an "onHide" when clicked.
     */
    backdrop: PropTypes.oneOf(['static', true, false]),
    /**
     * Add an optional extra class name to .modal-backdrop
     * It could end up looking like class="modal-backdrop foo-modal-backdrop in".
     */
    backdropClassName: PropTypes.string,
    /**
     * Close the modal when escape key is pressed
     */
    keyboard: PropTypes.bool,
    /**
     * Allows scrolling the `<Modal.Body>` instead of the entire Modal when overflowing.
     */
    scrollable: PropTypes.bool,
    /**
     * Open and close the Modal with a slide and fade animation.
     */
    animation: PropTypes.bool,
    /**
     * A css class to apply to the Modal dialog DOM node.
     */
    dialogClassName: PropTypes.string,
    /**
     * Add an optional extra class name to .modal-content
     */
    contentClassName: PropTypes.string,
    /**
     * A Component type that provides the modal content Markup. This is a useful
     * prop when you want to use your own styles and markup to create a custom
     * modal component.
     */
    dialogAs: PropTypes.elementType,
    /**
     * When `true` The modal will automatically shift focus to itself when it
     * opens, and replace it to the last focused element when it closes.
     * Generally this should never be set to false as it makes the Modal less
     * accessible to assistive technologies, like screen-readers.
     */
    autoFocus: PropTypes.bool,
    /**
     * When `true` The modal will prevent focus from leaving the Modal while
     * open. Consider leaving the default value here, as it is necessary to make
     * the Modal work well with assistive technologies, such as screen readers.
     */
    enforceFocus: PropTypes.bool,
    /**
     * When `true` The modal will restore focus to previously focused element once
     * modal is hidden
     */
    restoreFocus: PropTypes.bool,
    /**
     * Options passed to focus function when `restoreFocus` is set to `true`
     *
     * @link  https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus#Parameters
     */
    restoreFocusOptions: PropTypes.shape({
        preventScroll: PropTypes.bool,
    }),
    /**
     * When `true` The modal will show itself.
     */
    show: PropTypes.bool,
    /**
     * A callback fired when the Modal is opening.
     */
    onShow: PropTypes.func,
    /**
     * A callback fired when the header closeButton or non-static backdrop is
     * clicked. Required if either are specified.
     */
    onHide: PropTypes.func,
    /**
     * A callback fired when the escape key, if specified in `keyboard`, is pressed.
     */
    onEscapeKeyDown: PropTypes.func,
    /**
     * Callback fired before the Modal transitions in
     */
    onEnter: PropTypes.func,
    /**
     * Callback fired as the Modal begins to transition in
     */
    onEntering: PropTypes.func,
    /**
     * Callback fired after the Modal finishes transitioning in
     */
    onEntered: PropTypes.func,
    /**
     * Callback fired right before the Modal transitions out
     */
    onExit: PropTypes.func,
    /**
     * Callback fired as the Modal begins to transition out
     */
    onExiting: PropTypes.func,
    /**
     * Callback fired after the Modal finishes transitioning out
     */
    onExited: PropTypes.func,
    /**
     * A ModalManager instance used to track and manage the state of open
     * Modals. Useful when customizing how modals interact within a container
     */
    manager: PropTypes.object,
    /**
     * @private
     */
    container: PropTypes.any,
    'aria-labelledby': PropTypes.string,
    'aria-describedby': PropTypes.string,
    'aria-label': PropTypes.string,
    /**
     * Conveys centered align style to Modal
     */
    centeredAlignVariant: PropTypes.bool,
};
const defaultProps$f = {
    show: false,
    backdrop: true,
    keyboard: true,
    autoFocus: true,
    enforceFocus: true,
    restoreFocus: true,
    animation: true,
    dialogAs: ModalDialog,
    centeredAlignVariant: false,
};
function DialogTransition(props) {
    return React.createElement(Fade, { ...props, timeout: null });
}
function BackdropTransition(props) {
    return React.createElement(Fade, { ...props, timeout: null });
}
/* eslint-enable no-use-before-define */
const Modal = React.forwardRef(({ bsPrefix, className, style, dialogClassName, contentClassName, children, dialogAs: Dialog = ModalDialog, 'aria-labelledby': ariaLabelledby, 'aria-describedby': ariaDescribedby, 'aria-label': ariaLabel, centeredAlignVariant, 
/* BaseModal props */
show, animation, backdrop, keyboard, onEscapeKeyDown, onShow, onHide, container, autoFocus, enforceFocus, restoreFocus, restoreFocusOptions, onEntered, onExit, onExiting, onEnter, onEntering, onExited, backdropClassName, manager: propsManager, ...props }, ref) => {
    const [modalStyle, setStyle] = useState({});
    const [animateStaticModal, setAnimateStaticModal] = useState(false);
    const waitingForMouseUpRef = useRef(false);
    const ignoreBackdropClickRef = useRef(false);
    const removeStaticModalAnimationRef = useRef(null);
    const [modal, setModalRef] = useCallbackRef();
    const mergedRef = useMergedRefs(ref, setModalRef);
    const handleHide = useEventCallback(onHide);
    const isRTL = useIsRTL();
    bsPrefix = useBootstrapPrefix(bsPrefix, 'modal');
    const modalContext = useMemo(() => ({
        onHide: handleHide,
    }), [handleHide]);
    function getModalManager() {
        if (propsManager)
            return propsManager;
        return getSharedManager({ isRTL });
    }
    function updateDialogStyle(node) {
        if (!canUseDOM)
            return;
        const containerIsOverflowing = getModalManager().getScrollbarWidth() > 0;
        const modalIsOverflowing = node.scrollHeight >
            ownerDocument(node).documentElement.clientHeight;
        setStyle({
            paddingRight: containerIsOverflowing && !modalIsOverflowing
                ? getScrollbarSize()
                : undefined,
            paddingLeft: !containerIsOverflowing && modalIsOverflowing
                ? getScrollbarSize()
                : undefined,
        });
    }
    const handleWindowResize = useEventCallback(() => {
        if (modal) {
            updateDialogStyle(modal.dialog);
        }
    });
    useWillUnmount(() => {
        removeEventListener(window, 'resize', handleWindowResize);
        removeStaticModalAnimationRef.current?.();
    });
    // We prevent the modal from closing during a drag by detecting where the
    // the click originates from. If it starts in the modal and then ends outside
    // don't close.
    const handleDialogMouseDown = () => {
        waitingForMouseUpRef.current = true;
    };
    const handleMouseUp = (e) => {
        if (waitingForMouseUpRef.current &&
            modal &&
            e.target === modal.dialog) {
            ignoreBackdropClickRef.current = true;
        }
        waitingForMouseUpRef.current = false;
    };
    const handleStaticModalAnimation = () => {
        setAnimateStaticModal(true);
        removeStaticModalAnimationRef.current = transitionEnd(modal.dialog, () => {
            setAnimateStaticModal(false);
        });
    };
    const handleStaticBackdropClick = (e) => {
        if (e.target !== e.currentTarget) {
            return;
        }
        handleStaticModalAnimation();
    };
    const handleClick = (e) => {
        if (backdrop === 'static') {
            handleStaticBackdropClick(e);
            return;
        }
        if (ignoreBackdropClickRef.current || e.target !== e.currentTarget) {
            ignoreBackdropClickRef.current = false;
            return;
        }
        onHide?.();
    };
    const handleEscapeKeyDown = (e) => {
        if (!keyboard && backdrop === 'static') {
            // Call preventDefault to stop modal from closing in restart ui,
            // then play our animation.
            e.preventDefault();
            handleStaticModalAnimation();
        }
        else if (keyboard && onEscapeKeyDown) {
            onEscapeKeyDown(e);
        }
    };
    const handleEnter = (node, isAppearing) => {
        if (node) {
            node.style.display = 'block';
            updateDialogStyle(node);
        }
        onEnter?.(node, isAppearing);
    };
    const handleExit = (node) => {
        removeStaticModalAnimationRef.current?.();
        onExit?.(node);
    };
    const handleEntering = (node, isAppearing) => {
        onEntering?.(node, isAppearing);
        // FIXME: This should work even when animation is disabled.
        addEventListener(window, 'resize', handleWindowResize);
    };
    const handleExited = (node) => {
        if (node)
            node.style.display = ''; // RHL removes it sometimes
        onExited?.(node);
        // FIXME: This should work even when animation is disabled.
        removeEventListener(window, 'resize', handleWindowResize);
    };
    const renderBackdrop = useCallback((backdropProps) => (React.createElement("div", { ...backdropProps, className: classNames(`${bsPrefix}-backdrop`, backdropClassName, !animation && 'show') })), [animation, backdropClassName, bsPrefix]);
    const baseModalStyle = { ...style, ...modalStyle };
    // Sets `display` always block when `animation` is false
    if (!animation) {
        baseModalStyle.display = 'block';
    }
    const renderDialog = (dialogProps) => (React.createElement(SGDSWrapper, { role: "dialog", ...dialogProps, style: baseModalStyle, className: classNames(className, bsPrefix, animateStaticModal && `${bsPrefix}-static`), onClick: backdrop ? handleClick : undefined, onMouseUp: handleMouseUp, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby, "aria-describedby": ariaDescribedby, variant: centeredAlignVariant ? 'centered-align-icon' : undefined },
        React.createElement(Dialog, { ...props, onMouseDown: handleDialogMouseDown, className: dialogClassName, contentClassName: contentClassName }, children)));
    return (React.createElement(ModalContext.Provider, { value: modalContext },
        React.createElement(BaseModal, { show: show, ref: mergedRef, backdrop: backdrop, container: container, keyboard // Always set true - see handleEscapeKeyDown
            : true, autoFocus: autoFocus, enforceFocus: enforceFocus, restoreFocus: restoreFocus, restoreFocusOptions: restoreFocusOptions, onEscapeKeyDown: handleEscapeKeyDown, onShow: onShow, onHide: onHide, onEnter: handleEnter, onEntering: handleEntering, onEntered: onEntered, onExit: handleExit, onExiting: onExiting, onExited: handleExited, manager: getModalManager(), transition: animation
                ? DialogTransition
                : undefined, backdropTransition: animation
                ? BackdropTransition
                : undefined, renderBackdrop: renderBackdrop, renderDialog: renderDialog })));
});
Modal.displayName = 'Modal';
Modal.propTypes = propTypes$y;
Modal.defaultProps = defaultProps$f;
var Modal$1 = Object.assign(Modal, {
    Body: ModalBody,
    Header: ModalHeader,
    Title: ModalTitle,
    Footer: ModalFooter,
    Dialog: ModalDialog,
    TRANSITION_DURATION: 300,
    BACKDROP_TRANSITION_DURATION: 150,
});

const NavItem = createWithBsPrefix('nav-item', {
    Component: "li",
    displayName: 'NavItem'
});

const propTypes$x = {
    /**
     * @default 'nav-link'
     */
    bsPrefix: PropTypes.string,
    /**
     * The active state of the NavItem item.
     */
    active: PropTypes.bool,
    /**
     * The disabled state of the NavItem item.
     */
    disabled: PropTypes.bool,
    /**
     * The ARIA role for the `NavLink`, In the context of a 'tablist' parent Nav,
     * the role defaults to 'tab'
     * */
    role: PropTypes.string,
    /** The HTML href attribute for the `NavLink` */
    href: PropTypes.string,
    /**
     * Uniquely identifies the `NavItem` amongst its siblings,
     * used to determine and control the active state of the parent `Nav`
     */
    eventKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    /** @default 'a' */
    as: PropTypes.elementType,
};
const defaultProps$e = {
    disabled: false,
};
const NavLink = React.forwardRef(({ bsPrefix, className, as: Component = Anchor, active, eventKey, 
// onClick,
...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'nav-link');
    const [navItemProps, meta] = useNavItem({
        key: makeEventKey(eventKey, props.href),
        active,
        ...props,
    });
    return (React.createElement(Component, { ...props, ...navItemProps, ref: ref, className: classNames(className, bsPrefix, props.disabled && 'disabled', meta.isActive && 'active'), "aria-current": meta.isActive ? "page" : "false" }));
});
NavLink.displayName = 'NavLink';
NavLink.propTypes = propTypes$x;
NavLink.defaultProps = defaultProps$e;

const NavContext = React.createContext(null);
NavContext.displayName = 'NavContext';

const propTypes$w = {
    /**
     * An html id attribute for the Toggle button, necessary for assistive technologies, such as screen readers.
     * @type {string}
     */
    id: PropTypes.string,
    /** An `onClick` handler passed to the Toggle component */
    onClick: PropTypes.func,
    /** The content of the non-toggle Button.  */
    title: PropTypes.node.isRequired,
    /** Disables the toggle NavLink  */
    disabled: PropTypes.bool,
    /** Style the toggle NavLink as active  */
    active: PropTypes.bool,
    /** An ARIA accessible role applied to the Menu component. When set to 'menu', The dropdown */
    menuRole: PropTypes.string,
    /** Whether to render the dropdown menu in the DOM before the first time it is shown */
    renderMenuOnMount: PropTypes.bool,
    /**
     *  Which event when fired outside the component will cause it to be closed.
     *
     * _see [DropdownMenu](#menu-props) for more details_
     */
    rootCloseEvent: PropTypes.string,
    /**
     * Menu color variant.
     *
     * Omitting this will use the default light color.
     */
    menuVariant: PropTypes.oneOf(['dark']),
    /** @ignore */
    bsPrefix: PropTypes.string,
    /** When true, applies mega menu stylings */
    isMegaMenu: PropTypes.bool,
    eventKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
};
const NavDropdown = React.forwardRef(({ id, title, children, bsPrefix, className, rootCloseEvent, menuRole, disabled, active, renderMenuOnMount, menuVariant, isMegaMenu, eventKey, align, ...props }, ref) => {
    /* NavItem has no additional logic, it's purely presentational. Can set nav item class here to support "as" */
    const navContext = useContext(NavContext);
    const navItemPrefix = useBootstrapPrefix(undefined, 'nav-item');
    const dropDownClass = classNames(className, navItemPrefix, isMegaMenu ? 'has-megamenu' : undefined);
    return (React.createElement(Dropdown$1, { ref: ref, as: "li", ...props, className: dropDownClass, align: align },
        React.createElement(Dropdown$1.Toggle, { id: id, eventKey: null, active: active || navContext?.activeKey === eventKey, disabled: disabled, childBsPrefix: bsPrefix, as: NavLink },
            title,
            React.createElement("i", { className: "bi bi-chevron-down" })),
        React.createElement(Dropdown$1.Menu, { role: menuRole, renderOnMount: renderMenuOnMount, rootCloseEvent: rootCloseEvent, variant: menuVariant, isNav: true, align: align, as: isMegaMenu ? 'div' : undefined, className: isMegaMenu ? 'mega-menu' : undefined }, children)));
});
NavDropdown.displayName = 'NavDropdown';
NavDropdown.propTypes = propTypes$w;
var NavDropdown$1 = Object.assign(NavDropdown, {
    Item: Dropdown$1.Item,
    ItemText: Dropdown$1.ItemText,
    Divider: Dropdown$1.Divider,
    Header: Dropdown$1.Header,
});

const propTypes$v = {
    /**
     * @default 'nav'
     */
    bsPrefix: PropTypes.string,
    /** @private */
    // navbarBsPrefix: PropTypes.string,
    /** @private */
    // cardHeaderBsPrefix: PropTypes.string,
    /**
     * The visual variant of the nav items.
     *
     * @type {('tabs-basic-toggle' | 'tabs-info-toggle')}
     */
    variant: PropTypes.string,
    /**
     * The default active key that is selected on start.
     */
    defaultActiveKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    /**
     * Marks the NavItem with a matching `eventKey` (or `href` if present) as active.
     */
    activeKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    /**
     * A callback fired when a NavItem is selected.
     *
     * ```js
     * function (
     *  Any eventKey,
     *  SyntheticEvent event?
     * )
     * ```
     */
    onSelect: PropTypes.func,
    /**
     * ARIA role for the Nav, in the context of a TabContainer, the default will
     * be set to "tablist", but can be overridden by the Nav when set explicitly.
     *
     * When the role is "tablist", NavLink focus is managed according to
     * the ARIA authoring practices for tabs:
     * https://www.w3.org/TR/2013/WD-wai-aria-practices-20130307/#tabpanel
     */
    role: PropTypes.string,
    /**
     * Apply styling an alignment for use in a Navbar. This prop will be set
     * automatically when the Nav is used inside a Navbar.
     */
    // navbar: PropTypes.bool,
    /**
     * Enable vertical scrolling within the toggleable contents of a collapsed Navbar.
     */
    navbarScroll: PropTypes.bool,
    as: PropTypes.elementType,
    /** @private */
    onKeyDown: PropTypes.func,
};
const Nav = React.forwardRef((uncontrolledProps, ref) => {
    const { as = 'ul', bsPrefix: initialBsPrefix, navbarScroll, className, activeKey, ...props } = useUncontrolled(uncontrolledProps, { activeKey: 'onSelect' });
    const bsPrefix = useBootstrapPrefix(initialBsPrefix, 'nav');
    const contextValue = useMemo(() => ({
        activeKey,
    }), [activeKey]);
    const navbarContext = useContext(context$3);
    return (React.createElement(NavContext.Provider, { value: contextValue },
        React.createElement(BaseNav, { as: as, ref: ref, activeKey: activeKey, className: classNames(className, {
                [bsPrefix]: !navbarContext,
                [`${navbarContext?.bsPrefix}-nav`]: navbarContext,
                [`${navbarContext?.bsPrefix}-nav-scroll`]: navbarContext && navbarScroll,
                ['sgds']: !navbarContext,
                ['nav-tabs']: !navbarContext,
            }), ...props })));
});
Nav.displayName = 'Nav';
Nav.propTypes = propTypes$v;
var Nav$1 = Object.assign(Nav, {
    Item: NavItem,
    Link: NavLink,
    Dropdown: NavDropdown$1,
});

const propTypes$u = {
    /** @default 'navbar' */
    bsPrefix: PropTypes.string,
    /**
     * An href, when provided the Brand will render as an `<a>` element (unless `as` is provided).
     */
    href: PropTypes.string,
    /**
     * Set a custom element for this component.
     */
    as: PropTypes.elementType,
};
const NavbarBrand = React.forwardRef(({ bsPrefix, className, as, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'navbar-brand');
    const Component = as || (props.href ? 'a' : 'span');
    return (React.createElement(Component, { ...props, ref: ref, className: classNames(className, bsPrefix) }));
});
NavbarBrand.displayName = 'NavbarBrand';
NavbarBrand.propTypes = propTypes$u;

const propTypes$t = {
    /** @default 'navbar-collapse' */
    bsPrefix: PropTypes.string,
};
const NavbarCollapse = React.forwardRef(({ children, bsPrefix, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'navbar-collapse');
    const context = useContext(context$3);
    return (React.createElement(Collapse, { in: !!(context && context.expanded), ...props },
        React.createElement("div", { ref: ref, className: bsPrefix }, children)));
});
NavbarCollapse.displayName = 'NavbarCollapse';
NavbarCollapse.propTypes = propTypes$t;

const propTypes$s = {
    /** @default 'navbar-toggler' */
    bsPrefix: PropTypes.string,
    /** An accessible ARIA label for the toggler button. */
    label: PropTypes.string,
    /** @private */
    onClick: PropTypes.func,
    /**
     * The toggle content. When empty, the default toggle will be rendered.
     */
    children: PropTypes.node,
    as: PropTypes.elementType,
};
const defaultProps$d = {
    label: 'Toggle navigation',
};
const NavbarToggle = React.forwardRef(({ bsPrefix, className, children, label, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'button', onClick, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'navbar-toggler');
    const { onToggle, expanded } = useContext(context$3) || {};
    const handleClick = useEventCallback((e) => {
        if (onClick)
            onClick(e);
        if (onToggle)
            onToggle();
    });
    if (Component === 'button') {
        props.type = 'button';
    }
    return (React.createElement(Component, { ...props, ref: ref, onClick: handleClick, "aria-label": label, className: classNames(className, bsPrefix, !expanded && 'collapsed'), "aria-expanded": expanded }, children || React.createElement("span", { className: `${bsPrefix}-icon` })));
});
NavbarToggle.displayName = 'NavbarToggle';
NavbarToggle.propTypes = propTypes$s;
NavbarToggle.defaultProps = defaultProps$d;

const NavbarText = createWithBsPrefix('navbar-text', {
    Component: 'span',
});

const propTypes$r = {
    /** @default 'navbar' */
    bsPrefix: PropTypes.string,
    /**
     * The breakpoint, below which, the Navbar will collapse.
     * When `true` the Navbar will always be expanded regardless of screen size.
     */
    expand: PropTypes.oneOfType([
        PropTypes.bool,
        PropTypes.oneOf(['sm', 'md', 'lg', 'xl', 'xxl']),
    ]).isRequired,
    /**
     * A convenience prop for adding `bg-*` utility classes since they are so commonly used here.
     * `light` and `dark` are common choices but any `bg-*` class is supported, including any custom ones you might define.
     *
     * Pairs nicely with the `variant` prop.
     */
    bg: PropTypes.string,
    /**
     * Create a fixed navbar along the top or bottom of the screen, that scrolls with the
     * page. A convenience prop for the `fixed-*` positioning classes.
     */
    fixed: PropTypes.oneOf(['top', 'bottom']),
    /**
     * Position the navbar at the top of the viewport, but only after scrolling past it.
     * A convenience prop for the `sticky-top` positioning class.
     *
     *  __Not supported in <= IE11 and other older browsers without a polyfill__
     */
    sticky: PropTypes.oneOf(['top']),
    /**
     * Set a custom element for this component.
     */
    as: PropTypes.elementType,
    /**
     * A callback fired when the `<Navbar>` body collapses or expands. Fired when
     * a `<Navbar.Toggle>` is clicked and called with the new `expanded`
     * boolean value.
     *
     * @controllable expanded
     */
    onToggle: PropTypes.func,
    /**
     * A callback fired when a descendant of a child `<Nav>` is selected. Should
     * be used to execute complex closing or other miscellaneous actions desired
     * after selecting a descendant of `<Nav>`. Does nothing if no `<Nav>` or `<Nav>`
     * descendants exist. The callback is called with an eventKey, which is a
     * prop from the selected `<Nav>` descendant, and an event.
     *
     * ```js
     * function (
     *  eventKey: mixed,
     *  event?: SyntheticEvent
     * )
     * ```
     *
     * For basic closing behavior after all `<Nav>` descendant onSelect events in
     * mobile viewports, try using collapseOnSelect.
     *
     * Note: If you are manually closing the navbar using this `OnSelect` prop,
     * ensure that you are setting `expanded` to false and not *toggling* between
     * true and false.
     */
    onSelect: PropTypes.func,
    /**
     * Toggles `expanded` to `false` after the onSelect event of a descendant of a
     * child `<Nav>` fires. Does nothing if no `<Nav>` or `<Nav>` descendants exist.
     *
     * Manually controlling `expanded` via the onSelect callback is recommended instead,
     * for more complex operations that need to be executed after
     * the `select` event of `<Nav>` descendants.
     */
    collapseOnSelect: PropTypes.bool,
    /**
     * Controls the visiblity of the navbar body
     *
     * @controllable onToggle
     */
    expanded: PropTypes.bool,
    /**
     * The ARIA role for the navbar, will default to 'navigation' for
     * Navbars whose `as` is something other than `<nav>`.
     *
     * @default 'navigation'
     */
    role: PropTypes.string,
    hasBorderBottom: PropTypes.bool,
};
const defaultProps$c = {
    expand: true,
    collapseOnSelect: false,
};
const Navbar = React.forwardRef((props, ref) => {
    const { bsPrefix: initialBsPrefix, expand, bg, fixed, sticky, className, hasBorderBottom, 
    // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
    as: Component = 'nav', expanded, onToggle, onSelect, collapseOnSelect, ...controlledProps } = useUncontrolled(props, {
        expanded: 'onToggle',
    });
    const bsPrefix = useBootstrapPrefix(initialBsPrefix, 'navbar');
    const handleCollapse = useCallback((...args) => {
        onSelect?.(...args);
        if (collapseOnSelect && expanded) {
            onToggle?.(false);
        }
    }, [onSelect, collapseOnSelect, expanded, onToggle]);
    // will result in some false positives but that seems better
    // than false negatives. strict `undefined` check allows explicit
    // "nulling" of the role if the user really doesn't want one
    if (controlledProps.role === undefined && Component !== 'nav') {
        controlledProps.role = 'navigation';
    }
    let expandClass = `${bsPrefix}-expand`;
    if (typeof expand === 'string')
        expandClass = `${expandClass}-${expand}`;
    const navbarContext = useMemo(() => ({
        onToggle: () => onToggle?.(!expanded),
        bsPrefix,
        expanded: !!expanded,
    }), [bsPrefix, expanded, onToggle]);
    return (React.createElement(context$3.Provider, { value: navbarContext },
        React.createElement(SelectableContext.Provider, { value: handleCollapse },
            React.createElement(SGDSWrapper, { as: Component, ref: ref, ...controlledProps, className: classNames(className, bsPrefix, expand && expandClass, 'navbar-light', bg && `bg-${bg}`, sticky && `sticky-${sticky}`, fixed && `fixed-${fixed}`, hasBorderBottom && 'border-bottom') }))));
});
Navbar.propTypes = propTypes$r;
Navbar.defaultProps = defaultProps$c;
Navbar.displayName = 'Navbar';
var Navbar$1 = Object.assign(Navbar, {
    Brand: NavbarBrand,
    Collapse: NavbarCollapse,
    // Offcanvas: NavbarOffcanvas,
    Text: NavbarText,
    Toggle: NavbarToggle,
});

var PopoverHeader = createWithBsPrefix('popover-header');

var PopoverBody = createWithBsPrefix('popover-body');

function getOverlayDirection(placement, isRTL) {
    let bsDirection = placement;
    if (placement === 'left') {
        bsDirection = isRTL ? 'end' : 'start';
    }
    else if (placement === 'right') {
        bsDirection = isRTL ? 'start' : 'end';
    }
    return bsDirection;
}

const propTypes$q = {
    /**
     * @default 'popover'
     */
    bsPrefix: PropTypes.string,
    /**
     * An html id attribute, necessary for accessibility
     * @type {string}
     * @required
     */
    id: PropTypes.string,
    /**
     * Sets the direction the Popover is positioned towards.
     *
     * > This is generally provided by the `Overlay` component positioning the popover
     */
    placement: PropTypes.oneOf([
        'auto-start',
        'auto',
        'auto-end',
        'top-start',
        'top',
        'top-end',
        'right-start',
        'right',
        'right-end',
        'bottom-end',
        'bottom',
        'bottom-start',
        'left-end',
        'left',
        'left-start',
    ]),
    /**
     * An Overlay injected set of props for positioning the popover arrow.
     *
     * > This is generally provided by the `Overlay` component positioning the popover
     */
    arrowProps: PropTypes.shape({
        ref: PropTypes.any,
        style: PropTypes.object,
    }),
    /**
     * When this prop is set, it creates a Popover with a Popover.Body inside
     * passing the children directly to it
     */
    body: PropTypes.bool,
    /** @private */
    popper: PropTypes.object,
    /** @private */
    show: PropTypes.bool,
    hasArrow: PropTypes.bool,
};
const defaultProps$b = {
    placement: 'right',
};
const Popover = React.forwardRef(({ bsPrefix, placement, className, style, children, body, arrowProps, hasArrow = false, popper: _, show: _1, ...props }, ref) => {
    const decoratedBsPrefix = useBootstrapPrefix(bsPrefix, 'popover');
    const isRTL = useIsRTL();
    const [primaryPlacement] = placement?.split('-') || [];
    const bsDirection = getOverlayDirection(primaryPlacement, isRTL);
    return (React.createElement("div", { ref: ref, role: "tooltip", style: style, "x-placement": primaryPlacement, className: classNames(className, decoratedBsPrefix, primaryPlacement && `bs-popover-${bsDirection}`), ...props },
        hasArrow && React.createElement("div", { className: "popover-arrow", ...arrowProps }),
        React.createElement(React.Fragment, null,
            " ",
            children)));
});
Popover.defaultProps = defaultProps$b;
Popover.propTypes = propTypes$q;
var Popover$1 = Object.assign(Popover, {
    Header: PopoverHeader,
    Body: PopoverBody,
    // Default popover offset.
    // https://github.com/twbs/bootstrap/blob/5c32767e0e0dbac2d934bcdee03719a65d3f1187/js/src/popover.js#L28
    POPPER_OFFSET: [0, 8],
});

// This is meant for internal use.
// This applies a custom offset to the overlay if it's a popover.
function useOverlayOffset(customOffset) {
    const overlayRef = useRef(null);
    const popoverClass = useBootstrapPrefix(undefined, 'popover');
    const offset = useMemo(() => ({
        name: 'offset',
        options: {
            offset: () => {
                if (overlayRef.current &&
                    hasClass(overlayRef.current, popoverClass)) {
                    return customOffset || Popover$1.POPPER_OFFSET;
                }
                return customOffset || [0, 0];
            },
        },
    }), [customOffset, popoverClass]);
    return [overlayRef, [offset]];
}

const propTypes$p = {
    /**
     * A component instance, DOM node, or function that returns either.
     * The `container` element will have the Overlay appended to it via a React portal.
     */
    container: PropTypes.oneOfType([componentOrElement, PropTypes.func]),
    /**
     * A component instance, DOM node, or function that returns either.
     * The overlay will be positioned in relation to the `target`
     */
    target: PropTypes.oneOfType([componentOrElement, PropTypes.func]),
    /**
     * Set the visibility of the Overlay
     */
    show: PropTypes.bool,
    /**
     * A set of popper options and props passed directly to Popper.
     */
    popperConfig: PropTypes.object,
    /**
     * Specify whether the overlay should trigger onHide when the user clicks outside the overlay
     */
    rootClose: PropTypes.bool,
    /**
     * Specify event for triggering a "root close" toggle.
     */
    rootCloseEvent: PropTypes.oneOf(['click', 'mousedown']),
    /**
     * A callback invoked by the overlay when it wishes to be hidden. Required if
     * `rootClose` is specified.
     */
    onHide: PropTypes.func,
    /**
     * Animate the entering and exiting of the Overlay. `true` will use the `<Fade>` transition,
     * or a custom react-transition-group `<Transition>` component can be provided.
     */
    transition: PropTypes.oneOfType([PropTypes.bool, elementType]),
    /**
     * Callback fired before the Overlay transitions in
     */
    onEnter: PropTypes.func,
    /**
     * Callback fired as the Overlay begins to transition in
     */
    onEntering: PropTypes.func,
    /**
     * Callback fired after the Overlay finishes transitioning in
     */
    onEntered: PropTypes.func,
    /**
     * Callback fired right before the Overlay transitions out
     */
    onExit: PropTypes.func,
    /**
     * Callback fired as the Overlay begins to transition out
     */
    onExiting: PropTypes.func,
    /**
     * Callback fired after the Overlay finishes transitioning out
     */
    onExited: PropTypes.func,
    /**
     * The placement of the Overlay in relation to it's `target`.
     */
    placement: PropTypes.oneOf([
        'auto-start',
        'auto',
        'auto-end',
        'top-start',
        'top',
        'top-end',
        'right-start',
        'right',
        'right-end',
        'bottom-end',
        'bottom',
        'bottom-start',
        'left-end',
        'left',
        'left-start',
    ]),
};
const defaultProps$a = {
    transition: Fade,
    rootClose: false,
    show: false,
    placement: 'top',
};
function wrapRefs(props, arrowProps) {
    const { ref } = props;
    const { ref: aRef } = arrowProps;
    props.ref = ref.__wrapped || (ref.__wrapped = (r) => ref(safeFindDOMNode(r)));
    arrowProps.ref =
        aRef.__wrapped || (aRef.__wrapped = (r) => aRef(safeFindDOMNode(r)));
}
const Overlay = React.forwardRef(({ children: overlay, transition, popperConfig = {}, ...outerProps }, outerRef) => {
    const popperRef = useRef({});
    const [ref, modifiers] = useOverlayOffset(outerProps.offset);
    const mergedRef = useMergedRefs(outerRef, ref);
    const actualTransition = transition === true ? Fade : transition || undefined;
    return (React.createElement(BaseOverlay, { ...outerProps, ref: mergedRef, popperConfig: {
            ...popperConfig,
            modifiers: modifiers.concat(popperConfig.modifiers || []),
        }, 
        //@ts-ignore
        transition: actualTransition }, (overlayProps, { arrowProps, popper: popperObj, show }) => {
        wrapRefs(overlayProps, arrowProps);
        // Need to get placement from popper object, handling case when overlay is flipped using 'flip' prop
        const updatedPlacement = popperObj?.placement;
        const popper = Object.assign(popperRef.current, {
            state: popperObj?.state,
            scheduleUpdate: popperObj?.update,
            placement: updatedPlacement,
            outOfBoundaries: popperObj?.state?.modifiersData.hide?.isReferenceHidden || false,
        });
        if (typeof overlay === 'function')
            return overlay({
                ...overlayProps,
                placement: updatedPlacement,
                show,
                ...(!transition && show && { className: 'show' }),
                popper,
                arrowProps,
            });
        return React.cloneElement(overlay, {
            ...overlayProps,
            placement: updatedPlacement,
            arrowProps,
            popper,
            className: classNames(overlay.props.className, !transition && show && 'show'),
            style: {
                ...overlay.props.style,
                ...overlayProps.style,
            },
        });
    }));
});
Overlay.displayName = 'Overlay';
Overlay.propTypes = propTypes$p;
Overlay.defaultProps = defaultProps$a;

function normalizeDelay(delay) {
    return delay && typeof delay === 'object'
        ? delay
        : {
            show: delay,
            hide: delay,
        };
}
// Simple implementation of mouseEnter and mouseLeave.
// React's built version is broken: https://github.com/facebook/react/issues/4251
// for cases when the trigger is disabled and mouseOut/Over can cause flicker
// moving from one child element to another.
function handleMouseOverOut(
// eslint-disable-next-line @typescript-eslint/no-shadow
handler, args, relatedNative) {
    const [e] = args;
    const target = e.currentTarget;
    const related = e.relatedTarget || e.nativeEvent[relatedNative];
    if ((!related || related !== target) && !contains(target, related)) {
        handler(...args);
    }
}
const triggerType = PropTypes.oneOf(['click', 'hover', 'focus']);
const propTypes$o = {
    children: PropTypes.oneOfType([PropTypes.element, PropTypes.func]).isRequired,
    /**
     * Specify which action or actions trigger Overlay visibility
     *
     * @type {'hover' | 'click' |'focus' | Array<'hover' | 'click' |'focus'>}
     */
    trigger: PropTypes.oneOfType([triggerType, PropTypes.arrayOf(triggerType)]),
    /**
     * A millisecond delay amount to show and hide the Overlay once triggered
     */
    delay: PropTypes.oneOfType([
        PropTypes.number,
        PropTypes.shape({
            show: PropTypes.number,
            hide: PropTypes.number,
        }),
    ]),
    /**
     * The visibility of the Overlay. `show` is a _controlled_ prop so should be paired
     * with `onToggle` to avoid breaking user interactions.
     *
     * Manually toggling `show` does **not** wait for `delay` to change the visibility.
     *
     * @controllable onToggle
     */
    show: PropTypes.bool,
    /**
     * The initial visibility state of the Overlay.
     */
    defaultShow: PropTypes.bool,
    /**
     * A callback that fires when the user triggers a change in tooltip visibility.
     *
     * `onToggle` is called with the desired next `show`, and generally should be passed
     * back to the `show` prop. `onToggle` fires _after_ the configured `delay`
     *
     * @controllable `show`
     */
    onToggle: PropTypes.func,
    /**
      The initial flip state of the Overlay.
     */
    flip: PropTypes.bool,
    /**
     * An element or text to overlay next to the target.
     */
    overlay: PropTypes.oneOfType([PropTypes.func, PropTypes.element.isRequired]),
    /**
     * A Popper.js config object passed to the the underlying popper instance.
     */
    popperConfig: PropTypes.object,
    // Overridden props from `<Overlay>`.
    /**
     * @private
     */
    target: PropTypes.oneOf([null]),
    /**
     * @private
     */
    onHide: PropTypes.oneOf([null]),
    /**
     * The placement of the Overlay in relation to it's `target`.
     */
    placement: PropTypes.oneOf([
        'auto-start',
        'auto',
        'auto-end',
        'top-start',
        'top',
        'top-end',
        'right-start',
        'right',
        'right-end',
        'bottom-end',
        'bottom',
        'bottom-start',
        'left-end',
        'left',
        'left-start',
    ]),
};
const defaultProps$9 = {
    defaultShow: false,
    trigger: ['hover', 'focus'],
};
function OverlayTrigger({ trigger, overlay, children, popperConfig = {}, show: propsShow, defaultShow = false, onToggle, delay: propsDelay, placement, flip = placement && placement.indexOf('auto') !== -1, ...props }) {
    const triggerNodeRef = useRef(null);
    const mergedRef = useMergedRefs(triggerNodeRef, children.ref);
    const timeout = useTimeout();
    const hoverStateRef = useRef('');
    const [show, setShow] = useUncontrolledProp(propsShow, defaultShow, onToggle);
    const delay = normalizeDelay(propsDelay);
    const { onFocus, onBlur, onClick } = typeof children !== 'function'
        ? React.Children.only(children).props
        : {};
    const attachRef = (r) => {
        mergedRef(safeFindDOMNode(r));
    };
    const handleShow = useCallback(() => {
        timeout.clear();
        hoverStateRef.current = 'show';
        if (!delay.show) {
            setShow(true);
            return;
        }
        timeout.set(() => {
            if (hoverStateRef.current === 'show')
                setShow(true);
        }, delay.show);
    }, [delay.show, setShow, timeout]);
    const handleHide = useCallback(() => {
        timeout.clear();
        hoverStateRef.current = 'hide';
        if (!delay.hide) {
            setShow(false);
            return;
        }
        timeout.set(() => {
            if (hoverStateRef.current === 'hide')
                setShow(false);
        }, delay.hide);
    }, [delay.hide, setShow, timeout]);
    const handleFocus = useCallback((...args) => {
        handleShow();
        onFocus?.(...args);
    }, [handleShow, onFocus]);
    const handleBlur = useCallback((...args) => {
        handleHide();
        onBlur?.(...args);
    }, [handleHide, onBlur]);
    const handleClick = useCallback((...args) => {
        setShow(!show);
        onClick?.(...args);
    }, [onClick, setShow, show]);
    const handleMouseOver = useCallback((...args) => {
        handleMouseOverOut(handleShow, args, 'fromElement');
    }, [handleShow]);
    const handleMouseOut = useCallback((...args) => {
        handleMouseOverOut(handleHide, args, 'toElement');
    }, [handleHide]);
    const triggers = trigger == null ? [] : [].concat(trigger);
    const triggerProps = {
        ref: attachRef,
    };
    if (triggers.indexOf('click') !== -1) {
        triggerProps.onClick = handleClick;
    }
    if (triggers.indexOf('focus') !== -1) {
        triggerProps.onFocus = handleFocus;
        triggerProps.onBlur = handleBlur;
    }
    if (triggers.indexOf('hover') !== -1) {
        warning(triggers.length > 1, '[react-bootstrap] Specifying only the `"hover"` trigger limits the visibility of the overlay to just mouse users. Consider also including the `"focus"` trigger so that touch and keyboard only users can see the overlay as well.');
        triggerProps.onMouseOver = handleMouseOver;
        triggerProps.onMouseOut = handleMouseOut;
    }
    return (React.createElement(React.Fragment, null,
        typeof children === 'function'
            ? children(triggerProps)
            : cloneElement(children, triggerProps),
        React.createElement(Overlay, { ...props, show: show, onHide: handleHide, flip: flip, placement: placement, popperConfig: popperConfig, target: triggerNodeRef.current }, overlay)));
}
OverlayTrigger.defaultProps = defaultProps$9;
OverlayTrigger.propTypes = propTypes$o;

/* eslint-disable react/no-multi-comp */
const propTypes$n = {
    /** Disables the PageItem */
    disabled: PropTypes.bool,
    /** Styles PageItem as active, and renders a `<span>` instead of an `<a>`. */
    active: PropTypes.bool,
    /** A callback function for when this component is clicked */
    onClick: PropTypes.func,
    /** An accessible label indicating the active state.. */
    activeLabel: PropTypes.string,
};
const defaultProps$8 = {
    active: false,
    disabled: false,
    activeLabel: '(current)',
};
const PageItem = React.forwardRef(({ active, disabled, className, style, children, activeLabel, ...props }, ref) => {
    const Component = active || disabled ? 'span' : Anchor;
    return (React.createElement("li", { ref: ref, style: style, className: classNames(className, 'page-item', { active, disabled }) },
        React.createElement(Component, { className: "page-link", disabled: disabled, ...props },
            children,
            active && activeLabel && (React.createElement("span", { className: "visually-hidden" }, activeLabel)))));
});
PageItem.propTypes = propTypes$n;
PageItem.defaultProps = defaultProps$8;
PageItem.displayName = 'PageItem';
function createButton(name, defaultValue, label = name) {
    const Button = React.forwardRef(({ children, ...props }, ref) => (React.createElement(PageItem, { ...props, ref: ref },
        React.createElement("span", { "aria-hidden": "true" }, children || defaultValue),
        React.createElement("span", { className: "visually-hidden" }, label))));
    Button.displayName = name;
    return Button;
}
const First = createButton('First', '«');
const Prev = createButton('Previous', '‹');
const Ellipsis = createButton('Ellipsis', '…');
const Next = createButton('Next', '›');
const Last = createButton('Last', '»');

const propTypes$m = {
    /**
     * @default 'pagination'
     * */
    bsPrefix: PropTypes.string,
    /**
     * Set's the size of all PageItems.
     *
     * @type {('sm' | 'md' | lg')}
     */
    size: PropTypes.oneOf(['sm', 'md', 'lg']),
};
/**
 * @property {PageItem} Item
 * @property {PageItem} First
 * @property {PageItem} Prev
 * @property {PageItem} Ellipsis
 * @property {PageItem} Next
 * @property {PageItem} Last
 */
const PaginationBase = React.forwardRef(({ bsPrefix, className, size, ...props }, ref) => {
    const decoratedBsPrefix = useBootstrapPrefix(bsPrefix, 'pagination');
    return (React.createElement(SGDSWrapper, { as: 'nav', "aria-label": 'Page Navigation' },
        React.createElement("ul", { ref: ref, ...props, className: classNames(className, decoratedBsPrefix, size && `${decoratedBsPrefix}-${size}`) })));
});
PaginationBase.propTypes = propTypes$m;
PaginationBase.displayName = 'PaginationBase';
var PaginationBase$1 = Object.assign(PaginationBase, {
    First,
    Prev,
    Ellipsis,
    Item: PageItem,
    Next,
    Last,
});

const Pagination = ({ dataLength = 0, currentPage = 1, itemsPerPage = 5, limit = 3, setCurrentPage, directionVariant = 'icon-text', size = 'sm', ellipsisOn = false, ellipsisJump = 3, }) => {
    // set the id of page item clicked to currentPage
    const handlePageClick = (event) => {
        const liTarget = event.target;
        setCurrentPage(Number(liTarget.id));
    };
    const pages = [];
    for (let i = 1; i <= Math.ceil(dataLength / itemsPerPage); i++) {
        pages.push(i);
    }
    const sanitizeLimit = limit >= pages.length ? pages.length : limit;
    const renderPgNumbers = () => {
        const pagesToShow = [];
        let sanitizeStartPage = 1;
        let endPage;
        if (limit < pages.length)
            sanitizeStartPage = currentPage - Math.floor(sanitizeLimit / 2);
        if (pages.length - sanitizeStartPage < limit)
            sanitizeStartPage = pages.length + 1 - limit;
        if (sanitizeStartPage <= 0)
            sanitizeStartPage = 1;
        endPage = sanitizeStartPage + sanitizeLimit - 1;
        if (endPage > pages.length)
            endPage = pages.length;
        if (currentPage === pages.length)
            sanitizeStartPage = pages.length - sanitizeLimit + 1;
        for (let i = sanitizeStartPage; i <= endPage; i++) {
            pagesToShow.push(i);
        }
        return pagesToShow.map((number) => (React.createElement(PaginationBase$1.Item, { key: number, id: number.toString(), onClick: handlePageClick, className: currentPage == number ? 'active' : undefined }, number)));
    };
    const handleNextButton = () => {
        setCurrentPage(currentPage + 1);
    };
    const handlePrevButton = () => {
        setCurrentPage(currentPage - 1);
    };
    // handleclick for ellipsisOn
    const handleNextEllipsisButton = () => {
        setCurrentPage(currentPage + ellipsisJump);
        if (currentPage + ellipsisJump > pages.length)
            setCurrentPage(pages.length);
    };
    const handlePrevEllipsisButton = () => {
        setCurrentPage(currentPage - ellipsisJump);
        if (currentPage - ellipsisJump < 1)
            setCurrentPage(1);
    };
    const renderLastEllipsis = () => {
        const isEvenLimit = sanitizeLimit % 2 === 0;
        const differentialLimitCondition = isEvenLimit
            ? currentPage + Math.floor(sanitizeLimit / 2) <= pages.length
            : currentPage + Math.floor(sanitizeLimit / 2) < pages.length;
        if (pages.length !== sanitizeLimit && differentialLimitCondition)
            return (React.createElement(PaginationBase$1.Ellipsis, { onClick: handleNextEllipsisButton, disabled: !ellipsisOn }));
        else
            return null;
    };
    const renderFirstEllipsis = () => {
        if (pages.length !== sanitizeLimit &&
            currentPage - Math.floor(sanitizeLimit / 2) > 1)
            return React.createElement(PaginationBase$1.Ellipsis, { onClick: handlePrevEllipsisButton });
        else
            return null;
    };
    const directionBtnContent = (directionLabel, iconClass) => {
        return (React.createElement(React.Fragment, null,
            directionVariant !== 'icon' &&
                directionLabel === 'Next' &&
                directionLabel,
            directionVariant === 'text' ? null : React.createElement("i", { className: iconClass }),
            directionVariant !== 'icon' &&
                directionLabel === 'Previous' &&
                directionLabel));
    };
    return (React.createElement(PaginationBase$1, { size: size },
        React.createElement(PaginationBase$1.Prev, { onClick: handlePrevButton, disabled: currentPage <= 1 }, directionBtnContent('Previous', 'bi bi-chevron-left')),
        ellipsisOn ? renderFirstEllipsis() : null,
        renderPgNumbers(),
        renderLastEllipsis(),
        React.createElement(PaginationBase$1.Next, { onClick: handleNextButton, disabled: currentPage >= pages.length }, directionBtnContent('Next', 'bi bi-chevron-right'))));
};
Pagination.displayName = 'Pagination';

/**
 * Iterates through children that are typically specified as `props.children`,
 * but only maps over children that are "valid elements".
 *
 * The mapFunction provided index will be normalised to the components mapped,
 * so an invalid component would not increase the index.
 *
 */
function map(children, func) {
    let index = 0;
    return React.Children.map(children, (child) => React.isValidElement(child) ? func(child, index++) : child);
}
/**
 * Iterates through children that are "valid elements".
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child with the index reflecting the position relative to "valid components".
 */
function forEach(children, func) {
    let index = 0;
    React.Children.forEach(children, (child) => {
        if (React.isValidElement(child))
            func(child, index++);
    });
}

const ROUND_PRECISION = 1000;
/**
 * Validate that children, if any, are instances of `<ProgressBar>`.
 */
function onlyProgressBar(props, propName, componentName) {
    const children = props[propName];
    if (!children) {
        return null;
    }
    let error = null;
    React.Children.forEach(children, (child) => {
        if (error) {
            return;
        }
        /**
         * Compare types in a way that works with libraries that patch and proxy
         * components like react-hot-loader.
         *
         * see https://github.com/gaearon/react-hot-loader#checking-element-types
         */
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        const element = React.createElement(ProgressBar, null);
        if (child.type === element.type)
            return;
        const childType = child.type;
        const childIdentifier = React.isValidElement(child)
            ? childType.displayName || childType.name || childType
            : child;
        error = new Error(`Children of ${componentName} can contain only ProgressBar ` +
            `components. Found ${childIdentifier}.`);
    });
    return error;
}
const propTypes$l = {
    /**
     * Minimum value progress can begin from
     */
    min: PropTypes.number,
    /**
     * Current value of progress
     */
    now: PropTypes.number,
    /**
     * Maximum value progress can reach
     */
    max: PropTypes.number,
    /**
     * Show label that represents visual percentage.
     * EG. 60%
     */
    label: PropTypes.node,
    /**
     * Forwards to aria-label attribute on element with role="progressbar"
     *
     */
    ariaLabel: PropTypes.string,
    /**
     * Hide's the label visually.
     */
    visuallyHidden: PropTypes.bool,
    /**
     * Uses a gradient to create a striped effect.
     */
    striped: PropTypes.bool,
    /**
     * Animate's the stripes from right to left
     */
    animated: PropTypes.bool,
    /**
     * @private
     * @default 'progress-bar'
     */
    bsPrefix: PropTypes.string,
    /**
     * Sets the background class of the progress bar.
     *
     * @type ('success'|'danger'|'warning'|'info')
     */
    variant: PropTypes.string,
    /**
     * Child elements (only allows elements of type <ProgressBar />)
     */
    children: onlyProgressBar,
    /**
     * @private
     */
    isChild: PropTypes.bool,
};
const defaultProps$7 = {
    min: 0,
    max: 100,
    animated: false,
    isChild: false,
    visuallyHidden: false,
    striped: false,
    ariaLabel: 'progressbar',
};
function getPercentage(now, min, max) {
    const percentage = ((now - min) / (max - min)) * 100;
    return Math.round(percentage * ROUND_PRECISION) / ROUND_PRECISION;
}
function renderProgressBar({ min, now, max, label, visuallyHidden, striped, animated, className, style, variant, bsPrefix, ariaLabel = 'progressbar', ...props }, ref) {
    return (React.createElement("div", { ref: ref, ...props, role: "progressbar", className: classNames(className, `${bsPrefix}-bar`, {
            [`bg-${variant}`]: variant,
            [`${bsPrefix}-bar-animated`]: animated,
            [`${bsPrefix}-bar-striped`]: animated || striped,
        }), style: { width: `${getPercentage(now, min, max)}%`, ...style }, "aria-valuenow": now, "aria-valuemin": min, "aria-valuemax": max, "aria-label": ariaLabel }, visuallyHidden ? (React.createElement("span", { className: "visually-hidden" }, label)) : (label)));
}
renderProgressBar.propTypes = propTypes$l;
const ProgressBar = React.forwardRef(({ isChild, ...props }, ref) => {
    props.bsPrefix = useBootstrapPrefix(props.bsPrefix, 'progress');
    if (isChild) {
        return renderProgressBar(props, ref);
    }
    const { min, now, max, label, visuallyHidden, striped, animated, bsPrefix, variant, className, children, ariaLabel, ...wrapperProps } = props;
    return (React.createElement(SGDSWrapper, { ref: ref, ...wrapperProps, className: classNames(className, bsPrefix) }, children
        ? map(children, (child) => cloneElement(child, { isChild: true }))
        : renderProgressBar({
            min,
            now,
            max,
            label,
            visuallyHidden,
            striped,
            animated,
            bsPrefix,
            variant,
            ariaLabel,
        }, ref)));
});
ProgressBar.displayName = 'ProgressBar';
ProgressBar.propTypes = propTypes$l;
ProgressBar.defaultProps = defaultProps$7;

const defaultProps$6 = {
    size: 'sm',
    step: 1,
};
const propTypes$k = {
    step: PropTypes.number,
    size: PropTypes.oneOf(['sm', 'lg']),
    count: PropTypes.number.isRequired,
    setCount: PropTypes.func.isRequired,
    disabled: PropTypes.bool,
    variant: PropTypes.oneOf([
        'primary',
        'secondary',
        'success',
        'danger',
        'warning',
        'info',
        'dark',
        'light',
        'link',
        'outline-primary',
        'outline-secondary',
        'outline-success',
        'outline-danger',
        'outline-warning',
        'outline-info',
        'outline-dark',
        'outline-light',
    ]),
};
const QuantityToggle = React.forwardRef(({ size, step = 1, disabled, variant, count, setCount, ...props }, ref) => {
    const buttonProps = { disabled, variant };
    const onPlus = () => {
        setCount(count + step);
    };
    const onMinus = () => {
        if (count < 1)
            setCount(0);
        else
            setCount(count - step);
    };
    React.useEffect(() => {
        if (count < 0)
            setCount(0);
    }, []);
    return (React.createElement(React.Fragment, null,
        React.createElement(FormLabel, { className: "visually-hidden" }, "quantity-toggle"),
        React.createElement(InputGroup$1, { size: size, variant: "quantity-toggle" },
            React.createElement(Button, { onClick: onMinus, ...buttonProps, "aria-label": `decrease by ${step}` },
                React.createElement("i", { className: "bi bi-dash" })),
            React.createElement(FormControl$1, { ...props, disabled: disabled, ref: ref, type: "number", className: "text-center", value: count, name: "quantity", onChange: (e) => {
                    setCount(parseInt(e.target.value));
                }, min: 0 }),
            React.createElement("div", { id: "quantitytoggle-announcer", role: "region", "aria-live": "assertive", className: "visually-hidden" }, count),
            React.createElement(Button, { onClick: onPlus, ...buttonProps, "aria-label": `increase by ${step}` },
                React.createElement("i", { className: "bi bi-plus" })))));
});
QuantityToggle.displayName = 'QuantityToggle';
QuantityToggle.defaultProps = defaultProps$6;
QuantityToggle.propTypes = propTypes$k;

const DEVICE_SIZES = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];
const rowColWidth = PropTypes.oneOfType([PropTypes.number, PropTypes.string]);
const rowColumns = PropTypes.oneOfType([
    rowColWidth,
    PropTypes.shape({
        cols: rowColWidth,
    }),
]);
const propTypes$j = {
    /**
     * @default 'row'
     */
    bsPrefix: PropTypes.string,
    as: PropTypes.elementType,
    /**
     * The number of columns that will fit next to each other on extra small devices (<576px).
     * Use `auto` to give columns their natural widths.
     *
     * @type {(number|'auto'|{ cols: number|'auto' })}
     */
    xs: rowColumns,
    /**
     * The number of columns that will fit next to each other on small devices (≥576px).
     * Use `auto` to give columns their natural widths.
     *
     * @type {(number|'auto'|{ cols: number|'auto' })}
     */
    sm: rowColumns,
    /**
     * The number of columns that will fit next to each other on medium devices (≥768px).
     * Use `auto` to give columns their natural widths.
     *
     * @type {(number|'auto'|{ cols: number|'auto' })}
     */
    md: rowColumns,
    /**
     * The number of columns that will fit next to each other on large devices (≥992px).
     * Use `auto` to give columns their natural widths.
     *
     * @type {(number|'auto'|{ cols: number|'auto' })}
     */
    lg: rowColumns,
    /**
     * The number of columns that will fit next to each other on extra large devices (≥1200px).
     * Use `auto` to give columns their natural widths.
     *
     * @type {(number|'auto'|{ cols: number|'auto' })}
     */
    xl: rowColumns,
    /**
     * The number of columns that will fit next to each other on extra extra large devices (≥1400px).
     * Use `auto` to give columns their natural widths.
     *
     * @type {(number|'auto'|{ cols: number|'auto' })}
     */
    xxl: rowColumns,
};
const Row = React.forwardRef(({ bsPrefix, className, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'div', ...props }, ref) => {
    const decoratedBsPrefix = useBootstrapPrefix(bsPrefix, 'row');
    const sizePrefix = `${decoratedBsPrefix}-cols`;
    const classes = [];
    DEVICE_SIZES.forEach((brkPoint) => {
        const propValue = props[brkPoint];
        delete props[brkPoint];
        let cols;
        if (propValue != null && typeof propValue === 'object') {
            ({ cols } = propValue);
        }
        else {
            cols = propValue;
        }
        const infix = brkPoint !== 'xs' ? `-${brkPoint}` : '';
        if (cols != null)
            classes.push(`${sizePrefix}${infix}-${cols}`);
    });
    return (React.createElement(Component, { ref: ref, ...props, className: classNames(className, decoratedBsPrefix, ...classes) }));
});
Row.displayName = 'Row';
Row.propTypes = propTypes$j;

function isSideNavItemSelected(activeEventKey, eventKey) {
    return Array.isArray(activeEventKey)
        ? activeEventKey.includes(eventKey)
        : activeEventKey === eventKey;
}
const context$1 = React.createContext({});
context$1.displayName = 'SideNavContext';

const context = React.createContext({
    eventKey: '',
});
context.displayName = 'SideNavItemContext';

const propTypes$i = {
    /** Set a custom element for this component */
    as: PropTypes.elementType,
    /** @default 'sidenav-button' */
    bsPrefix: PropTypes.string,
    /** A callback function for when this component is clicked */
    onClick: PropTypes.func,
    /** Providing a `href` will render an `<a>` element, _styled_ as a button. */
    href: PropTypes.string,
};
function useSideNavButton(eventKey, onClick) {
    const { activeEventKey, onSelect, alwaysOpen } = useContext(context$1);
    return (e) => {
        /*
          Compare the event key in context with the given event key.
          If they are the same, then collapse the component.
        */
        let eventKeyPassed = eventKey === activeEventKey ? null : eventKey;
        if (alwaysOpen) {
            if (Array.isArray(activeEventKey)) {
                if (activeEventKey.includes(eventKey)) {
                    eventKeyPassed = activeEventKey.filter((k) => k !== eventKey);
                }
                else {
                    eventKeyPassed = [...activeEventKey, eventKey];
                }
            }
            else {
                // activeEventKey is undefined.
                eventKeyPassed = [eventKey];
            }
        }
        onSelect?.(eventKeyPassed, e);
        onClick?.(e);
    };
}
const setCollapseCSS = (activeEventKey, eventKey) => {
    if (Array.isArray(activeEventKey)) {
        return !activeEventKey.includes(eventKey) && 'collapsed';
    }
    if (typeof activeEventKey === 'string') {
        return activeEventKey !== eventKey && 'collapsed';
    }
    return 'collapsed';
};
const SideNavButton = React.forwardRef(({ 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = Button, bsPrefix, className, onClick, children, ...props }, ref) => {
    const btnRef = React.useRef(null);
    const mergedRef = useMergedRefs(ref, btnRef);
    const { eventKey } = useContext(context);
    const sideNavOnClick = useSideNavButton(eventKey, onClick);
    const { activeEventKey } = useContext(context$1);
    if (Component === 'button') {
        props.type = 'button';
    }
    return (React.createElement(Component, { ref: mergedRef, variant: '', onClick: sideNavOnClick, ...props, "aria-expanded": eventKey === activeEventKey, "aria-haspopup": "menu", className: classNames(className, setCollapseCSS(activeEventKey, eventKey)) },
        children,
        !props.href && React.createElement("i", { className: "bi bi-chevron-down" })));
});
SideNavButton.propTypes = propTypes$i;
SideNavButton.displayName = 'SideNavButton';

const propTypes$h = {
    /** Set a custom element for this component */
    as: PropTypes.elementType,
    /** Children prop should only contain a single child, and is enforced as such */
    children: PropTypes.node,
};
const SideNavCollapse = React.forwardRef(({ as: Component = 'div', bsPrefix, className, children, ...props }, ref) => {
    const { activeEventKey } = useContext(context$1);
    const { eventKey: itemEventKey } = useContext(context);
    bsPrefix = useBootstrapPrefix(bsPrefix, 'sidenav-collapse');
    return (React.createElement(Collapse, { ref: ref, in: isSideNavItemSelected(activeEventKey, itemEventKey), ...props, className: classNames(className, bsPrefix) },
        React.createElement(Component, null,
            React.createElement("ul", { className: "list-unstyled" }, React.Children.map(children, child => (React.createElement("li", null, React.cloneElement(child))))))));
});
SideNavCollapse.propTypes = propTypes$h;
SideNavCollapse.displayName = 'SideNavCollapse';

const propTypes$g = {
    /** Set a custom element for this component */
    as: PropTypes.elementType,
    /** @default 'accordion-item' */
    bsPrefix: PropTypes.string,
    /**
     * A unique key used to control this item's collapse/expand.
     * @required
     */
    eventKey: PropTypes.string.isRequired,
};
const SideNavItem = React.forwardRef(({ 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'li', bsPrefix, className, eventKey, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'sidenav-item');
    const contextValue = useMemo(() => ({
        eventKey,
    }), [eventKey]);
    return (React.createElement(context.Provider, { value: contextValue },
        React.createElement(Component, { ref: ref, ...props, className: classNames(className, bsPrefix) })));
});
SideNavItem.propTypes = propTypes$g;
SideNavItem.displayName = 'SideNavItem';

const propTypes$f = {
    eventKey: PropTypes.string.isRequired
};
const SideNavLink = React.forwardRef(({ eventKey, ...props }, ref) => {
    const { activeLinkKey } = React.useContext(context$1);
    return (React.createElement(NavLink, { ...props, ref: ref, eventKey: eventKey, active: activeLinkKey === eventKey }));
});
SideNavLink.displayName = 'SideNavLink';
SideNavLink.propTypes = propTypes$f;

const propTypes$e = {
    /** Set a custom element for this component */
    as: PropTypes.elementType,
    /** @default 'sidenav' */
    bsPrefix: PropTypes.string,
    /** The current active key that corresponds to the currently expanded card */
    activeKey: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),
    /** The default active key that is expanded on start */
    defaultActiveKey: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),
    /** Allow accordion items to stay open when another item is opened */
    alwaysOpen: PropTypes.bool,
    /** The current active NavLink that corresponds to the currently expanded card */
    activeNavLinkKey: PropTypes.string,
};
const SideNav = React.forwardRef((props, ref) => {
    const { 
    // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
    as: Component = 'ul', activeKey, bsPrefix, className, onSelect, alwaysOpen, activeNavLinkKey = '', ...controlledProps } = useUncontrolled(props, {
        activeKey: 'onSelect',
    });
    const prefix = useBootstrapPrefix(bsPrefix, 'sidenav');
    const contextValue = useMemo(() => ({
        activeEventKey: activeKey,
        onSelect,
        alwaysOpen,
        activeLinkKey: activeNavLinkKey,
    }), [activeKey, onSelect, alwaysOpen, activeNavLinkKey]);
    return (React.createElement(context$1.Provider, { value: contextValue },
        React.createElement(SGDSWrapper, { as: Component, ref: ref, ...controlledProps, className: classNames(className, prefix, 'list-unstyled') })));
});
SideNav.displayName = 'SideNav';
SideNav.propTypes = propTypes$e;
var SideNav$1 = Object.assign(SideNav, {
    Button: SideNavButton,
    Collapse: SideNavCollapse,
    Item: SideNavItem,
    Link: SideNavLink,
});

const propTypes$d = {
    /**
     * An html id attribute for the Toggle button, necessary for assistive technologies, such as screen readers.
     * @type {string}
     * @required
     */
    id: PropTypes.string,
    /**
     * Accessible label for the toggle; the value of `title` if not specified.
     */
    toggleLabel: PropTypes.string,
    /** An `href` passed to the non-toggle Button */
    href: PropTypes.string,
    /** An anchor `target` passed to the non-toggle Button */
    target: PropTypes.string,
    /** An `onClick` handler passed to the non-toggle Button */
    onClick: PropTypes.func,
    /** The content of the non-toggle Button.  */
    title: PropTypes.node.isRequired,
    /** A `type` passed to the non-toggle Button */
    type: PropTypes.string,
    /** Disables both Buttons  */
    disabled: PropTypes.bool,
    /**
     * Aligns the dropdown menu.
     *
     * _see [DropdownMenu](#dropdown-menu-props) for more details_
     *
     * @type {"start"|"end"|{ sm: "start"|"end" }|{ md: "start"|"end" }|{ lg: "start"|"end" }|{ xl: "start"|"end"}|{ xxl: "start"|"end"} }
     */
    align: alignPropType,
    /** An ARIA accessible role applied to the Menu component. When set to 'menu', The dropdown */
    menuRole: PropTypes.string,
    /** Whether to render the dropdown menu in the DOM before the first time it is shown */
    renderMenuOnMount: PropTypes.bool,
    /**
     *  Which event when fired outside the component will cause it to be closed.
     *
     * _see [DropdownMenu](#dropdown-menu-props) for more details_
     */
    rootCloseEvent: PropTypes.string,
    /** @ignore */
    bsPrefix: PropTypes.string,
    /** @ignore */
    variant: PropTypes.string,
    /** @ignore */
    size: PropTypes.string,
};
const defaultProps$5 = {
    toggleLabel: 'Toggle dropdown',
    type: 'button',
};
/**
 * A convenience component for simple or general use split button dropdowns. Renders a
 * `ButtonGroup` containing a `Button` and a `Button` toggle for the `Dropdown`. All `children`
 * are passed directly to the default `Dropdown.Menu`. This component accepts all of [`Dropdown`'s
 * props](#dropdown-props).
 *
 * _All unknown props are passed through to the `Dropdown` component._
 * The Button `variant`, `size` and `bsPrefix` props are passed to the button and toggle,
 * and menu-related props are passed to the `Dropdown.Menu`
 */
const SplitButton = React.forwardRef(({ id, bsPrefix, size, variant, title, type, toggleLabel, children, onClick, href, target, menuRole, renderMenuOnMount, rootCloseEvent, ...props }, ref) => (React.createElement(Dropdown$1, { ref: ref, ...props, as: ButtonGroup },
    React.createElement(Button, { size: size, variant: variant, disabled: props.disabled, bsPrefix: bsPrefix, href: href, target: target, onClick: onClick, type: type }, title),
    React.createElement(Dropdown$1.Toggle, { split: true, id: id, size: size, variant: variant, disabled: props.disabled, childBsPrefix: bsPrefix },
        React.createElement("span", { className: "visually-hidden" }, toggleLabel),
        React.createElement("i", { className: "bi bi-chevron-down" })),
    React.createElement(Dropdown$1.Menu, { role: menuRole, renderOnMount: renderMenuOnMount, rootCloseEvent: rootCloseEvent }, children))));
SplitButton.propTypes = propTypes$d;
SplitButton.defaultProps = defaultProps$5;
SplitButton.displayName = 'SplitButton';

class WrappedStepMetadata {
    stepMetadata;
    index;
    constructor(stepMetadata, index) {
        this.stepMetadata = stepMetadata;
        this.index = index;
    }
    get component() {
        return this.stepMetadata.component;
    }
    get title() {
        return this.stepMetadata.title;
    }
    get step() {
        return this.index + 1;
    }
    get stepHeader() {
        return this.stepMetadata.stepHeader;
    }
    async onNextStep(onDone) {
        if (this.stepMetadata.onNextStep) {
            await this.stepMetadata.onNextStep(onDone);
        }
        else {
            await onDone();
        }
    }
    async onPreviousStep(onDone) {
        if (this.stepMetadata.onPreviousStep) {
            await this.stepMetadata.onPreviousStep(onDone);
        }
        else {
            await onDone();
        }
    }
    async onArrived() {
        if (this.stepMetadata.onArrived) {
            await this.stepMetadata.onArrived();
        }
    }
}
class WrappedStepsMetadata {
    wrappedStepMetadataArr;
    constructor(wrappedStepMetadataArr) {
        this.wrappedStepMetadataArr = wrappedStepMetadataArr;
    }
    get length() {
        return this.wrappedStepMetadataArr.length;
    }
    findByStep(step) {
        return this.wrappedStepMetadataArr.find((wrappedStepMetadata) => wrappedStepMetadata.step === step);
    }
    isFirstStep(step) {
        return step === 1;
    }
    isLastStep(step) {
        return step === this.length;
    }
    isWithinStepRange(step) {
        return step >= 1 && step <= this.length + 1;
    }
    get data() {
        return this.wrappedStepMetadataArr;
    }
}
function useStep(stepsMetadata) {
    const wrappedStepsMetadata = new WrappedStepsMetadata(stepsMetadata.map((stepMetadata, index) => new WrappedStepMetadata(stepMetadata, index)));
    const getStateMethod = () => {
        return useState({
            currentStep: 1,
        });
    };
    const [state, setState] = getStateMethod();
    useEffect(() => {
        runOnArrived();
    }, [state.currentStep]);
    const runOnArrived = async () => {
        const stepData = wrappedStepsMetadata.findByStep(state.currentStep);
        if (stepData) {
            await stepData.onArrived();
        }
    };
    const setStep = async (newStep) => {
        if (newStep === state.currentStep) {
            return;
        }
        const stepData = wrappedStepsMetadata.findByStep(state.currentStep);
        if (!stepData) {
            return;
        }
        if (!wrappedStepsMetadata.isWithinStepRange(newStep)) {
            return;
        }
        const onDoneMethod = async () => {
            setState({
                ...state,
                currentStep: newStep,
            });
        };
        if (newStep > state.currentStep) {
            await stepData.onNextStep(onDoneMethod);
        }
        if (newStep < state.currentStep) {
            await stepData.onPreviousStep(onDoneMethod);
        }
    };
    const nextStep = async () => {
        await setStep(state.currentStep + 1);
    };
    const prevStep = async () => {
        await setStep(state.currentStep - 1);
    };
    const getTitle = () => {
        const stepData = wrappedStepsMetadata.findByStep(state.currentStep);
        if (stepData) {
            return stepData.title;
        }
        return '';
    };
    const getComponent = () => {
        const stepData = wrappedStepsMetadata.findByStep(state.currentStep);
        if (stepData) {
            return stepData.component;
        }
    };
    const getNextButtonTitle = () => {
        if (wrappedStepsMetadata.isLastStep(state.currentStep)) {
            return 'Submit';
        }
        else {
            return 'Next';
        }
    };
    const getBackButtonTitle = () => {
        if (wrappedStepsMetadata.isFirstStep(state.currentStep)) {
            return null;
        }
        else {
            return 'Back';
        }
    };
    const reset = async () => {
        if (state.currentStep !== 1) {
            setState({
                ...state,
                currentStep: 1,
            });
        }
        else {
            await runOnArrived();
        }
    };
    return {
        state,
        stepsMetadata: wrappedStepsMetadata,
        nextStep,
        prevStep,
        setStep,
        getTitle,
        getComponent,
        getNextButtonTitle,
        getBackButtonTitle,
        reset,
    };
}

const propTypes$c = {
    methods: PropTypes.shape({
        state: PropTypes.shape({ currentStep: PropTypes.number }),
        stepsMetadata: PropTypes.instanceOf(WrappedStepsMetadata),
        nextStep: PropTypes.func,
        prevStep: PropTypes.func,
        setStep: PropTypes.func,
        getTitle: PropTypes.func,
        getComponent: PropTypes.func,
        getNextButtonTitle: PropTypes.func,
        getBackButtonTitle: PropTypes.func,
        reset: PropTypes.func,
    }).isRequired,
};
const Stepper = ({ methods }) => {
    const [stepperEl, stepperRef] = useCallbackRef$1();
    const { state, stepsMetadata, setStep } = methods;
    useEffect(() => {
        if (!stepperEl)
            return;
        stepperEl.querySelectorAll('.stepper-item').forEach(stepperItem => {
            stepperItem.addEventListener('keydown', e => {
                const keyDown = e.key;
                if (keyDown === 'Enter') {
                    e.preventDefault();
                    stepperItem.click();
                }
            });
        });
    }, [stepperEl]);
    const getClass = (stepMetadata) => {
        if (stepMetadata.step < state.currentStep) {
            return 'is-completed is-clickable';
        }
        if (stepMetadata.step === state.currentStep) {
            return 'is-active';
        }
        return '';
    };
    const back = (stepMetadata) => {
        return () => {
            if (stepMetadata.step < state.currentStep) {
                return setStep(stepMetadata.step);
            }
            return;
        };
    };
    return (React__default.createElement(SGDSWrapper, { ref: stepperRef, className: "stepper" }, stepsMetadata.data.map((stepMetadata) => (React__default.createElement("div", { "data-testid": "sgds-step", className: `stepper-item ${getClass(stepMetadata)}`, onClick: back(stepMetadata), key: stepMetadata.step, tabIndex: 0, "aria-current": stepMetadata.step === state.currentStep ? "step" : "false", "aria-disabled": stepMetadata.step >= state.currentStep },
        React__default.createElement("div", { className: "stepper-marker" }, stepMetadata.step),
        React__default.createElement("div", { className: "stepper-detail" },
            React__default.createElement("p", null,
                React__default.createElement("b", null, stepMetadata.stepHeader))))))));
};
Stepper.displayName = 'Stepper';
Stepper.propTypes = propTypes$c;

const TableRow = React.forwardRef(({ as: Component = 'tr', ...props }, ref) => {
    return (React.createElement(Component, { ...props, ref: ref }));
});
TableRow.displayName = 'TableRow';

const TableHeader = React.forwardRef(({ as: Component = 'thead', ...props }, ref) => {
    return (React.createElement(Component, { ...props, ref: ref }));
});
TableHeader.displayName = 'TableHeader';

const TableHeaderCell = React.forwardRef(({ as: Component = 'th', ...props }, ref) => {
    return (React.createElement(Component, { ...props, ref: ref }));
});
TableHeaderCell.displayName = 'TableHeaderCell';

const propTypes$b = {
    /**
     * Handles the click event on the sort label. User is expected to pass in the sort
     * handler function that will sort the respective table column.
     *
     * @param e The click event.
     */
    onClick: PropTypes.func,
    /**
     * Whether sorting is currently active on the column.
     */
    active: PropTypes.bool,
    /**
     * Whether the column is currently sorted by ascending ('asc') or descending ('desc') order.
     */
    direction: PropTypes.oneOf(['asc', 'desc']),
    as: PropTypes.elementType,
    bsPrefix: PropTypes.string,
};
const TableSortLabel = React.forwardRef(({ onClick, direction = 'asc', active = false, as: Component = 'span', ...props }, ref) => {
    const getIcon = () => {
        if (!active) {
            return React.createElement("i", { className: "bi bi-arrow-down-up ms-2 align-self-center" });
        }
        return direction === 'asc' ? (React.createElement("i", { className: "bi bi-sort-up-alt ms-2 align-self-center" })) : (React.createElement("i", { className: "bi bi-sort-down ms-2 align-self-center" }));
    };
    return (React.createElement(Component, { ...props, ref: ref, role: "button", tabIndex: "0", onClick: onClick },
        props.children,
        " ",
        getIcon()));
});
TableSortLabel.displayName = 'TableSortLabel';
TableSortLabel.propTypes = propTypes$b;

const TableBody = React.forwardRef(({ as: Component = 'tbody', ...props }, ref) => {
    return React.createElement(Component, { ...props, ref: ref });
});
TableBody.displayName = 'TableBody';

const TableDataCell = React.forwardRef(({ as: Component = 'td', ...props }, ref) => {
    return (React.createElement(Component, { ...props, ref: ref }));
});
TableDataCell.displayName = 'TableDataCell';

const propTypes$a = {
    /**
     * @default 'table'
     */
    bsPrefix: PropTypes.string,
    /**
   * Adds zebra-striping to any table row within the `<tbody>`.
   */
    striped: PropTypes.bool,
    /**
     * Adds borders on all sides of the table and cells.
     */
    bordered: PropTypes.bool,
    /**
     * Removes all borders on the table and cells, including table header.
     */
    borderless: PropTypes.bool,
    /**
     * Enable a hover state on table rows within a `<tbody>`.
     */
    hover: PropTypes.bool,
    /**
     * Make tables more compact by cutting cell padding in half by setting
     * size as `sm`.
     */
    size: PropTypes.string,
    /**
     * Invert the colors of the table — with light text on dark backgrounds
     * by setting variant as `dark`.
     */
    variant: PropTypes.string,
    /**
     * Responsive tables allow tables to be scrolled horizontally with ease.
     * Across every breakpoint, use `responsive` for horizontally
     * scrolling tables. Responsive tables are wrapped automatically in a `div`.
     * Use `responsive="sm"`, `responsive="md"`, `responsive="lg"`, or
     * `responsive="xl"` as needed to create responsive tables up to
     * a particular breakpoint. From that breakpoint and up, the table will
     * behave normally and not scroll horizontally.
     */
    responsive: PropTypes.oneOfType([PropTypes.bool, PropTypes.string]),
};
const Table = React.forwardRef(({ bsPrefix, className, striped, bordered, borderless, hover, size, variant, responsive, ...props }, ref) => {
    const decoratedBsPrefix = useBootstrapPrefix(bsPrefix, 'table');
    const classes = classNames(className, decoratedBsPrefix, variant && `${decoratedBsPrefix}-${variant}`, size && `${decoratedBsPrefix}-${size}`, striped && `${decoratedBsPrefix}-striped`, bordered && `${decoratedBsPrefix}-bordered`, borderless && `${decoratedBsPrefix}-borderless`, hover && `${decoratedBsPrefix}-hover`);
    const table = (React.createElement(SGDSWrapper, { as: "table", ...props, className: classes, ref: ref }));
    if (responsive) {
        let responsiveClass = `${decoratedBsPrefix}-responsive`;
        if (typeof responsive === 'string') {
            responsiveClass = `${responsiveClass}-${responsive}`;
        }
        return (React.createElement("div", { className: responsiveClass, tabIndex: 0 }, table));
    }
    return table;
});
Table.displayName = 'Table';
Table.propTypes = propTypes$a;
var Table$1 = Object.assign(Table, {
    Row: TableRow,
    Header: TableHeader,
    HeaderCell: TableHeaderCell,
    SortLabel: TableSortLabel,
    Body: TableBody,
    DataCell: TableDataCell,
});

const TabContent = createWithBsPrefix('sgds tab-content');

function getTabTransitionComponent(transition) {
    if (typeof transition === 'boolean') {
        return transition ? Fade : NoopTransition;
    }
    return transition;
}

const propTypes$9 = {
    /**
     * @default 'tab-pane'
     */
    bsPrefix: PropTypes.string,
    as: PropTypes.elementType,
    /**
     * A key that associates the `TabPane` with it's controlling `NavLink`.
     */
    eventKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    /**
     * Toggles the active state of the TabPane, this is generally controlled by a
     * TabContainer.
     */
    active: PropTypes.bool,
    /**
     * Use animation when showing or hiding `<TabPane>`s. Defaults to `<Fade>`
     * animation, else use `false` to disable or a react-transition-group
     * `<Transition/>` component.
     */
    transition: PropTypes.oneOfType([PropTypes.bool, PropTypes.elementType]),
    /**
     * Transition onEnter callback when animation is not `false`
     */
    onEnter: PropTypes.func,
    /**
     * Transition onEntering callback when animation is not `false`
     */
    onEntering: PropTypes.func,
    /**
     * Transition onEntered callback when animation is not `false`
     */
    onEntered: PropTypes.func,
    /**
     * Transition onExit callback when animation is not `false`
     */
    onExit: PropTypes.func,
    /**
     * Transition onExiting callback when animation is not `false`
     */
    onExiting: PropTypes.func,
    /**
     * Transition onExited callback when animation is not `false`
     */
    onExited: PropTypes.func,
    /**
     * Wait until the first "enter" transition to mount the tab (add it to the DOM)
     */
    mountOnEnter: PropTypes.bool,
    /**
     * Unmount the tab (remove it from the DOM) when it is no longer visible
     */
    unmountOnExit: PropTypes.bool,
    /** @ignore * */
    id: PropTypes.string,
    /** @ignore * */
    'aria-labelledby': PropTypes.string,
};
const TabPane = React.forwardRef(({ bsPrefix, transition, ...props }, ref) => {
    const [{ className, 
    // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
    as: Component = 'div', ...rest }, { isActive, onEnter, onEntering, onEntered, onExit, onExiting, onExited, mountOnEnter, unmountOnExit, transition: Transition = Fade, },] = useTabPanel({
        ...props,
        transition: getTabTransitionComponent(transition),
    });
    const { mdxType, originalType, contentLeft, contentRight, contentBottom, variant, ...attrs } = rest;
    const prefix = useBootstrapPrefix(bsPrefix, 'tab-pane');
    // We provide an empty the TabContext so `<Nav>`s in `<TabPanel>`s don't
    // conflict with the top level one.
    return (React.createElement(TabContext.Provider, { value: null },
        React.createElement(SelectableContext.Provider, { value: null },
            React.createElement(Transition, { in: isActive, onEnter: onEnter, onEntering: onEntering, onEntered: onEntered, onExit: onExit, onExiting: onExiting, onExited: onExited, mountOnEnter: mountOnEnter, unmountOnExit: unmountOnExit },
                React.createElement(Component, { ...attrs, ref: ref, className: classNames(className, prefix, isActive && 'active') })))));
});
TabPane.displayName = 'TabPane';
TabPane.propTypes = propTypes$9;

const propTypes$8 = {
    /**
     * Mark the Tab with a matching `eventKey` as active.
     *
     * @controllable onSelect
     */
    activeKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    /** The default active key that is selected on start */
    defaultActiveKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    /**
     * Navigation style
     *
     * @type {('tabs-basic-toggle'| 'tabs-info-toggle')}
     */
    variant: PropTypes.string,
    /**
     * Sets a default animation strategy for all children `<TabPane>`s.<tbcont
     *
     * Defaults to `<Fade>` animation, else use `false` to disable or a
     * react-transition-group `<Transition/>` component.
     *
     * @type {Transition | false}
     * @default {Fade}
     */
    transition: PropTypes.oneOfType([
        PropTypes.oneOf([false]),
        PropTypes.elementType,
    ]),
    /**
     * HTML id attribute, required if no `generateChildId` prop
     * is specified.
     *
     * @type {string}
     */
    id: PropTypes.string,
    /**
     * Callback fired when a Tab is selected.
     *
     * ```js
     * function (
     *   Any eventKey,
     *   SyntheticEvent event?
     * )
     * ```
     *
     * @controllable activeKey
     */
    onSelect: PropTypes.func,
    /**
     * Wait until the first "enter" transition to mount tabs (add them to the DOM)
     */
    mountOnEnter: PropTypes.bool,
    /**
     * Unmount tabs (remove it from the DOM) when it is no longer visible
     */
    unmountOnExit: PropTypes.bool,
};
const defaultProps$4 = {
    // variant: 'tabs',
    mountOnEnter: false,
    unmountOnExit: false,
};
function getDefaultActiveKey(children) {
    let defaultActiveKey;
    forEach(children, (child) => {
        if (defaultActiveKey == null) {
            defaultActiveKey = child.props.eventKey;
        }
    });
    return defaultActiveKey;
}
function renderTab(variant) {
    return (child) => {
        const { title, eventKey, disabled, tabClassName, tabAttrs, id, contentLeft, contentRight, contentBottom, } = child.props;
        if (title == null) {
            return null;
        }
        const tabsBasic = (React.createElement(React.Fragment, null,
            contentLeft,
            title,
            contentRight));
        const tabsInfo = (React.createElement(React.Fragment, null,
            React.createElement("div", { className: `tabs-info-label ${contentLeft ? 'has-icon' : ''}` },
                contentLeft,
                title),
            React.createElement("div", { className: "tabs-info-count" }, contentBottom)));
        return (React.createElement(NavItem, { as: "li", role: "presentation" },
            React.createElement(NavLink, { as: "button", type: "button", eventKey: eventKey, disabled: disabled, id: id, className: tabClassName, ...tabAttrs }, variant === 'tabs-info-toggle' ? tabsInfo : tabsBasic)));
    };
}
const Tabs = (props) => {
    const { id, variant, onSelect, transition, mountOnEnter, unmountOnExit, children, activeKey = getDefaultActiveKey(children), ...controlledProps } = useUncontrolled(props, {
        activeKey: 'onSelect',
    });
    return (React.createElement(BaseTabs, { id: id, activeKey: activeKey, onSelect: onSelect, transition: getTabTransitionComponent(transition), mountOnEnter: mountOnEnter, unmountOnExit: unmountOnExit },
        React.createElement(Nav$1, { ...controlledProps, role: "tablist", as: "ul", variant: props.variant }, map(children, renderTab(variant))),
        React.createElement(TabContent, null, map(children, (child) => {
            const childProps = { ...child.props };
            delete childProps.title;
            delete childProps.disabled;
            delete childProps.tabClassName;
            delete childProps.tabAttrs;
            return React.createElement(TabPane, { ...childProps });
        }))));
};
Tabs.propTypes = propTypes$8;
Tabs.defaultProps = defaultProps$4;
Tabs.displayName = 'Tabs';

const propTypes$7 = {
    /**
     * HTML id attribute, required if no `generateChildId` prop
     * is specified.
     *
     * @type {string}
     */
    id: PropTypes.string,
    /**
     * Sets a default animation strategy for all children `<TabPane>`s.
     * Defaults to `<Fade>` animation; else, use `false` to disable, or a
     * custom react-transition-group `<Transition/>` component.
     *
     * @type {{Transition | false}}
     * @default {Fade}
     */
    transition: PropTypes.oneOfType([
        PropTypes.oneOf([false]),
        PropTypes.elementType,
    ]),
    /**
     * Wait until the first "enter" transition to mount tabs (add them to the DOM)
     */
    mountOnEnter: PropTypes.bool,
    /**
     * Unmount tabs (remove it from the DOM) when they are no longer visible
     */
    unmountOnExit: PropTypes.bool,
    /**
     * A function that takes an `eventKey` and `type` and returns a unique id for
     * child tab `<NavItem>`s and `<TabPane>`s. The function _must_ be a pure
     * function, meaning it should always return the _same_ id for the same set
     * of inputs. The default value requires that an `id` to be set for the
     * `<TabContainer>`.
     *
     * The `type` argument will either be `"tab"` or `"pane"`.
     *
     * @defaultValue (eventKey, type) => `${props.id}-${type}-${eventKey}`
     */
    generateChildId: PropTypes.func,
    /**
     * A callback fired when a tab is selected.
     *
     * @controllable activeKey
     */
    onSelect: PropTypes.func,
    /**
     * The `eventKey` of the currently active tab.
     *
     * @controllable onSelect
     */
    activeKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
};
const TabContainer = ({ transition, ...props }) => (React.createElement(BaseTabs, { ...props, transition: getTabTransitionComponent(transition) }));
TabContainer.propTypes = propTypes$7;
TabContainer.displayName = 'TabContainer';

/* eslint-disable react/no-unused-prop-types */
const propTypes$6 = {
    eventKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    /**
     * Content for the tab title.
     */
    title: PropTypes.node.isRequired,
    /**
     * The disabled state of the tab.
     */
    disabled: PropTypes.bool,
    /**
     * Class to pass to the underlying nav link.
     */
    tabClassName: PropTypes.string,
    /**
     * Object containing attributes to pass to underlying nav link.
     */
    tabAttrs: PropTypes.object,
    /**
    * Content to the left of title.
    */
    contentLeft: PropTypes.node,
    /**
    * Content to the right of title. Not applicable to tabs-info-toggle variant.
    */
    contentRight: PropTypes.node,
    /**
     * Content to the bottom of title. Applicable to tabs-info-toggle variant only.
     */
    contentBottom: PropTypes.node,
};
const Tab = () => {
    throw new Error('ReactBootstrap: The `Tab` component is not meant to be rendered! ' +
        "It's an abstract component that is only valid as a direct Child of the `Tabs` Component. " +
        'For custom tabs components use TabPane and TabsContainer directly');
};
Tab.propTypes = propTypes$6;
var Tab$1 = Object.assign(Tab, {
    Container: TabContainer,
    Content: TabContent,
    Pane: TabPane,
});

const fadeStyles = {
    [ENTERING]: 'showing',
    [EXITING]: 'showing show',
};
const ToastFade = React.forwardRef((props, ref) => (React.createElement(Fade, { ...props, ref: ref, transitionClasses: fadeStyles })));
ToastFade.displayName = 'ToastFade';

const ToastContext = React.createContext({
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    onClose() { },
});

const propTypes$5 = {
    bsPrefix: PropTypes.string,
    /**
     * Provides an accessible label for the close
     * button. It is used for Assistive Technology when the label text is not
     * readable.
     */
    closeLabel: PropTypes.string,
    /**
     * Sets the variant for close button.
     */
    closeVariant: PropTypes.oneOf(['white']),
    /**
     * Specify whether the Component should contain a close button
     */
    closeButton: PropTypes.bool,
};
const defaultProps$3 = {
    closeLabel: 'Close',
    closeButton: true,
};
const ToastHeader = React.forwardRef(({ bsPrefix, closeLabel, closeVariant, closeButton, className, children, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'toast-header');
    const context = useContext(ToastContext);
    const handleClick = useEventCallback((e) => {
        context?.onClose?.(e);
    });
    return (React.createElement("div", { ref: ref, ...props, className: classNames(bsPrefix, className) },
        children,
        closeButton && (React.createElement(CloseButton, { "aria-label": closeLabel, variant: closeVariant, onClick: handleClick, "data-dismiss": "toast" }))));
});
ToastHeader.displayName = 'ToastHeader';
ToastHeader.propTypes = propTypes$5;
ToastHeader.defaultProps = defaultProps$3;

const ToastBody = createWithBsPrefix('toast-body');

const propTypes$4 = {
    /**
     * @default 'toast'
     */
    bsPrefix: PropTypes.string,
    /**
     * Apply a CSS fade transition to the toast
     */
    animation: PropTypes.bool,
    /**
     * Auto hide the toast
     */
    autohide: PropTypes.bool,
    /**
     * Delay hiding the toast (ms)
     */
    delay: PropTypes.number,
    /**
     * A Callback fired when the close button is clicked.
     */
    onClose: PropTypes.func,
    /**
     * When `true` The toast will show itself.
     */
    show: PropTypes.bool,
    /**
     * A `react-transition-group` Transition component used to animate the Toast on dismissal.
     */
    transition: PropTypes.elementType,
    /**
     * Sets Toast background
     *
     * @type {('primary'|'secondary'|'success'|'danger'|'warning'|'info'|'dark'|'light')}
     */
    bg: PropTypes.string,
    isSGDS: PropTypes.bool,
    status: PropTypes.oneOf(['success', 'warning', 'danger']),
};
const Toast = React.forwardRef(({ bsPrefix, className, transition: Transition = ToastFade, show = true, animation = true, delay = 5000, autohide = false, onClose, bg, isSGDS = true, status, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'toast');
    // We use refs for these, because we don't want to restart the autohide
    // timer in case these values change.
    const delayRef = useRef(delay);
    const onCloseRef = useRef(onClose);
    useEffect(() => {
        delayRef.current = delay;
        onCloseRef.current = onClose;
    }, [delay, onClose]);
    const autohideTimeout = useTimeout();
    const autohideToast = !!(autohide && show);
    const autohideFunc = useCallback(() => {
        if (autohideToast) {
            onCloseRef.current?.();
        }
    }, [autohideToast]);
    useEffect(() => {
        // Only reset timer if show or autohide changes.
        autohideTimeout.set(autohideFunc, delayRef.current);
    }, [autohideTimeout, autohideFunc]);
    const toastContext = useMemo(() => ({
        onClose,
    }), [onClose]);
    const hasAnimation = !!(Transition && animation);
    const toast = (React.createElement("div", { ...props, ref: ref, className: classNames(bsPrefix, className, bg && `bg-${bg}`, !hasAnimation && (show ? 'show' : 'hide'), isSGDS && 'sgds', status && `is-${status}`), role: "alert", "aria-live": "assertive", "aria-atomic": "true" }));
    return (React.createElement(ToastContext.Provider, { value: toastContext }, hasAnimation && Transition ? (React.createElement(Transition, { in: show, unmountOnExit: true }, toast)) : (toast)));
});
Toast.propTypes = propTypes$4;
Toast.displayName = 'Toast';
var Toast$1 = Object.assign(Toast, {
    Body: ToastBody,
    Header: ToastHeader,
});

const propTypes$3 = {
    /**
     * @default 'toast-container'
     */
    bsPrefix: PropTypes.string,
    /**Position of toasts placed within the container. */
    position: PropTypes.oneOf([
        'top-start',
        'top-center',
        'top-end',
        'middle-start',
        'middle-center',
        'middle-end',
        'bottom-start',
        'bottom-center',
        'bottom-end',
    ]),
};
const positionClasses = {
    'top-start': 'top-0 start-0',
    'top-center': 'top-0 start-50 translate-middle-x',
    'top-end': 'top-0 end-0',
    'middle-start': 'top-50 start-0 translate-middle-y',
    'middle-center': 'top-50 start-50 translate-middle',
    'middle-end': 'top-50 end-0 translate-middle-y',
    'bottom-start': 'bottom-0 start-0',
    'bottom-center': 'bottom-0 start-50 translate-middle-x',
    'bottom-end': 'bottom-0 end-0',
};
const ToastContainer = React.forwardRef(({ bsPrefix, position, className, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'div', ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'toast-container');
    return (React.createElement(SGDSWrapper, { ref: ref, ...props, className: classNames(bsPrefix, position && `position-absolute ${positionClasses[position]}`, className) }));
});
ToastContainer.displayName = 'ToastContainer';
ToastContainer.propTypes = propTypes$3;

const propTypes$2 = {
    /**
     * @default 'tooltip'
     */
    bsPrefix: PropTypes.string,
    /**
     * An html id attribute, necessary for accessibility
     * @type {string}
     * @required
     */
    id: PropTypes.string,
    /**
     * Sets the direction the Tooltip is positioned towards.
     *
     * > This is generally provided by the `Overlay` component positioning the tooltip
     */
    placement: PropTypes.oneOf([
        'auto-start',
        'auto',
        'auto-end',
        'top-start',
        'top',
        'top-end',
        'right-start',
        'right',
        'right-end',
        'bottom-end',
        'bottom',
        'bottom-start',
        'left-end',
        'left',
        'left-start',
    ]),
    /**
     * An Overlay injected set of props for positioning the tooltip arrow.
     *
     * > This is generally provided by the `Overlay` component positioning the tooltip
     *
     * @type {{ ref: ReactRef, style: Object }}
     */
    arrowProps: PropTypes.shape({
        ref: PropTypes.any,
        style: PropTypes.object,
    }),
    /** @private */
    popper: PropTypes.object,
    /** @private */
    show: PropTypes.any,
    closeBtn: PropTypes.element
};
const defaultProps$2 = {
    placement: 'right',
};
const TooltipBox = React.forwardRef(({ bsPrefix, placement, className, style, children, arrowProps, popper: _, show: _2, closeBtn, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'tooltip');
    const isRTL = useIsRTL();
    const [primaryPlacement] = placement?.split('-') || [];
    const bsDirection = getOverlayDirection(primaryPlacement, isRTL);
    return (React.createElement(SGDSWrapper, { ref: ref, style: style, role: "tooltip", "x-placement": primaryPlacement, className: classNames(className, bsPrefix, `bs-tooltip-${bsDirection}`), ...props },
        React.createElement("div", { className: "tooltip-arrow", ...arrowProps }),
        React.createElement("div", { className: `${bsPrefix}-inner` },
            children,
            closeBtn)));
});
TooltipBox.defaultProps = defaultProps$2;
TooltipBox.displayName = 'Tooltip';
TooltipBox.propTypes = propTypes$2;

const propTypes$1 = {
    placement: PropTypes.oneOf([
        'top-start',
        'bottom-start',
        'top',
        'bottom',
        'left',
        'right',
    ]),
    type: PropTypes.oneOf(['hover', 'click']),
    content: PropTypes.oneOfType([PropTypes.string]),
    children: PropTypes.element,
};
const defaultProps$1 = {
    placement: 'top',
    type: 'hover',
    content: '',
};
const Tooltip = ((props = defaultProps$1) => {
    const { type, placement, content, children } = props;
    const [show, setShow] = useState(false);
    const target = useRef(null);
    const [tooltipId, setTooltipId] = useState("");
    React.useEffect(() => {
        setTooltipId(generateId('tooltip', 'div'));
    }, []);
    const clickToolTip = () => (React.createElement(React.Fragment, null,
        React.cloneElement(children, {
            onClick: () => setShow(!show),
            ref: target,
            'aria-describedby': tooltipId,
        }),
        React.createElement(Overlay, { target: target.current, show: show, placement: placement }, (props) => (React.createElement(TooltipBox, { ...props, closeBtn: React.createElement(CloseButton, { variant: "white", onClick: () => setShow(!show) }), id: tooltipId }, content)))));
    // console.log((children as React.ReactElement).props);
    const hoverTooltip = () => (React.createElement(OverlayTrigger, { placement: placement, overlay: React.createElement(TooltipBox, { id: tooltipId, ...props }, content) }, React.cloneElement(children, {
        onClick: () => setShow(!show),
        ref: target,
        'aria-describedby': tooltipId,
    })));
    return type === 'hover' ? hoverTooltip() : clickToolTip();
});
Tooltip.defaultProps = defaultProps$1;
Tooltip.propTypes = propTypes$1;

const propTypes = {
    initialValue: PropTypes.string,
    onChangeInput: PropTypes.func,
    menuPlacement: PropTypes.oneOf(['up', 'down']),
    menuList: PropTypes.arrayOf(PropTypes.string).isRequired,
    label: PropTypes.string,
    icon: PropTypes.element
};
const defaultProps = {
    menuPlacement: 'down',
    initialValue: '',
};
const Combobox = React.forwardRef(({ menuPlacement = 'down', menuList, initialValue = '', onChangeInput, label = '', icon, ...props }, ref) => {
    const formControlRef = useRef(null);
    const inputRef = useMergedRefs(ref, formControlRef);
    const [menuOpen, setIsMenuOpen] = useState(undefined);
    const initialState = {
        value: initialValue,
        invalid: false,
        menuList: initialValue
            ? menuList.filter((n) => n.toLowerCase().startsWith(initialValue.toLowerCase()))
            : menuList,
    };
    const [state, setState] = useState(initialState);
    const handleChange = (e) => {
        if (!menuOpen) {
            formControlRef.current?.click();
        }
        const filterMenuList = menuList.filter((n) => {
            const nLowerCase = n.toLowerCase();
            const valueLower = e.currentTarget.value.toLowerCase();
            return nLowerCase.startsWith(valueLower);
        });
        setState({
            ...state,
            value: e.currentTarget.value,
            menuList: filterMenuList,
        });
        if (onChangeInput)
            onChangeInput(e.currentTarget.value, e);
    };
    const controlProps = {
        onChange: handleChange,
        value: state.value,
        ref: inputRef,
        isInvalid: state.invalid,
        ...props,
    };
    const handleClickItem = (e) => {
        if (onChangeInput)
            onChangeInput(e.currentTarget.textContent, e);
        setState({
            ...state,
            value: e.currentTarget.textContent,
            menuList: state.menuList.filter((c) => c === e.currentTarget.textContent),
        });
    };
    const focusDropdownItem = (event) => {
        setState({
            ...state,
            value: event.currentTarget.textContent,
        });
    };
    const [comboboxMenuId, setComboboxMenuId] = useState("");
    React.useEffect(() => {
        setComboboxMenuId(generateId('combobox', 'ul'));
    }, []);
    return (React.createElement(React.Fragment, null,
        label && React.createElement(FormLabel, { htmlFor: props.id }, label),
        React.createElement(Dropdown$1, { className: icon && 'combobox', focusFirstItemOnShow: false, drop: menuPlacement },
            React.createElement(FormControlToggle, { ...controlProps, setIsMenuOpen: setIsMenuOpen, role: "combobox", "aria-autocomplete": "list", "aria-controls": comboboxMenuId }),
            icon &&
                React.cloneElement(icon, {
                    className: classNames(icon.props.className, 'form-control-icon'),
                }),
            state.menuList.length > 0 && (React.createElement(DropdownMenu, { id: comboboxMenuId, role: "listbox" }, state.menuList.map((menuItem) => (React.createElement(DropdownItem, { as: "button", key: menuItem, onClick: handleClickItem, onFocus: focusDropdownItem }, menuItem))))))));
});
Combobox.displayName = 'Combobox';
Combobox.propTypes = propTypes;
Combobox.defaultProps = defaultProps;

export { Accordion$1 as Accordion, AccordionBody, AccordionButton, AccordionCollapse, context$8 as AccordionContext, AccordionHeader, AccordionItem, Alert$1 as Alert, AlertHeading, AlertLink, Badge, Breadcrumb$1 as Breadcrumb, BreadcrumbItem, Button, ButtonGroup, Card$1 as Card, CardBody, CardFooter, CardGroup, CardHeader, CardImg, CardImgOverlay, CardLink, CardStretchedLink, CardSubtitle, CardText, CardTitle, CardUnit, CloseButton, Col, Collapse, Combobox, Container, DatePicker, Dropdown$1 as Dropdown, DropdownButton, DropdownDivider, DropdownHeader, DropdownItem, DropdownItemText, DropdownMenu, DropdownToggle, Fade, Feedback, FileUpload, Footer$1 as Footer, FooterBottom$1 as FooterBottom, FooterBottomCopyrights, FooterBottomLinks, FooterSection as FooterTop, FooterTopContactLinks, FooterTopHeader, FooterTopItem, FooterTopItemGroup, Form$1 as Form, FormCheck$1 as FormCheck, FormCheckInput, FormCheckLabel, FormControl$1 as FormControl, FormControlGroup, FormGroup, FormLabel, FormSelect, Switch$1 as FormSwitch, FormText, InputGroup$1 as InputGroup, InputGroupCheckbox, InputGroupRadio, InputGroupText, Modal$1 as Modal, ModalBody, ModalDialog, ModalFooter, ModalHeader, ModalTitle, Nav$1 as Nav, NavDropdown$1 as NavDropdown, NavItem, NavLink, Navbar$1 as Navbar, NavbarBrand, NavbarCollapse, NavbarText, NavbarToggle, Overlay, OverlayTrigger, Pagination, Popover$1 as Popover, PopoverBody, PopoverHeader, ProgressBar, QuantityToggle, Row, SelectableCard, SideNav$1 as SideNav, SideNavButton, SideNavCollapse, SideNavItem, SideNavLink, SplitButton, Stepper, Tab$1 as Tab, TabContainer, TabContent, TabPane, Table$1 as Table, TableBody, TableDataCell, TableHeader, TableHeaderCell, TableRow, TableSortLabel, Tabs, ThemeProvider, Toast$1 as Toast, ToastBody, ToastContainer, ToastHeader, Tooltip, TooltipBox, useAccordionButton, useStep };
