'use client';
import classNames from 'classnames';
import PropTypes from 'prop-types';
import * as React from 'react';
import { useContext, useMemo } from 'react';
import BaseDropdown from '@restart/ui/Dropdown';
import { useUncontrolled } from 'uncontrollable';
import useEventCallback from '@restart/hooks/useEventCallback';
import { useDropdownItem } from '@restart/ui/DropdownItem';
import Anchor from '@restart/ui/Anchor';
import { useDropdownMenu } from '@restart/ui/DropdownMenu';
import useIsomorphicEffect from '@restart/hooks/useIsomorphicEffect';
import useMergedRefs from '@restart/hooks/useMergedRefs';
import warning from 'warning';
import { alignPropType, alignDirection } from '../utils/types';
import useWrappedRefWithWarning from '../utils/useWrappedRefWithWarning';
import { useDropdownToggle } from '@restart/ui/DropdownToggle';
import DropdownContext$1 from '@restart/ui/DropdownContext';
import { useButtonProps } from '@restart/ui/Button';
import createWithBsPrefix from '../utils/createWithBsPrefix';

const DropdownContext = React.createContext({});
DropdownContext.displayName = 'DropdownContext';

const propTypes$5 = {
    /** @default 'dropdown-item' */
    bsPrefix: PropTypes.string,
    /**
     * Highlight the menu item as active.
     */
    active: PropTypes.bool,
    /**
     * Disable the menu item, making it unselectable.
     */
    disabled: PropTypes.bool,
    /**
     * Value passed to the `onSelect` handler, useful for identifying the selected menu item.
     */
    eventKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    /**
     * HTML `href` attribute corresponding to `a.href`.
     */
    href: PropTypes.string,
    /**
     * Callback fired when the menu item is clicked.
     */
    onClick: PropTypes.func,
    as: PropTypes.elementType,
};
const DropdownItem = React.forwardRef(({ bsPrefix, className, eventKey, disabled = false, onClick, active, as: Component = Anchor, ...props }, ref) => {
    const prefix = 'dropdown-item';
    const [dropdownItemProps, meta] = useDropdownItem({
        key: eventKey,
        href: props.href,
        disabled,
        onClick,
        active,
    });
    return (React.createElement("li", null,
        React.createElement(Component, { ...props, ...dropdownItemProps, ref: ref, className: classNames(className, prefix, meta.isActive && 'active', disabled && 'disabled') })));
});
DropdownItem.displayName = 'DropdownItem';
DropdownItem.propTypes = propTypes$5;

const context$1 = React.createContext(null);
context$1.displayName = 'InputGroupContext';

const context = React.createContext(null);
context.displayName = 'NavbarContext';

const propTypes$4 = {
    /**
     * @default 'dropdown-menu'
     */
    bsPrefix: PropTypes.string,
    /** Controls the visibility of the Dropdown menu  */
    show: PropTypes.bool,
    /** Whether to render the dropdown menu in the DOM before the first time it is shown */
    renderOnMount: PropTypes.bool,
    /** Have the dropdown switch to it's opposite placement when necessary to stay on screen. */
    flip: PropTypes.bool,
    /**
     * Aligns the dropdown menu to the specified side of the container. You can also align
     * the menu responsively for breakpoints starting at `sm` and up. The alignment
     * direction will affect the specified breakpoint or larger.
     *
     * *Note: Using responsive alignment will disable Popper usage for positioning.*
     *
     * @type {"start"|"end"|{ sm: "start"|"end" }|{ md: "start"|"end" }|{ lg: "start"|"end" }|{ xl: "start"|"end"}|{ xxl: "start"|"end"} }
     */
    align: alignPropType,
    onSelect: PropTypes.func,
    /**
     * Which event when fired outside the component will cause it to be closed
     *
     * *Note: For custom dropdown components, you will have to pass the
     * `rootCloseEvent` to `<RootCloseWrapper>` in your custom dropdown menu
     * component ([similarly to how it is implemented in `<Dropdown.Menu>`](https://github.com/react-bootstrap/react-bootstrap/blob/v0.31.5/src/DropdownMenu.js#L115-L119)).*
     */
    rootCloseEvent: PropTypes.oneOf(['click', 'mousedown']),
    /**
     * Control the rendering of the DropdownMenu. All non-menu props
     * (listed here) are passed through to the `as` Component.
     *
     * If providing a custom, non DOM, component. the `show`, `close` and `align` props
     * are also injected and should be handled appropriately.
     */
    as: PropTypes.elementType,
    /**
     * A set of popper options and props passed directly to Popper.
     */
    popperConfig: PropTypes.object,
    /**
     * Menu color variant.
     *
     * Omitting this will use the default light color.
     */
    variant: PropTypes.string,
    /** @private Provides context when used in NavDropdown component  */
    isNav: PropTypes.bool,
};
const defaultProps$2 = {
    flip: true,
};
function getDropdownMenuPlacement(alignEnd, dropDirection, isRTL) {
    const topStart = isRTL ? 'top-end' : 'top-start';
    const topEnd = isRTL ? 'top-start' : 'top-end';
    const bottomStart = isRTL ? 'bottom-end' : 'bottom-start';
    const bottomEnd = isRTL ? 'bottom-start' : 'bottom-end';
    // const leftStart = isRTL ? 'right-start' : 'left-start';
    // const leftEnd = isRTL ? 'right-end' : 'left-end';
    const rightStart = isRTL ? 'left-start' : 'right-start';
    const rightEnd = isRTL ? 'left-end' : 'right-end';
    let placement = alignEnd ? bottomEnd : bottomStart;
    if (dropDirection === 'up')
        placement = alignEnd ? topEnd : topStart;
    else if (dropDirection === 'end')
        placement = alignEnd ? rightEnd : rightStart;
    // else if (dropDirection === 'start')
    //   placement = alignEnd ? leftEnd : leftStart;
    return placement;
}
const DropdownMenu = React.forwardRef(({ bsPrefix, className, align, rootCloseEvent, flip, show: showProps, renderOnMount, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'ul', popperConfig, variant, isNav, ...props }, ref) => {
    let alignEnd = false;
    const isNavbar = useContext(context);
    const prefix = 'dropdown-menu';
    const { align: contextAlign, drop, isRTL } = useContext(DropdownContext);
    align = align || contextAlign;
    const isInputGroup = useContext(context$1);
    const alignClasses = [];
    if (align) {
        if (typeof align === 'object') {
            const keys = Object.keys(align);
            warning(keys.length === 1, 'There should only be 1 breakpoint when passing an object to `align`');
            if (keys.length) {
                const brkPoint = keys[0];
                const direction = align[brkPoint];
                // .dropdown-menu-end is required for responsively aligning
                // left in addition to align left classes.
                alignEnd = direction === 'start';
                alignClasses.push(`${prefix}-${brkPoint}-${direction}`);
            }
        }
        else if (align === 'end') {
            alignEnd = true;
        }
    }
    const placement = getDropdownMenuPlacement(alignEnd, drop, isRTL);
    const [menuProps, { hasShown, popper, show, toggle }] = useDropdownMenu({
        flip,
        rootCloseEvent,
        show: showProps,
        usePopper: !isNavbar && alignClasses.length === 0,
        offset: !isNav ? [0, 10] : undefined,
        popperConfig,
        placement,
    });
    menuProps.ref = useMergedRefs(useWrappedRefWithWarning(ref, 'DropdownMenu'), menuProps.ref);
    useIsomorphicEffect(() => {
        // Popper's initial position for the menu is incorrect when
        // renderOnMount=true. Need to call update() to correct it.
        if (show)
            popper?.update();
    }, [show]);
    if (!hasShown && !renderOnMount && !isInputGroup)
        return null;
    // For custom components provide additional, non-DOM, props;
    if (typeof Component !== 'string') {
        menuProps.show = show;
        menuProps.close = () => toggle?.(false);
        menuProps.align = align;
    }
    let style = props.style;
    if (popper?.placement) {
        // we don't need the default popper style,
        // menus are display: none when not shown.
        style = { ...props.style, ...menuProps.style };
        //@ts-ignore
        props['x-placement'] = popper.placement;
    }
    return (React.createElement(Component, { ...props, ...menuProps, style: style, ...((alignClasses.length || isNavbar) && {
            'data-bs-popper': 'static',
        }), className: classNames(className, prefix, show && 'show', alignEnd && `${prefix}-end`, variant && `${prefix}-${variant}`, ...alignClasses) }));
});
DropdownMenu.displayName = 'DropdownMenu';
DropdownMenu.propTypes = propTypes$4;
DropdownMenu.defaultProps = defaultProps$2;

const ThemeContext = React.createContext({ prefixes: {} });
({
    prefixes: PropTypes.object,
    dir: PropTypes.string,
});
function useBootstrapPrefix(prefix, defaultPrefix) {
    const { prefixes } = useContext(ThemeContext);
    return prefix || prefixes[defaultPrefix] || `${defaultPrefix}`;
}
// `sgds-${defaultPrefix}`
function useIsRTL() {
    const { dir } = useContext(ThemeContext);
    return dir === 'rtl';
}
const SGDSWrapper = React.forwardRef(({ as: Tag = 'div', ...props }, ref) => {
    return React.createElement(Tag, { ref: ref, ...props, className: classNames(props.className, 'sgds') });
});

const propTypes$3 = {
    /**
     * @default 'btn'
     */
    bsPrefix: PropTypes.string,
    /**
     * One or more button variant combinations
     *
     * buttons may be one of a variety of visual variants such as:
     *
     * `'primary', 'secondary', 'success', 'danger', 'warning', 'info', 'dark', 'light', 'link'`
     *
     * as well as "outline" versions (prefixed by 'outline-*')
     *
     * `'outline-primary', 'outline-secondary', 'outline-success', 'outline-danger', 'outline-warning', 'outline-info', 'outline-dark', 'outline-light'`
     */
    variant: PropTypes.string,
    /**
     * Specifies a large or small button.
     *
     * @type ('sm'|'lg')
     */
    size: PropTypes.string,
    /** Manually set the visual state of the button to `:active` */
    active: PropTypes.bool,
    /**
     * Disables the Button, preventing mouse events,
     * even if the underlying component is an `<a>` element
     */
    disabled: PropTypes.bool,
    /** Providing a `href` will render an `<a>` element, _styled_ as a button. */
    href: PropTypes.string,
    /**
     * Defines HTML button type attribute.
     *
     * @default 'button'
     */
    type: PropTypes.oneOf(['button', 'reset', 'submit', null]),
    as: PropTypes.elementType,
};
const defaultProps$1 = {
    variant: 'primary',
    active: false,
    disabled: false,
};
const Button = React.forwardRef(({ as, bsPrefix, variant, size, active, className, ...props }, ref) => {
    const prefix = useBootstrapPrefix(bsPrefix, 'btn');
    const [buttonProps, { tagName }] = useButtonProps({
        tagName: as,
        ...props,
    });
    const Component = tagName;
    return (React.createElement(SGDSWrapper, { as: Component, ...props, ...buttonProps, ref: ref, className: classNames(className, prefix, active && 'active', variant && `${prefix}-${variant}`, size && `${prefix}-${size}`, props.href && props.disabled && 'disabled') }));
});
Button.displayName = 'Button';
Button.propTypes = propTypes$3;
Button.defaultProps = defaultProps$1;

const propTypes$2 = {
    /**
     * @default 'dropdown-toggle'
     */
    bsPrefix: PropTypes.string,
    /**
     * An html id attribute, necessary for assistive technologies, such as screen readers.
     * @type {string|number}
     */
    id: PropTypes.string,
    split: PropTypes.bool,
    as: PropTypes.elementType,
    /**
     * to passthrough to the underlying button or whatever from DropdownButton
     * @private
     */
    childBsPrefix: PropTypes.string,
};
const DropdownToggle = React.forwardRef(({ bsPrefix, split, className, childBsPrefix, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = Button, ...props }, ref) => {
    const prefix = 'dropdown-toggle';
    const dropdownContext = useContext(DropdownContext$1);
    const isInputGroup = useContext(context$1);
    if (childBsPrefix !== undefined) {
        props.bsPrefix = childBsPrefix;
    }
    const [toggleProps] = useDropdownToggle();
    toggleProps.ref = useMergedRefs(toggleProps.ref, useWrappedRefWithWarning(ref, 'DropdownToggle'));
    // This intentionally forwards size and variant (if set) to the
    // underlying component, to allow it to render size and style variants.
    return (React.createElement(Component, { className: classNames(className, prefix, split && `${prefix}-split`, !!isInputGroup && dropdownContext?.show && 'show'), variant: "outline-secondary", ...toggleProps, ...props, "aria-haspopup": "menu" }));
});
DropdownToggle.displayName = 'DropdownToggle';
DropdownToggle.propTypes = propTypes$2;

const DropdownHeader = createWithBsPrefix('dropdown-header', {
    defaultProps: { role: 'heading' },
});
const DropdownDivider = createWithBsPrefix('dropdown-divider', {
    Component: 'hr',
    defaultProps: { role: 'separator' },
});
const DropdownItemText = createWithBsPrefix('dropdown-item-text', {
    Component: 'span',
});

const propTypes$1 = {
    /** @default 'dropdown' */
    bsPrefix: PropTypes.string,
    /**
     * Determines the direction and location of the Menu in relation to it's Toggle.
     *
     * @type {"end"|"up"|"down" }
     */
    drop: PropTypes.oneOf(['up', 'end', 'down']),
    as: PropTypes.elementType,
    align: alignDirection,
    /**
     * Whether or not the Dropdown is visible.
     *
     * @controllable onToggle
     */
    show: PropTypes.bool,
    /**
     * Allow Dropdown to flip in case of an overlapping on the reference element. For more information refer to
     * Popper.js's flip [docs](https://popper.js.org/docs/v2/modifiers/flip/).
     *
     */
    flip: PropTypes.bool,
    /**
     * A callback fired when the Dropdown wishes to change visibility. Called with the requested
     * `show` value, the DOM event, and the source that fired it: `'click'`,`'keydown'`,`'rootClose'`, or `'select'`.
     *
     * ```js
     * function(
     *   isOpen: boolean,
     *   event: SyntheticEvent,
     *   metadata: {
     *     source: 'select' | 'click' | 'rootClose' | 'keydown'
     *   }
     * ): void
     * ```
     *
     * @controllable show
     */
    onToggle: PropTypes.func,
    /**
     * A callback fired when a menu item is selected.
     *
     * ```js
     * (eventKey: any, event: Object) => any
     * ```
     */
    onSelect: PropTypes.func,
    /**
     * Controls the focus behavior for when the Dropdown is opened. Set to
     * `true` to always focus the first menu item, `keyboard` to focus only when
     * navigating via the keyboard, or `false` to disable completely
     *
     * The Default behavior is `false` **unless** the Menu has a `role="menu"`
     * where it will default to `keyboard` to match the recommended [ARIA Authoring practices](https://www.w3.org/TR/wai-aria-practices-1.1/#menubutton).
     */
    focusFirstItemOnShow: PropTypes.oneOf([false, true, 'keyboard']),
    /** @private */
    navbar: PropTypes.bool,
    /**
     * Controls the auto close behaviour of the dropdown when clicking outside of
     * the button or the list.
     */
    autoClose: PropTypes.oneOf([true, 'outside', 'inside', false]),
};
const defaultProps = {
    navbar: false,
    align: 'start',
    autoClose: true,
    focusFirstItemOnShow: 'keyboard',
};
const Dropdown = React.forwardRef((pProps, ref) => {
    const { bsPrefix, drop, show, className, align, onSelect, onToggle, focusFirstItemOnShow, 
    // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
    as: Component = 'div', navbar: _4, autoClose, ...props } = useUncontrolled(pProps, { show: 'onToggle' });
    const isInputGroup = useContext(context$1);
    const prefix = useBootstrapPrefix(bsPrefix, 'dropdown');
    const isRTL = useIsRTL();
    const isClosingPermitted = (source) => {
        // autoClose=false only permits close on button click
        if (autoClose === false)
            return source === 'click';
        // autoClose=inside doesn't permit close on rootClose
        if (autoClose === 'inside')
            return source !== 'rootClose';
        // autoClose=outside doesn't permit close on select
        if (autoClose === 'outside')
            return source !== 'select';
        return true;
    };
    const handleToggle = useEventCallback((nextShow, meta) => {
        if (meta.originalEvent.currentTarget === document &&
            (meta.source !== 'keydown' ||
                meta.originalEvent.key === 'Escape'))
            meta.source = 'rootClose';
        if (isClosingPermitted(meta.source))
            onToggle?.(nextShow, meta);
    });
    const alignEnd = align === 'end';
    const placement = getDropdownMenuPlacement(alignEnd, drop, isRTL);
    const contextValue = useMemo(() => ({
        align,
        drop,
        isRTL,
    }), [align, drop, isRTL]);
    return (React.createElement(DropdownContext.Provider, { value: contextValue },
        React.createElement(BaseDropdown, { placement: placement, show: show, onSelect: onSelect, onToggle: handleToggle, focusFirstItemOnShow: focusFirstItemOnShow, itemSelector: `.${prefix}-item:not(.disabled):not(:disabled)` }, isInputGroup ? (props.children) : (React.createElement(SGDSWrapper, { as: Component, ...props, ref: ref, className: classNames(className, show && 'show', prefix, drop === 'up' && 'dropup', drop === 'end' && 'dropend') })))));
});
Dropdown.displayName = 'Dropdown';
Dropdown.propTypes = propTypes$1;
Dropdown.defaultProps = defaultProps;
var Dropdown$1 = Object.assign(Dropdown, {
    Toggle: DropdownToggle,
    Menu: DropdownMenu,
    Item: DropdownItem,
    ItemText: DropdownItemText,
    Divider: DropdownDivider,
    Header: DropdownHeader,
});

const propTypes = {
    /**
     * An html id attribute for the Toggle button, necessary for assistive technologies, such as screen readers.
     * @type {string}
     */
    id: PropTypes.string,
    /** An `href` passed to the Toggle component */
    href: PropTypes.string,
    /** An `onClick` handler passed to the Toggle component */
    onClick: PropTypes.func,
    /** The content of the non-toggle Button.  */
    title: PropTypes.node.isRequired,
    /** Disables both Buttons  */
    disabled: PropTypes.bool,
    /**
     * Aligns the dropdown menu.
     *
     * _see [DropdownMenu](#dropdown-menu-props) for more details_
     *
     * @type {"start"|"end"|{ sm: "start"|"end" }|{ md: "start"|"end" }|{ lg: "start"|"end" }|{ xl: "start"|"end"}|{ xxl: "start"|"end"} }
     */
    align: alignPropType,
    /** An ARIA accessible role applied to the Menu component. When set to 'menu', The dropdown */
    menuRole: PropTypes.string,
    /** Whether to render the dropdown menu in the DOM before the first time it is shown */
    renderMenuOnMount: PropTypes.bool,
    /**
     *  Which event when fired outside the component will cause it to be closed.
     *
     * _see [DropdownMenu](#dropdown-menu-props) for more details_
     */
    rootCloseEvent: PropTypes.string,
    /**
     * Menu color variant.
     *
     * Omitting this will use the default light color.
     */
    menuVariant: PropTypes.oneOf(['dark']),
    /** @ignore */
    bsPrefix: PropTypes.string,
    /** @ignore */
    variant: PropTypes.string,
    /** @ignore */
    size: PropTypes.string,
};
/**
 * A convenience component for simple or general use dropdowns. Renders a `Button` toggle and all `children`
 * are passed directly to the default `Dropdown.Menu`. This component accepts all of
 * [`Dropdown`'s props](#dropdown-props).
 *
 * _All unknown props are passed through to the `Dropdown` component._ Only
 * the Button `variant`, `size` and `bsPrefix` props are passed to the toggle,
 * along with menu-related props are passed to the `Dropdown.Menu`
 */
const DropdownButton = React.forwardRef(({ title, children, bsPrefix, rootCloseEvent, variant, size, menuRole, renderMenuOnMount, disabled, href, id, menuVariant, ...props }, ref) => (React.createElement(Dropdown$1, { ref: ref, ...props },
    React.createElement(DropdownToggle, { id: id, href: href, size: size, variant: variant, disabled: disabled, childBsPrefix: bsPrefix },
        title,
        React.createElement("i", { className: "bi bi-chevron-down" })),
    React.createElement(DropdownMenu, { role: menuRole, renderOnMount: renderMenuOnMount, rootCloseEvent: rootCloseEvent, variant: menuVariant }, children))));
DropdownButton.displayName = 'DropdownButton';
DropdownButton.propTypes = propTypes;

export { Dropdown$1 as Dropdown, DropdownButton, DropdownDivider, DropdownHeader, DropdownItem, DropdownItemText, DropdownMenu, DropdownToggle };
