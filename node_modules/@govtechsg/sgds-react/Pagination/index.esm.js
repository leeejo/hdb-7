'use client';
import * as React from 'react';
import { useContext } from 'react';
import classNames from 'classnames';
import PropTypes from 'prop-types';
import Anchor from '@restart/ui/Anchor';

const ThemeContext = React.createContext({ prefixes: {} });
({
    prefixes: PropTypes.object,
    dir: PropTypes.string,
});
function useBootstrapPrefix(prefix, defaultPrefix) {
    const { prefixes } = useContext(ThemeContext);
    return prefix || prefixes[defaultPrefix] || `${defaultPrefix}`;
}
const SGDSWrapper = React.forwardRef(({ as: Tag = 'div', ...props }, ref) => {
    return React.createElement(Tag, { ref: ref, ...props, className: classNames(props.className, 'sgds') });
});

/* eslint-disable react/no-multi-comp */
const propTypes$1 = {
    /** Disables the PageItem */
    disabled: PropTypes.bool,
    /** Styles PageItem as active, and renders a `<span>` instead of an `<a>`. */
    active: PropTypes.bool,
    /** A callback function for when this component is clicked */
    onClick: PropTypes.func,
    /** An accessible label indicating the active state.. */
    activeLabel: PropTypes.string,
};
const defaultProps = {
    active: false,
    disabled: false,
    activeLabel: '(current)',
};
const PageItem = React.forwardRef(({ active, disabled, className, style, children, activeLabel, ...props }, ref) => {
    const Component = active || disabled ? 'span' : Anchor;
    return (React.createElement("li", { ref: ref, style: style, className: classNames(className, 'page-item', { active, disabled }) },
        React.createElement(Component, { className: "page-link", disabled: disabled, ...props },
            children,
            active && activeLabel && (React.createElement("span", { className: "visually-hidden" }, activeLabel)))));
});
PageItem.propTypes = propTypes$1;
PageItem.defaultProps = defaultProps;
PageItem.displayName = 'PageItem';
function createButton(name, defaultValue, label = name) {
    const Button = React.forwardRef(({ children, ...props }, ref) => (React.createElement(PageItem, { ...props, ref: ref },
        React.createElement("span", { "aria-hidden": "true" }, children || defaultValue),
        React.createElement("span", { className: "visually-hidden" }, label))));
    Button.displayName = name;
    return Button;
}
const First = createButton('First', '«');
const Prev = createButton('Previous', '‹');
const Ellipsis = createButton('Ellipsis', '…');
const Next = createButton('Next', '›');
const Last = createButton('Last', '»');

const propTypes = {
    /**
     * @default 'pagination'
     * */
    bsPrefix: PropTypes.string,
    /**
     * Set's the size of all PageItems.
     *
     * @type {('sm' | 'md' | lg')}
     */
    size: PropTypes.oneOf(['sm', 'md', 'lg']),
};
/**
 * @property {PageItem} Item
 * @property {PageItem} First
 * @property {PageItem} Prev
 * @property {PageItem} Ellipsis
 * @property {PageItem} Next
 * @property {PageItem} Last
 */
const PaginationBase = React.forwardRef(({ bsPrefix, className, size, ...props }, ref) => {
    const decoratedBsPrefix = useBootstrapPrefix(bsPrefix, 'pagination');
    return (React.createElement(SGDSWrapper, { as: 'nav', "aria-label": 'Page Navigation' },
        React.createElement("ul", { ref: ref, ...props, className: classNames(className, decoratedBsPrefix, size && `${decoratedBsPrefix}-${size}`) })));
});
PaginationBase.propTypes = propTypes;
PaginationBase.displayName = 'PaginationBase';
var PaginationBase$1 = Object.assign(PaginationBase, {
    First,
    Prev,
    Ellipsis,
    Item: PageItem,
    Next,
    Last,
});

const Pagination = ({ dataLength = 0, currentPage = 1, itemsPerPage = 5, limit = 3, setCurrentPage, directionVariant = 'icon-text', size = 'sm', ellipsisOn = false, ellipsisJump = 3, }) => {
    // set the id of page item clicked to currentPage
    const handlePageClick = (event) => {
        const liTarget = event.target;
        setCurrentPage(Number(liTarget.id));
    };
    const pages = [];
    for (let i = 1; i <= Math.ceil(dataLength / itemsPerPage); i++) {
        pages.push(i);
    }
    const sanitizeLimit = limit >= pages.length ? pages.length : limit;
    const renderPgNumbers = () => {
        const pagesToShow = [];
        let sanitizeStartPage = 1;
        let endPage;
        if (limit < pages.length)
            sanitizeStartPage = currentPage - Math.floor(sanitizeLimit / 2);
        if (pages.length - sanitizeStartPage < limit)
            sanitizeStartPage = pages.length + 1 - limit;
        if (sanitizeStartPage <= 0)
            sanitizeStartPage = 1;
        endPage = sanitizeStartPage + sanitizeLimit - 1;
        if (endPage > pages.length)
            endPage = pages.length;
        if (currentPage === pages.length)
            sanitizeStartPage = pages.length - sanitizeLimit + 1;
        for (let i = sanitizeStartPage; i <= endPage; i++) {
            pagesToShow.push(i);
        }
        return pagesToShow.map((number) => (React.createElement(PaginationBase$1.Item, { key: number, id: number.toString(), onClick: handlePageClick, className: currentPage == number ? 'active' : undefined }, number)));
    };
    const handleNextButton = () => {
        setCurrentPage(currentPage + 1);
    };
    const handlePrevButton = () => {
        setCurrentPage(currentPage - 1);
    };
    // handleclick for ellipsisOn
    const handleNextEllipsisButton = () => {
        setCurrentPage(currentPage + ellipsisJump);
        if (currentPage + ellipsisJump > pages.length)
            setCurrentPage(pages.length);
    };
    const handlePrevEllipsisButton = () => {
        setCurrentPage(currentPage - ellipsisJump);
        if (currentPage - ellipsisJump < 1)
            setCurrentPage(1);
    };
    const renderLastEllipsis = () => {
        const isEvenLimit = sanitizeLimit % 2 === 0;
        const differentialLimitCondition = isEvenLimit
            ? currentPage + Math.floor(sanitizeLimit / 2) <= pages.length
            : currentPage + Math.floor(sanitizeLimit / 2) < pages.length;
        if (pages.length !== sanitizeLimit && differentialLimitCondition)
            return (React.createElement(PaginationBase$1.Ellipsis, { onClick: handleNextEllipsisButton, disabled: !ellipsisOn }));
        else
            return null;
    };
    const renderFirstEllipsis = () => {
        if (pages.length !== sanitizeLimit &&
            currentPage - Math.floor(sanitizeLimit / 2) > 1)
            return React.createElement(PaginationBase$1.Ellipsis, { onClick: handlePrevEllipsisButton });
        else
            return null;
    };
    const directionBtnContent = (directionLabel, iconClass) => {
        return (React.createElement(React.Fragment, null,
            directionVariant !== 'icon' &&
                directionLabel === 'Next' &&
                directionLabel,
            directionVariant === 'text' ? null : React.createElement("i", { className: iconClass }),
            directionVariant !== 'icon' &&
                directionLabel === 'Previous' &&
                directionLabel));
    };
    return (React.createElement(PaginationBase$1, { size: size },
        React.createElement(PaginationBase$1.Prev, { onClick: handlePrevButton, disabled: currentPage <= 1 }, directionBtnContent('Previous', 'bi bi-chevron-left')),
        ellipsisOn ? renderFirstEllipsis() : null,
        renderPgNumbers(),
        renderLastEllipsis(),
        React.createElement(PaginationBase$1.Next, { onClick: handleNextButton, disabled: currentPage >= pages.length }, directionBtnContent('Next', 'bi bi-chevron-right'))));
};
Pagination.displayName = 'Pagination';

export { Pagination };
