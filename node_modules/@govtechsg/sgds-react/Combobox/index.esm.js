'use client';
import classNames from 'classnames';
import PropTypes from 'prop-types';
import * as React from 'react';
import { useContext, useMemo, useRef, useState } from 'react';
import { useDropdownMenu } from '@restart/ui/DropdownMenu';
import useIsomorphicEffect from '@restart/hooks/useIsomorphicEffect';
import useMergedRefs from '@restart/hooks/useMergedRefs';
import warning from 'warning';
import { alignPropType, alignDirection } from '../utils/types';
import useWrappedRefWithWarning from '../utils/useWrappedRefWithWarning';
import { useDropdownItem } from '@restart/ui/DropdownItem';
import Anchor from '@restart/ui/Anchor';
import BaseDropdown from '@restart/ui/Dropdown';
import { useUncontrolled } from 'uncontrollable';
import useEventCallback from '@restart/hooks/useEventCallback';
import { useDropdownToggle } from '@restart/ui/DropdownToggle';
import DropdownContext$1 from '@restart/ui/DropdownContext';
import { useButtonProps } from '@restart/ui/Button';
import createWithBsPrefix from '../utils/createWithBsPrefix';
import generateId from '../utils/generateId';

const DropdownContext = React.createContext({});
DropdownContext.displayName = 'DropdownContext';

const context$1 = React.createContext(null);
context$1.displayName = 'InputGroupContext';

const context = React.createContext(null);
context.displayName = 'NavbarContext';

const propTypes$b = {
    /**
     * @default 'dropdown-menu'
     */
    bsPrefix: PropTypes.string,
    /** Controls the visibility of the Dropdown menu  */
    show: PropTypes.bool,
    /** Whether to render the dropdown menu in the DOM before the first time it is shown */
    renderOnMount: PropTypes.bool,
    /** Have the dropdown switch to it's opposite placement when necessary to stay on screen. */
    flip: PropTypes.bool,
    /**
     * Aligns the dropdown menu to the specified side of the container. You can also align
     * the menu responsively for breakpoints starting at `sm` and up. The alignment
     * direction will affect the specified breakpoint or larger.
     *
     * *Note: Using responsive alignment will disable Popper usage for positioning.*
     *
     * @type {"start"|"end"|{ sm: "start"|"end" }|{ md: "start"|"end" }|{ lg: "start"|"end" }|{ xl: "start"|"end"}|{ xxl: "start"|"end"} }
     */
    align: alignPropType,
    onSelect: PropTypes.func,
    /**
     * Which event when fired outside the component will cause it to be closed
     *
     * *Note: For custom dropdown components, you will have to pass the
     * `rootCloseEvent` to `<RootCloseWrapper>` in your custom dropdown menu
     * component ([similarly to how it is implemented in `<Dropdown.Menu>`](https://github.com/react-bootstrap/react-bootstrap/blob/v0.31.5/src/DropdownMenu.js#L115-L119)).*
     */
    rootCloseEvent: PropTypes.oneOf(['click', 'mousedown']),
    /**
     * Control the rendering of the DropdownMenu. All non-menu props
     * (listed here) are passed through to the `as` Component.
     *
     * If providing a custom, non DOM, component. the `show`, `close` and `align` props
     * are also injected and should be handled appropriately.
     */
    as: PropTypes.elementType,
    /**
     * A set of popper options and props passed directly to Popper.
     */
    popperConfig: PropTypes.object,
    /**
     * Menu color variant.
     *
     * Omitting this will use the default light color.
     */
    variant: PropTypes.string,
    /** @private Provides context when used in NavDropdown component  */
    isNav: PropTypes.bool,
};
const defaultProps$4 = {
    flip: true,
};
function getDropdownMenuPlacement(alignEnd, dropDirection, isRTL) {
    const topStart = isRTL ? 'top-end' : 'top-start';
    const topEnd = isRTL ? 'top-start' : 'top-end';
    const bottomStart = isRTL ? 'bottom-end' : 'bottom-start';
    const bottomEnd = isRTL ? 'bottom-start' : 'bottom-end';
    // const leftStart = isRTL ? 'right-start' : 'left-start';
    // const leftEnd = isRTL ? 'right-end' : 'left-end';
    const rightStart = isRTL ? 'left-start' : 'right-start';
    const rightEnd = isRTL ? 'left-end' : 'right-end';
    let placement = alignEnd ? bottomEnd : bottomStart;
    if (dropDirection === 'up')
        placement = alignEnd ? topEnd : topStart;
    else if (dropDirection === 'end')
        placement = alignEnd ? rightEnd : rightStart;
    // else if (dropDirection === 'start')
    //   placement = alignEnd ? leftEnd : leftStart;
    return placement;
}
const DropdownMenu = React.forwardRef(({ bsPrefix, className, align, rootCloseEvent, flip, show: showProps, renderOnMount, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'ul', popperConfig, variant, isNav, ...props }, ref) => {
    let alignEnd = false;
    const isNavbar = useContext(context);
    const prefix = 'dropdown-menu';
    const { align: contextAlign, drop, isRTL } = useContext(DropdownContext);
    align = align || contextAlign;
    const isInputGroup = useContext(context$1);
    const alignClasses = [];
    if (align) {
        if (typeof align === 'object') {
            const keys = Object.keys(align);
            warning(keys.length === 1, 'There should only be 1 breakpoint when passing an object to `align`');
            if (keys.length) {
                const brkPoint = keys[0];
                const direction = align[brkPoint];
                // .dropdown-menu-end is required for responsively aligning
                // left in addition to align left classes.
                alignEnd = direction === 'start';
                alignClasses.push(`${prefix}-${brkPoint}-${direction}`);
            }
        }
        else if (align === 'end') {
            alignEnd = true;
        }
    }
    const placement = getDropdownMenuPlacement(alignEnd, drop, isRTL);
    const [menuProps, { hasShown, popper, show, toggle }] = useDropdownMenu({
        flip,
        rootCloseEvent,
        show: showProps,
        usePopper: !isNavbar && alignClasses.length === 0,
        offset: !isNav ? [0, 10] : undefined,
        popperConfig,
        placement,
    });
    menuProps.ref = useMergedRefs(useWrappedRefWithWarning(ref, 'DropdownMenu'), menuProps.ref);
    useIsomorphicEffect(() => {
        // Popper's initial position for the menu is incorrect when
        // renderOnMount=true. Need to call update() to correct it.
        if (show)
            popper?.update();
    }, [show]);
    if (!hasShown && !renderOnMount && !isInputGroup)
        return null;
    // For custom components provide additional, non-DOM, props;
    if (typeof Component !== 'string') {
        menuProps.show = show;
        menuProps.close = () => toggle?.(false);
        menuProps.align = align;
    }
    let style = props.style;
    if (popper?.placement) {
        // we don't need the default popper style,
        // menus are display: none when not shown.
        style = { ...props.style, ...menuProps.style };
        //@ts-ignore
        props['x-placement'] = popper.placement;
    }
    return (React.createElement(Component, { ...props, ...menuProps, style: style, ...((alignClasses.length || isNavbar) && {
            'data-bs-popper': 'static',
        }), className: classNames(className, prefix, show && 'show', alignEnd && `${prefix}-end`, variant && `${prefix}-${variant}`, ...alignClasses) }));
});
DropdownMenu.displayName = 'DropdownMenu';
DropdownMenu.propTypes = propTypes$b;
DropdownMenu.defaultProps = defaultProps$4;

const ThemeContext = React.createContext({ prefixes: {} });
({
    prefixes: PropTypes.object,
    dir: PropTypes.string,
});
function useBootstrapPrefix(prefix, defaultPrefix) {
    const { prefixes } = useContext(ThemeContext);
    return prefix || prefixes[defaultPrefix] || `${defaultPrefix}`;
}
// `sgds-${defaultPrefix}`
function useIsRTL() {
    const { dir } = useContext(ThemeContext);
    return dir === 'rtl';
}
const SGDSWrapper = React.forwardRef(({ as: Tag = 'div', ...props }, ref) => {
    return React.createElement(Tag, { ref: ref, ...props, className: classNames(props.className, 'sgds') });
});

const DEVICE_SIZES = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];
const colSize = PropTypes.oneOfType([
    PropTypes.bool,
    PropTypes.number,
    PropTypes.string,
    PropTypes.oneOf(['auto']),
]);
const stringOrNumber = PropTypes.oneOfType([
    PropTypes.number,
    PropTypes.string,
]);
const column = PropTypes.oneOfType([
    colSize,
    PropTypes.shape({
        size: colSize,
        order: stringOrNumber,
        offset: stringOrNumber,
    }),
]);
const propTypes$a = {
    /**
     * @default 'col'
     */
    bsPrefix: PropTypes.string,
    as: PropTypes.elementType,
    /**
     * The number of columns to span on extra small devices (<576px)
     *
     * @type {(boolean|"auto"|number|{ span: boolean|"auto"|number, offset: number, order: "first"|"last"|number })}
     */
    xs: column,
    /**
     * The number of columns to span on small devices (≥576px)
     *
     * @type {(boolean|"auto"|number|{ span: boolean|"auto"|number, offset: number, order: "first"|"last"|number })}
     */
    sm: column,
    /**
     * The number of columns to span on medium devices (≥768px)
     *
     * @type {(boolean|"auto"|number|{ span: boolean|"auto"|number, offset: number, order: "first"|"last"|number })}
     */
    md: column,
    /**
     * The number of columns to span on large devices (≥992px)
     *
     * @type {(boolean|"auto"|number|{ span: boolean|"auto"|number, offset: number, order: "first"|"last"|number })}
     */
    lg: column,
    /**
     * The number of columns to span on extra large devices (≥1200px)
     *
     * @type {(boolean|"auto"|number|{ span: boolean|"auto"|number, offset: number, order: "first"|"last"|number })}
     */
    xl: column,
    /**
     * The number of columns to span on extra extra large devices (≥1400px)
     *
     * @type {(boolean|"auto"|number|{ span: boolean|"auto"|number, offset: number, order: "first"|"last"|number })}
     */
    xxl: column,
};
function useCol({ as, bsPrefix, className, ...props }) {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'col');
    const spans = [];
    const classes = [];
    DEVICE_SIZES.forEach((brkPoint) => {
        const propValue = props[brkPoint];
        delete props[brkPoint];
        let span;
        let offset;
        let order;
        if (typeof propValue === 'object' && propValue != null) {
            ({ span, offset, order } = propValue);
        }
        else {
            span = propValue;
        }
        const infix = brkPoint !== 'xs' ? `-${brkPoint}` : '';
        if (span)
            spans.push(span === true ? `${bsPrefix}${infix}` : `${bsPrefix}${infix}-${span}`);
        if (order != null)
            classes.push(`order${infix}-${order}`);
        if (offset != null)
            classes.push(`offset${infix}-${offset}`);
    });
    return [
        { ...props, className: classNames(className, ...spans, ...classes) },
        {
            as,
            bsPrefix,
            spans,
        },
    ];
}
const Col = React.forwardRef(
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
(props, ref) => {
    const [{ className, ...colProps }, { as: Component = 'div', bsPrefix, spans },] = useCol(props);
    return (React.createElement(Component, { ...colProps, ref: ref, className: classNames(className, !spans.length && bsPrefix) }));
});
Col.displayName = 'Col';
Col.propTypes = propTypes$a;

const FormContext = React.createContext({});

const propTypes$9 = {
    /**
     * @default 'form-label'
     */
    bsPrefix: PropTypes.string,
    /**
     * Uses `controlId` from `<FormGroup>` if not explicitly specified.
     */
    htmlFor: PropTypes.string,
    /**
     * Renders the FormLabel as a `<Col>` component (accepting all the same props),
     * as well as adding additional styling for horizontal forms.
     */
    column: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['sm', 'lg'])]),
    /**
     * The FormLabel `ref` will be forwarded to the underlying element.
     * Unless the FormLabel is rendered `as` a composite component,
     * it will be a DOM node, when resolved.
     *
     * @type {ReactRef}
     * @alias ref
     */
    _ref: PropTypes.any,
    /**
     * Hides the label visually while still allowing it to be
     * read by assistive technologies.
     */
    visuallyHidden: PropTypes.bool,
    /** Set a custom element for this component */
    as: PropTypes.elementType,
};
const defaultProps$3 = {
    column: false,
    visuallyHidden: false,
};
const FormLabel = React.forwardRef(({ 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'label', bsPrefix, column, visuallyHidden, className, htmlFor, ...props }, ref) => {
    const { controlId } = useContext(FormContext);
    bsPrefix = useBootstrapPrefix(bsPrefix, 'form-label');
    let columnClass = 'col-form-label';
    if (typeof column === 'string')
        columnClass = `${columnClass} ${columnClass}-${column}`;
    const classes = classNames(className, bsPrefix, visuallyHidden && 'visually-hidden', column && columnClass);
    warning(controlId == null || !htmlFor, '`controlId` is ignored on `<FormLabel>` when `htmlFor` is specified.');
    htmlFor = htmlFor || controlId;
    if (column)
        return (React.createElement(Col, { ref: ref, as: "label", className: classes, htmlFor: htmlFor, ...props }));
    return (
    // eslint-disable-next-line jsx-a11y/label-has-for, jsx-a11y/label-has-associated-control
    React.createElement(Component, { ref: ref, className: classes, htmlFor: htmlFor, ...props }));
});
FormLabel.displayName = 'FormLabel';
FormLabel.propTypes = propTypes$9;
FormLabel.defaultProps = defaultProps$3;

const propTypes$8 = {
    /** @default 'dropdown-item' */
    bsPrefix: PropTypes.string,
    /**
     * Highlight the menu item as active.
     */
    active: PropTypes.bool,
    /**
     * Disable the menu item, making it unselectable.
     */
    disabled: PropTypes.bool,
    /**
     * Value passed to the `onSelect` handler, useful for identifying the selected menu item.
     */
    eventKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    /**
     * HTML `href` attribute corresponding to `a.href`.
     */
    href: PropTypes.string,
    /**
     * Callback fired when the menu item is clicked.
     */
    onClick: PropTypes.func,
    as: PropTypes.elementType,
};
const DropdownItem = React.forwardRef(({ bsPrefix, className, eventKey, disabled = false, onClick, active, as: Component = Anchor, ...props }, ref) => {
    const prefix = 'dropdown-item';
    const [dropdownItemProps, meta] = useDropdownItem({
        key: eventKey,
        href: props.href,
        disabled,
        onClick,
        active,
    });
    return (React.createElement("li", null,
        React.createElement(Component, { ...props, ...dropdownItemProps, ref: ref, className: classNames(className, prefix, meta.isActive && 'active', disabled && 'disabled') })));
});
DropdownItem.displayName = 'DropdownItem';
DropdownItem.propTypes = propTypes$8;

const propTypes$7 = {
    /**
     * @default 'btn'
     */
    bsPrefix: PropTypes.string,
    /**
     * One or more button variant combinations
     *
     * buttons may be one of a variety of visual variants such as:
     *
     * `'primary', 'secondary', 'success', 'danger', 'warning', 'info', 'dark', 'light', 'link'`
     *
     * as well as "outline" versions (prefixed by 'outline-*')
     *
     * `'outline-primary', 'outline-secondary', 'outline-success', 'outline-danger', 'outline-warning', 'outline-info', 'outline-dark', 'outline-light'`
     */
    variant: PropTypes.string,
    /**
     * Specifies a large or small button.
     *
     * @type ('sm'|'lg')
     */
    size: PropTypes.string,
    /** Manually set the visual state of the button to `:active` */
    active: PropTypes.bool,
    /**
     * Disables the Button, preventing mouse events,
     * even if the underlying component is an `<a>` element
     */
    disabled: PropTypes.bool,
    /** Providing a `href` will render an `<a>` element, _styled_ as a button. */
    href: PropTypes.string,
    /**
     * Defines HTML button type attribute.
     *
     * @default 'button'
     */
    type: PropTypes.oneOf(['button', 'reset', 'submit', null]),
    as: PropTypes.elementType,
};
const defaultProps$2 = {
    variant: 'primary',
    active: false,
    disabled: false,
};
const Button = React.forwardRef(({ as, bsPrefix, variant, size, active, className, ...props }, ref) => {
    const prefix = useBootstrapPrefix(bsPrefix, 'btn');
    const [buttonProps, { tagName }] = useButtonProps({
        tagName: as,
        ...props,
    });
    const Component = tagName;
    return (React.createElement(SGDSWrapper, { as: Component, ...props, ...buttonProps, ref: ref, className: classNames(className, prefix, active && 'active', variant && `${prefix}-${variant}`, size && `${prefix}-${size}`, props.href && props.disabled && 'disabled') }));
});
Button.displayName = 'Button';
Button.propTypes = propTypes$7;
Button.defaultProps = defaultProps$2;

const propTypes$6 = {
    /**
     * @default 'dropdown-toggle'
     */
    bsPrefix: PropTypes.string,
    /**
     * An html id attribute, necessary for assistive technologies, such as screen readers.
     * @type {string|number}
     */
    id: PropTypes.string,
    split: PropTypes.bool,
    as: PropTypes.elementType,
    /**
     * to passthrough to the underlying button or whatever from DropdownButton
     * @private
     */
    childBsPrefix: PropTypes.string,
};
const DropdownToggle = React.forwardRef(({ bsPrefix, split, className, childBsPrefix, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = Button, ...props }, ref) => {
    const prefix = 'dropdown-toggle';
    const dropdownContext = useContext(DropdownContext$1);
    const isInputGroup = useContext(context$1);
    if (childBsPrefix !== undefined) {
        props.bsPrefix = childBsPrefix;
    }
    const [toggleProps] = useDropdownToggle();
    toggleProps.ref = useMergedRefs(toggleProps.ref, useWrappedRefWithWarning(ref, 'DropdownToggle'));
    // This intentionally forwards size and variant (if set) to the
    // underlying component, to allow it to render size and style variants.
    return (React.createElement(Component, { className: classNames(className, prefix, split && `${prefix}-split`, !!isInputGroup && dropdownContext?.show && 'show'), variant: "outline-secondary", ...toggleProps, ...props, "aria-haspopup": "menu" }));
});
DropdownToggle.displayName = 'DropdownToggle';
DropdownToggle.propTypes = propTypes$6;

const DropdownHeader = createWithBsPrefix('dropdown-header', {
    defaultProps: { role: 'heading' },
});
const DropdownDivider = createWithBsPrefix('dropdown-divider', {
    Component: 'hr',
    defaultProps: { role: 'separator' },
});
const DropdownItemText = createWithBsPrefix('dropdown-item-text', {
    Component: 'span',
});

const propTypes$5 = {
    /** @default 'dropdown' */
    bsPrefix: PropTypes.string,
    /**
     * Determines the direction and location of the Menu in relation to it's Toggle.
     *
     * @type {"end"|"up"|"down" }
     */
    drop: PropTypes.oneOf(['up', 'end', 'down']),
    as: PropTypes.elementType,
    align: alignDirection,
    /**
     * Whether or not the Dropdown is visible.
     *
     * @controllable onToggle
     */
    show: PropTypes.bool,
    /**
     * Allow Dropdown to flip in case of an overlapping on the reference element. For more information refer to
     * Popper.js's flip [docs](https://popper.js.org/docs/v2/modifiers/flip/).
     *
     */
    flip: PropTypes.bool,
    /**
     * A callback fired when the Dropdown wishes to change visibility. Called with the requested
     * `show` value, the DOM event, and the source that fired it: `'click'`,`'keydown'`,`'rootClose'`, or `'select'`.
     *
     * ```js
     * function(
     *   isOpen: boolean,
     *   event: SyntheticEvent,
     *   metadata: {
     *     source: 'select' | 'click' | 'rootClose' | 'keydown'
     *   }
     * ): void
     * ```
     *
     * @controllable show
     */
    onToggle: PropTypes.func,
    /**
     * A callback fired when a menu item is selected.
     *
     * ```js
     * (eventKey: any, event: Object) => any
     * ```
     */
    onSelect: PropTypes.func,
    /**
     * Controls the focus behavior for when the Dropdown is opened. Set to
     * `true` to always focus the first menu item, `keyboard` to focus only when
     * navigating via the keyboard, or `false` to disable completely
     *
     * The Default behavior is `false` **unless** the Menu has a `role="menu"`
     * where it will default to `keyboard` to match the recommended [ARIA Authoring practices](https://www.w3.org/TR/wai-aria-practices-1.1/#menubutton).
     */
    focusFirstItemOnShow: PropTypes.oneOf([false, true, 'keyboard']),
    /** @private */
    navbar: PropTypes.bool,
    /**
     * Controls the auto close behaviour of the dropdown when clicking outside of
     * the button or the list.
     */
    autoClose: PropTypes.oneOf([true, 'outside', 'inside', false]),
};
const defaultProps$1 = {
    navbar: false,
    align: 'start',
    autoClose: true,
    focusFirstItemOnShow: 'keyboard',
};
const Dropdown = React.forwardRef((pProps, ref) => {
    const { bsPrefix, drop, show, className, align, onSelect, onToggle, focusFirstItemOnShow, 
    // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
    as: Component = 'div', navbar: _4, autoClose, ...props } = useUncontrolled(pProps, { show: 'onToggle' });
    const isInputGroup = useContext(context$1);
    const prefix = useBootstrapPrefix(bsPrefix, 'dropdown');
    const isRTL = useIsRTL();
    const isClosingPermitted = (source) => {
        // autoClose=false only permits close on button click
        if (autoClose === false)
            return source === 'click';
        // autoClose=inside doesn't permit close on rootClose
        if (autoClose === 'inside')
            return source !== 'rootClose';
        // autoClose=outside doesn't permit close on select
        if (autoClose === 'outside')
            return source !== 'select';
        return true;
    };
    const handleToggle = useEventCallback((nextShow, meta) => {
        if (meta.originalEvent.currentTarget === document &&
            (meta.source !== 'keydown' ||
                meta.originalEvent.key === 'Escape'))
            meta.source = 'rootClose';
        if (isClosingPermitted(meta.source))
            onToggle?.(nextShow, meta);
    });
    const alignEnd = align === 'end';
    const placement = getDropdownMenuPlacement(alignEnd, drop, isRTL);
    const contextValue = useMemo(() => ({
        align,
        drop,
        isRTL,
    }), [align, drop, isRTL]);
    return (React.createElement(DropdownContext.Provider, { value: contextValue },
        React.createElement(BaseDropdown, { placement: placement, show: show, onSelect: onSelect, onToggle: handleToggle, focusFirstItemOnShow: focusFirstItemOnShow, itemSelector: `.${prefix}-item:not(.disabled):not(:disabled)` }, isInputGroup ? (props.children) : (React.createElement(SGDSWrapper, { as: Component, ...props, ref: ref, className: classNames(className, show && 'show', prefix, drop === 'up' && 'dropup', drop === 'end' && 'dropend') })))));
});
Dropdown.displayName = 'Dropdown';
Dropdown.propTypes = propTypes$5;
Dropdown.defaultProps = defaultProps$1;
var Dropdown$1 = Object.assign(Dropdown, {
    Toggle: DropdownToggle,
    Menu: DropdownMenu,
    Item: DropdownItem,
    ItemText: DropdownItemText,
    Divider: DropdownDivider,
    Header: DropdownHeader,
});

const propTypes$4 = {
    /**
     * Specify whether the feedback is for valid or invalid fields
     *
     * @type {('valid'|'invalid')}
     */
    type: PropTypes.string,
    as: PropTypes.elementType,
};
const Feedback = React.forwardRef(
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
({ as: Component = 'div', className, type = 'valid', ...props }, ref) => {
    return (React.createElement(Component, { ...props, ref: ref, className: classNames(className, `${type}-feedback`) }));
});
Feedback.displayName = 'Feedback';
Feedback.propTypes = propTypes$4;

const propTypes$3 = {
    as: PropTypes.elementType,
    icon: PropTypes.element,
};
const FormControlGroup = React.forwardRef(({ icon, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'div', bsPrefix, children, className, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'form-control-group');
    return (React.createElement(SGDSWrapper, { className: classNames(bsPrefix, className), ...props, ref: ref },
        icon &&
            React.cloneElement(icon, {
                className: classNames(icon.props.className, 'form-control-icon'),
            }),
        children));
});
FormControlGroup.displayName = 'FormControlGroup';
FormControlGroup.propTypes = propTypes$3;

const propTypes$2 = {
    /**
     * @default {'form-control'}
     */
    bsPrefix: PropTypes.string,
    /**
     * The FormControl `ref` will be forwarded to the underlying input element,
     * which means unless `as` is a composite component,
     * it will be a DOM node, when resolved.
     *
     * @type {ReactRef}
     * @alias ref
     */
    _ref: PropTypes.any,
    /**
     * Input size variants
     *
     * @type {('sm'|'lg')}
     */
    size: PropTypes.string,
    /**
     * The underlying HTML element to use when rendering the FormControl.
     *
     * @type {('input'|'textarea'|elementType)}
     */
    as: PropTypes.elementType,
    /**
     * Render the input as plain text. Generally used along side `readOnly`.
     */
    plaintext: PropTypes.bool,
    /** Make the control readonly */
    readOnly: PropTypes.bool,
    /** Make the control disabled */
    disabled: PropTypes.bool,
    /**
     * The `value` attribute of underlying input
     *
     * @controllable onChange
     * */
    value: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.arrayOf(PropTypes.string),
        PropTypes.number,
    ]),
    /** A callback fired when the `value` prop changes */
    onChange: PropTypes.func,
    /**
     * The HTML input `type`, which is only relevant if `as` is `'input'` (the default).
     */
    type: PropTypes.string,
    /**
     * Uses `controlId` from `<FormGroup>` if not explicitly specified.
     */
    id: PropTypes.string,
    /** Add "valid" validation styles to the control */
    isValid: PropTypes.bool,
    /** Add "invalid" validation styles to the control and accompanying label */
    isInvalid: PropTypes.bool,
};
const FormControl = React.forwardRef(({ bsPrefix, type, size, id, className, isValid = false, isInvalid = false, plaintext, readOnly, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'input', ...props }, ref) => {
    const { controlId } = useContext(FormContext);
    bsPrefix = useBootstrapPrefix(bsPrefix, 'form-control');
    let classes;
    if (plaintext) {
        classes = { [`${bsPrefix}-plaintext`]: true };
    }
    else {
        classes = {
            [bsPrefix]: true,
            [`${bsPrefix}-${size}`]: size,
        };
    }
    warning(controlId == null || !id, '`controlId` is ignored on `<FormControl>` when `id` is specified.');
    return (React.createElement(Component, { ...props, type: type, ref: ref, readOnly: readOnly, id: id || controlId, className: classNames(className, classes, isValid && `is-valid`, isInvalid && `is-invalid`, type === 'color' && `${bsPrefix}-color`) }));
});
FormControl.displayName = 'FormControl';
FormControl.propTypes = propTypes$2;
var FormControl$1 = Object.assign(FormControl, { Feedback, Group: FormControlGroup });

const propTypes$1 = {
    /**
     * @default 'dropdown-toggle'
     */
    bsPrefix: PropTypes.string,
    /**
     * An html id attribute, necessary for assistive technologies, such as screen readers.
     * @type {string|number}
     */
    id: PropTypes.string,
    split: PropTypes.bool,
    as: PropTypes.elementType,
    /**
     * to passthrough to the underlying button or whatever from DropdownButton
     * @private
     */
    childBsPrefix: PropTypes.string,
    setIsMenuOpen: PropTypes.func
};
const FormControlToggle = React.forwardRef(({ bsPrefix, className, childBsPrefix, setIsMenuOpen, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = FormControl$1, ...props }, ref) => {
    const prefix = 'dropdown-toggle';
    const dropdownContext = useContext(DropdownContext$1);
    const isInputGroup = useContext(context$1);
    if (childBsPrefix !== undefined) {
        props.bsPrefix = childBsPrefix;
    }
    const [toggleProps] = useDropdownToggle();
    toggleProps.ref = useMergedRefs(toggleProps.ref, useWrappedRefWithWarning(ref, 'DropdownToggle'));
    const { "aria-expanded": ariaExpanded, id, ...newToggleProps } = toggleProps;
    if (setIsMenuOpen) {
        React.useEffect(() => {
            setIsMenuOpen(dropdownContext?.show);
        }, [dropdownContext?.show]);
    }
    // This intentionally forwards size and variant (if set) to the
    // underlying component, to allow it to render size and style variants.
    return (React.createElement(Component, { className: classNames(className, prefix, !!isInputGroup && dropdownContext?.show && 'show'), ...newToggleProps, ...props }));
});
FormControlToggle.displayName = 'FormToggle';
FormControlToggle.propTypes = propTypes$1;

const propTypes = {
    initialValue: PropTypes.string,
    onChangeInput: PropTypes.func,
    menuPlacement: PropTypes.oneOf(['up', 'down']),
    menuList: PropTypes.arrayOf(PropTypes.string).isRequired,
    label: PropTypes.string,
    icon: PropTypes.element
};
const defaultProps = {
    menuPlacement: 'down',
    initialValue: '',
};
const Combobox = React.forwardRef(({ menuPlacement = 'down', menuList, initialValue = '', onChangeInput, label = '', icon, ...props }, ref) => {
    const formControlRef = useRef(null);
    const inputRef = useMergedRefs(ref, formControlRef);
    const [menuOpen, setIsMenuOpen] = useState(undefined);
    const initialState = {
        value: initialValue,
        invalid: false,
        menuList: initialValue
            ? menuList.filter((n) => n.toLowerCase().startsWith(initialValue.toLowerCase()))
            : menuList,
    };
    const [state, setState] = useState(initialState);
    const handleChange = (e) => {
        if (!menuOpen) {
            formControlRef.current?.click();
        }
        const filterMenuList = menuList.filter((n) => {
            const nLowerCase = n.toLowerCase();
            const valueLower = e.currentTarget.value.toLowerCase();
            return nLowerCase.startsWith(valueLower);
        });
        setState({
            ...state,
            value: e.currentTarget.value,
            menuList: filterMenuList,
        });
        if (onChangeInput)
            onChangeInput(e.currentTarget.value, e);
    };
    const controlProps = {
        onChange: handleChange,
        value: state.value,
        ref: inputRef,
        isInvalid: state.invalid,
        ...props,
    };
    const handleClickItem = (e) => {
        if (onChangeInput)
            onChangeInput(e.currentTarget.textContent, e);
        setState({
            ...state,
            value: e.currentTarget.textContent,
            menuList: state.menuList.filter((c) => c === e.currentTarget.textContent),
        });
    };
    const focusDropdownItem = (event) => {
        setState({
            ...state,
            value: event.currentTarget.textContent,
        });
    };
    const [comboboxMenuId, setComboboxMenuId] = useState("");
    React.useEffect(() => {
        setComboboxMenuId(generateId('combobox', 'ul'));
    }, []);
    return (React.createElement(React.Fragment, null,
        label && React.createElement(FormLabel, { htmlFor: props.id }, label),
        React.createElement(Dropdown$1, { className: icon && 'combobox', focusFirstItemOnShow: false, drop: menuPlacement },
            React.createElement(FormControlToggle, { ...controlProps, setIsMenuOpen: setIsMenuOpen, role: "combobox", "aria-autocomplete": "list", "aria-controls": comboboxMenuId }),
            icon &&
                React.cloneElement(icon, {
                    className: classNames(icon.props.className, 'form-control-icon'),
                }),
            state.menuList.length > 0 && (React.createElement(DropdownMenu, { id: comboboxMenuId, role: "listbox" }, state.menuList.map((menuItem) => (React.createElement(DropdownItem, { as: "button", key: menuItem, onClick: handleClickItem, onFocus: focusDropdownItem }, menuItem))))))));
});
Combobox.displayName = 'Combobox';
Combobox.propTypes = propTypes;
Combobox.defaultProps = defaultProps;

export { Combobox };
