'use client';
import * as React from 'react';
import { useContext, useMemo, useRef, useState } from 'react';
import classNames from 'classnames';
import PropTypes from 'prop-types';
import { useButtonProps } from '@restart/ui/Button';
import useMergedRefs from '@restart/hooks/useMergedRefs';
import warning from 'warning';
import { useDropdownToggle } from '@restart/ui/DropdownToggle';
import DropdownContext$1 from '@restart/ui/DropdownContext';
import useWrappedRefWithWarning from '../utils/useWrappedRefWithWarning';
import BaseDropdown from '@restart/ui/Dropdown';
import { useUncontrolled } from 'uncontrollable';
import useEventCallback from '@restart/hooks/useEventCallback';
import { useDropdownItem } from '@restart/ui/DropdownItem';
import Anchor from '@restart/ui/Anchor';
import { useDropdownMenu } from '@restart/ui/DropdownMenu';
import useIsomorphicEffect from '@restart/hooks/useIsomorphicEffect';
import { alignPropType, alignDirection } from '../utils/types';
import createWithBsPrefix from '../utils/createWithBsPrefix';
import generateId from '../utils/generateId';

const DAY_LABELS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const setTimeToNoon = (date) => {
    const newDate = new Date(date);
    newDate.setHours(12);
    newDate.setMinutes(0);
    newDate.setSeconds(0);
    newDate.setMilliseconds(0);
    return newDate;
};
const Calendar = React.forwardRef((props, ref) => {
    const handleClick = (e) => {
        const day = e.currentTarget.getAttribute('data-day');
        const displayDateClone = new Date(props.displayDate);
        const newSelectedDate = setTimeToNoon(displayDateClone);
        newSelectedDate.setDate(parseInt(day));
        props.changeDate(newSelectedDate);
    };
    /**
     * Change the time of all dates in selectedDate to noon.
     * @returns The processed selectedDate.
     */
    const getProcessedSelectedDate = () => {
        if (props.selectedDate instanceof Date) {
            return setTimeToNoon(props.selectedDate);
        }
        else if (props.selectedDate) {
            // selectedDate is of type RangeSelectionValue
            const { start, end } = props.selectedDate;
            const processedStart = start ? setTimeToNoon(start) : undefined;
            const processedEnd = end ? setTimeToNoon(end) : undefined;
            return { start: processedStart, end: processedEnd };
        }
        else {
            return undefined;
        }
    };
    /**
     * Checks if a given date is selected.
     * @param date The given date.
     * @param selectedDate The selected date or date range.
     * @returns true if the given date is selected, false if otherwise.
     */
    const isSelectedDate = (date, selectedDate) => {
        if (selectedDate instanceof Date) {
            return Date.parse(date.toISOString()) === Date.parse(selectedDate.toISOString());
        }
        let { start, end } = selectedDate;
        if (start && end) {
            // if selected end date is before selected start date --> swap
            if (new Date(start).getTime() > new Date(end).getTime()) {
                const temp = start;
                start = end;
                end = temp;
            }
            return Date.parse(date.toISOString()) >= Date.parse(start.toISOString())
                && Date.parse(date.toISOString()) <= Date.parse(end.toISOString());
        }
        else if (start) {
            return Date.parse(date.toISOString()) === Date.parse(start.toISOString());
        }
        else if (end) {
            Date.parse(date.toISOString()) === Date.parse(end.toISOString());
        }
        else {
            return false;
        }
        return false;
    };
    const currentDate = setTimeToNoon(new Date());
    const processedSelectedDate = getProcessedSelectedDate();
    const minimumDate = props.minDate
        ? setTimeToNoon(new Date(props.minDate))
        : null;
    const maximumDate = props.maxDate
        ? setTimeToNoon(new Date(props.maxDate))
        : null;
    const year = props.displayDate.getFullYear();
    const month = props.displayDate.getMonth();
    const firstDay = new Date(year, month, 1);
    const startingDay = firstDay.getDay();
    let monthLength = daysInMonth[month];
    if (month === 1) {
        if ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0) {
            monthLength = 29;
        }
    }
    const weeks = [];
    let day = 1;
    for (let i = 0; i < 9; i++) {
        const week = [];
        for (let j = 0; j <= 6; j++) {
            if (day <= monthLength && (i > 0 || j >= startingDay)) {
                let className = undefined;
                const date = new Date(year, month, day, 12, 0, 0, 0);
                const dateString = date.toISOString();
                const beforeMinDate = minimumDate &&
                    Date.parse(dateString) < Date.parse(minimumDate.toISOString());
                const afterMinDate = maximumDate &&
                    Date.parse(dateString) > Date.parse(maximumDate.toISOString());
                let clickHandler = handleClick;
                const style = {
                    cursor: 'pointer',
                    borderRadius: 0,
                };
                if (Date.parse(dateString) === Date.parse(currentDate.toISOString())) {
                    // if date is the current Date
                    className = 'text-primary';
                }
                if (beforeMinDate || afterMinDate) {
                    className = 'text-muted';
                    clickHandler = undefined;
                    style.cursor = 'default';
                }
                if (processedSelectedDate && isSelectedDate(date, processedSelectedDate)) {
                    className = 'bg-primary-100';
                }
                week.push(React.createElement("td", { key: j, "data-day": day, onClick: clickHandler, style: style, className: className }, day));
                day++;
            }
            else {
                week.push(React.createElement("td", { key: j }));
            }
        }
        weeks.push(React.createElement("tr", { key: i }, week));
        if (day > monthLength) {
            break;
        }
    }
    return (React.createElement("table", { className: "text-center", role: "grid", ref: ref },
        React.createElement("thead", null,
            React.createElement("tr", null, DAY_LABELS.map((label, index) => {
                return (React.createElement("th", { key: index, abbr: label, scope: "col" },
                    React.createElement("small", null, label.slice(0, 3))));
            }))),
        React.createElement("tbody", null, weeks)));
});

const context$2 = React.createContext({
    view: 'day',
    setView: () => { }
});
context$2.displayName = 'DatePickerContext';

const MONTH_LABELS$1 = [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December',
];
const CalendarHeader = ({ ...props }) => {
    const { view, setView } = useContext(context$2);
    const handleClickPrevious = () => {
        const newDisplayDate = new Date(props.displayDate);
        newDisplayDate.setDate(1);
        if (view === 'month') {
            newDisplayDate.setFullYear(newDisplayDate.getFullYear() - 1);
            return props.onChange(newDisplayDate);
        }
        else if (view === 'year') {
            newDisplayDate.setFullYear(newDisplayDate.getFullYear() - 10);
            return props.onChange(newDisplayDate);
        }
        else {
            newDisplayDate.setMonth(newDisplayDate.getMonth() - 1);
            return props.onChange(newDisplayDate);
        }
    };
    const handleClickNext = () => {
        const newDisplayDate = new Date(props.displayDate);
        newDisplayDate.setDate(1);
        if (view === 'month') {
            newDisplayDate.setFullYear(newDisplayDate.getFullYear() + 1);
            return props.onChange(newDisplayDate);
        }
        else if (view === 'year') {
            newDisplayDate.setFullYear(newDisplayDate.getFullYear() + 10);
            return props.onChange(newDisplayDate);
        }
        else {
            newDisplayDate.setMonth(newDisplayDate.getMonth() + 1);
            return props.onChange(newDisplayDate);
        }
    };
    const changeView = () => {
        switch (view) {
            case 'day':
                setView('month');
                break;
            case 'month':
                setView('year');
                break;
        }
    };
    const renderHeader = () => {
        if (view === 'month') {
            return `${props.displayDate.getFullYear()}`;
        }
        if (view === 'year')
            return `${props.displayDate.getFullYear() - 5} - ${props.displayDate.getFullYear() + 6}`;
        return `${MONTH_LABELS$1[props.displayDate.getMonth()]} ${props.displayDate.getFullYear()}`;
    };
    return (React.createElement("div", { className: "text-center d-flex justify-content-between" },
        React.createElement("button", { onClick: handleClickPrevious, "aria-label": `previous ${view}` },
            React.createElement("i", { className: "bi bi-chevron-left" })),
        React.createElement("button", { onClick: changeView, disabled: view === 'year', "aria-live": 'polite' }, renderHeader()),
        React.createElement("button", { onClick: handleClickNext, "aria-label": `next ${view}` },
            React.createElement("i", { className: "bi bi-chevron-right" }))));
};

const ThemeContext = React.createContext({ prefixes: {} });
({
    prefixes: PropTypes.object,
    dir: PropTypes.string,
});
function useBootstrapPrefix(prefix, defaultPrefix) {
    const { prefixes } = useContext(ThemeContext);
    return prefix || prefixes[defaultPrefix] || `${defaultPrefix}`;
}
// `sgds-${defaultPrefix}`
function useIsRTL() {
    const { dir } = useContext(ThemeContext);
    return dir === 'rtl';
}
const SGDSWrapper = React.forwardRef(({ as: Tag = 'div', ...props }, ref) => {
    return React.createElement(Tag, { ref: ref, ...props, className: classNames(props.className, 'sgds') });
});

const propTypes$a = {
    /**
     * @default 'btn'
     */
    bsPrefix: PropTypes.string,
    /**
     * One or more button variant combinations
     *
     * buttons may be one of a variety of visual variants such as:
     *
     * `'primary', 'secondary', 'success', 'danger', 'warning', 'info', 'dark', 'light', 'link'`
     *
     * as well as "outline" versions (prefixed by 'outline-*')
     *
     * `'outline-primary', 'outline-secondary', 'outline-success', 'outline-danger', 'outline-warning', 'outline-info', 'outline-dark', 'outline-light'`
     */
    variant: PropTypes.string,
    /**
     * Specifies a large or small button.
     *
     * @type ('sm'|'lg')
     */
    size: PropTypes.string,
    /** Manually set the visual state of the button to `:active` */
    active: PropTypes.bool,
    /**
     * Disables the Button, preventing mouse events,
     * even if the underlying component is an `<a>` element
     */
    disabled: PropTypes.bool,
    /** Providing a `href` will render an `<a>` element, _styled_ as a button. */
    href: PropTypes.string,
    /**
     * Defines HTML button type attribute.
     *
     * @default 'button'
     */
    type: PropTypes.oneOf(['button', 'reset', 'submit', null]),
    as: PropTypes.elementType,
};
const defaultProps$3 = {
    variant: 'primary',
    active: false,
    disabled: false,
};
const Button = React.forwardRef(({ as, bsPrefix, variant, size, active, className, ...props }, ref) => {
    const prefix = useBootstrapPrefix(bsPrefix, 'btn');
    const [buttonProps, { tagName }] = useButtonProps({
        tagName: as,
        ...props,
    });
    const Component = tagName;
    return (React.createElement(SGDSWrapper, { as: Component, ...props, ...buttonProps, ref: ref, className: classNames(className, prefix, active && 'active', variant && `${prefix}-${variant}`, size && `${prefix}-${size}`, props.href && props.disabled && 'disabled') }));
});
Button.displayName = 'Button';
Button.propTypes = propTypes$a;
Button.defaultProps = defaultProps$3;

const MONTH_LABELS = [
    'Jan',
    'Feb',
    'Mar',
    'Apr',
    'May',
    'Jun',
    'Jul',
    'Aug',
    'Sep',
    'Oct',
    'Nov',
    'Dec',
];
const MonthView = React.forwardRef(({ displayDate, onClickMonth, ...props }, ref) => {
    const displayMonth = MONTH_LABELS[displayDate.getMonth()];
    return (React.createElement("div", { className: "sgds monthpicker", ref: ref, ...props }, MONTH_LABELS.map((m, idx) => (React.createElement("button", { className: classNames(displayMonth === m && 'active', 'month'), key: m, onClick: () => onClickMonth(idx) }, m)))));
});

const YearView = React.forwardRef(({ displayDate, onClickYear, ...props }, ref) => {
    const displayYear = displayDate.getFullYear();
    const startLimit = displayYear - 5;
    const endLimit = displayYear + 6;
    const yearArray = [];
    for (let i = startLimit; i < endLimit + 1; i++) {
        yearArray.push(i);
    }
    return (React.createElement("div", { className: "sgds yearpicker", ref: ref, ...props }, yearArray.map((y) => (React.createElement("button", { className: classNames(displayYear === y && 'active', 'year'), key: y, onClick: () => onClickYear(y) }, y)))));
});

const context$1 = React.createContext(null);
context$1.displayName = 'InputGroupContext';

const propTypes$9 = {
    /**
     * Specify whether the feedback is for valid or invalid fields
     *
     * @type {('valid'|'invalid')}
     */
    type: PropTypes.string,
    as: PropTypes.elementType,
};
const Feedback = React.forwardRef(
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
({ as: Component = 'div', className, type = 'valid', ...props }, ref) => {
    return (React.createElement(Component, { ...props, ref: ref, className: classNames(className, `${type}-feedback`) }));
});
Feedback.displayName = 'Feedback';
Feedback.propTypes = propTypes$9;

const FormContext = React.createContext({});

const propTypes$8 = {
    as: PropTypes.elementType,
    icon: PropTypes.element,
};
const FormControlGroup = React.forwardRef(({ icon, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'div', bsPrefix, children, className, ...props }, ref) => {
    bsPrefix = useBootstrapPrefix(bsPrefix, 'form-control-group');
    return (React.createElement(SGDSWrapper, { className: classNames(bsPrefix, className), ...props, ref: ref },
        icon &&
            React.cloneElement(icon, {
                className: classNames(icon.props.className, 'form-control-icon'),
            }),
        children));
});
FormControlGroup.displayName = 'FormControlGroup';
FormControlGroup.propTypes = propTypes$8;

const propTypes$7 = {
    /**
     * @default {'form-control'}
     */
    bsPrefix: PropTypes.string,
    /**
     * The FormControl `ref` will be forwarded to the underlying input element,
     * which means unless `as` is a composite component,
     * it will be a DOM node, when resolved.
     *
     * @type {ReactRef}
     * @alias ref
     */
    _ref: PropTypes.any,
    /**
     * Input size variants
     *
     * @type {('sm'|'lg')}
     */
    size: PropTypes.string,
    /**
     * The underlying HTML element to use when rendering the FormControl.
     *
     * @type {('input'|'textarea'|elementType)}
     */
    as: PropTypes.elementType,
    /**
     * Render the input as plain text. Generally used along side `readOnly`.
     */
    plaintext: PropTypes.bool,
    /** Make the control readonly */
    readOnly: PropTypes.bool,
    /** Make the control disabled */
    disabled: PropTypes.bool,
    /**
     * The `value` attribute of underlying input
     *
     * @controllable onChange
     * */
    value: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.arrayOf(PropTypes.string),
        PropTypes.number,
    ]),
    /** A callback fired when the `value` prop changes */
    onChange: PropTypes.func,
    /**
     * The HTML input `type`, which is only relevant if `as` is `'input'` (the default).
     */
    type: PropTypes.string,
    /**
     * Uses `controlId` from `<FormGroup>` if not explicitly specified.
     */
    id: PropTypes.string,
    /** Add "valid" validation styles to the control */
    isValid: PropTypes.bool,
    /** Add "invalid" validation styles to the control and accompanying label */
    isInvalid: PropTypes.bool,
};
const FormControl = React.forwardRef(({ bsPrefix, type, size, id, className, isValid = false, isInvalid = false, plaintext, readOnly, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'input', ...props }, ref) => {
    const { controlId } = useContext(FormContext);
    bsPrefix = useBootstrapPrefix(bsPrefix, 'form-control');
    let classes;
    if (plaintext) {
        classes = { [`${bsPrefix}-plaintext`]: true };
    }
    else {
        classes = {
            [bsPrefix]: true,
            [`${bsPrefix}-${size}`]: size,
        };
    }
    warning(controlId == null || !id, '`controlId` is ignored on `<FormControl>` when `id` is specified.');
    return (React.createElement(Component, { ...props, type: type, ref: ref, readOnly: readOnly, id: id || controlId, className: classNames(className, classes, isValid && `is-valid`, isInvalid && `is-invalid`, type === 'color' && `${bsPrefix}-color`) }));
});
FormControl.displayName = 'FormControl';
FormControl.propTypes = propTypes$7;
var FormControl$1 = Object.assign(FormControl, { Feedback, Group: FormControlGroup });

const propTypes$6 = {
    /**
     * @default 'dropdown-toggle'
     */
    bsPrefix: PropTypes.string,
    /**
     * An html id attribute, necessary for assistive technologies, such as screen readers.
     * @type {string|number}
     */
    id: PropTypes.string,
    split: PropTypes.bool,
    as: PropTypes.elementType,
    /**
     * to passthrough to the underlying button or whatever from DropdownButton
     * @private
     */
    childBsPrefix: PropTypes.string,
    setIsMenuOpen: PropTypes.func
};
const FormControlToggle = React.forwardRef(({ bsPrefix, className, childBsPrefix, setIsMenuOpen, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = FormControl$1, ...props }, ref) => {
    const prefix = 'dropdown-toggle';
    const dropdownContext = useContext(DropdownContext$1);
    const isInputGroup = useContext(context$1);
    if (childBsPrefix !== undefined) {
        props.bsPrefix = childBsPrefix;
    }
    const [toggleProps] = useDropdownToggle();
    toggleProps.ref = useMergedRefs(toggleProps.ref, useWrappedRefWithWarning(ref, 'DropdownToggle'));
    const { "aria-expanded": ariaExpanded, id, ...newToggleProps } = toggleProps;
    if (setIsMenuOpen) {
        React.useEffect(() => {
            setIsMenuOpen(dropdownContext?.show);
        }, [dropdownContext?.show]);
    }
    // This intentionally forwards size and variant (if set) to the
    // underlying component, to allow it to render size and style variants.
    return (React.createElement(Component, { className: classNames(className, prefix, !!isInputGroup && dropdownContext?.show && 'show'), ...newToggleProps, ...props }));
});
FormControlToggle.displayName = 'FormToggle';
FormControlToggle.propTypes = propTypes$6;

const DropdownContext = React.createContext({});
DropdownContext.displayName = 'DropdownContext';

const propTypes$5 = {
    /** @default 'dropdown-item' */
    bsPrefix: PropTypes.string,
    /**
     * Highlight the menu item as active.
     */
    active: PropTypes.bool,
    /**
     * Disable the menu item, making it unselectable.
     */
    disabled: PropTypes.bool,
    /**
     * Value passed to the `onSelect` handler, useful for identifying the selected menu item.
     */
    eventKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    /**
     * HTML `href` attribute corresponding to `a.href`.
     */
    href: PropTypes.string,
    /**
     * Callback fired when the menu item is clicked.
     */
    onClick: PropTypes.func,
    as: PropTypes.elementType,
};
const DropdownItem = React.forwardRef(({ bsPrefix, className, eventKey, disabled = false, onClick, active, as: Component = Anchor, ...props }, ref) => {
    const prefix = 'dropdown-item';
    const [dropdownItemProps, meta] = useDropdownItem({
        key: eventKey,
        href: props.href,
        disabled,
        onClick,
        active,
    });
    return (React.createElement("li", null,
        React.createElement(Component, { ...props, ...dropdownItemProps, ref: ref, className: classNames(className, prefix, meta.isActive && 'active', disabled && 'disabled') })));
});
DropdownItem.displayName = 'DropdownItem';
DropdownItem.propTypes = propTypes$5;

const context = React.createContext(null);
context.displayName = 'NavbarContext';

const propTypes$4 = {
    /**
     * @default 'dropdown-menu'
     */
    bsPrefix: PropTypes.string,
    /** Controls the visibility of the Dropdown menu  */
    show: PropTypes.bool,
    /** Whether to render the dropdown menu in the DOM before the first time it is shown */
    renderOnMount: PropTypes.bool,
    /** Have the dropdown switch to it's opposite placement when necessary to stay on screen. */
    flip: PropTypes.bool,
    /**
     * Aligns the dropdown menu to the specified side of the container. You can also align
     * the menu responsively for breakpoints starting at `sm` and up. The alignment
     * direction will affect the specified breakpoint or larger.
     *
     * *Note: Using responsive alignment will disable Popper usage for positioning.*
     *
     * @type {"start"|"end"|{ sm: "start"|"end" }|{ md: "start"|"end" }|{ lg: "start"|"end" }|{ xl: "start"|"end"}|{ xxl: "start"|"end"} }
     */
    align: alignPropType,
    onSelect: PropTypes.func,
    /**
     * Which event when fired outside the component will cause it to be closed
     *
     * *Note: For custom dropdown components, you will have to pass the
     * `rootCloseEvent` to `<RootCloseWrapper>` in your custom dropdown menu
     * component ([similarly to how it is implemented in `<Dropdown.Menu>`](https://github.com/react-bootstrap/react-bootstrap/blob/v0.31.5/src/DropdownMenu.js#L115-L119)).*
     */
    rootCloseEvent: PropTypes.oneOf(['click', 'mousedown']),
    /**
     * Control the rendering of the DropdownMenu. All non-menu props
     * (listed here) are passed through to the `as` Component.
     *
     * If providing a custom, non DOM, component. the `show`, `close` and `align` props
     * are also injected and should be handled appropriately.
     */
    as: PropTypes.elementType,
    /**
     * A set of popper options and props passed directly to Popper.
     */
    popperConfig: PropTypes.object,
    /**
     * Menu color variant.
     *
     * Omitting this will use the default light color.
     */
    variant: PropTypes.string,
    /** @private Provides context when used in NavDropdown component  */
    isNav: PropTypes.bool,
};
const defaultProps$2 = {
    flip: true,
};
function getDropdownMenuPlacement(alignEnd, dropDirection, isRTL) {
    const topStart = isRTL ? 'top-end' : 'top-start';
    const topEnd = isRTL ? 'top-start' : 'top-end';
    const bottomStart = isRTL ? 'bottom-end' : 'bottom-start';
    const bottomEnd = isRTL ? 'bottom-start' : 'bottom-end';
    // const leftStart = isRTL ? 'right-start' : 'left-start';
    // const leftEnd = isRTL ? 'right-end' : 'left-end';
    const rightStart = isRTL ? 'left-start' : 'right-start';
    const rightEnd = isRTL ? 'left-end' : 'right-end';
    let placement = alignEnd ? bottomEnd : bottomStart;
    if (dropDirection === 'up')
        placement = alignEnd ? topEnd : topStart;
    else if (dropDirection === 'end')
        placement = alignEnd ? rightEnd : rightStart;
    // else if (dropDirection === 'start')
    //   placement = alignEnd ? leftEnd : leftStart;
    return placement;
}
const DropdownMenu = React.forwardRef(({ bsPrefix, className, align, rootCloseEvent, flip, show: showProps, renderOnMount, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = 'ul', popperConfig, variant, isNav, ...props }, ref) => {
    let alignEnd = false;
    const isNavbar = useContext(context);
    const prefix = 'dropdown-menu';
    const { align: contextAlign, drop, isRTL } = useContext(DropdownContext);
    align = align || contextAlign;
    const isInputGroup = useContext(context$1);
    const alignClasses = [];
    if (align) {
        if (typeof align === 'object') {
            const keys = Object.keys(align);
            warning(keys.length === 1, 'There should only be 1 breakpoint when passing an object to `align`');
            if (keys.length) {
                const brkPoint = keys[0];
                const direction = align[brkPoint];
                // .dropdown-menu-end is required for responsively aligning
                // left in addition to align left classes.
                alignEnd = direction === 'start';
                alignClasses.push(`${prefix}-${brkPoint}-${direction}`);
            }
        }
        else if (align === 'end') {
            alignEnd = true;
        }
    }
    const placement = getDropdownMenuPlacement(alignEnd, drop, isRTL);
    const [menuProps, { hasShown, popper, show, toggle }] = useDropdownMenu({
        flip,
        rootCloseEvent,
        show: showProps,
        usePopper: !isNavbar && alignClasses.length === 0,
        offset: !isNav ? [0, 10] : undefined,
        popperConfig,
        placement,
    });
    menuProps.ref = useMergedRefs(useWrappedRefWithWarning(ref, 'DropdownMenu'), menuProps.ref);
    useIsomorphicEffect(() => {
        // Popper's initial position for the menu is incorrect when
        // renderOnMount=true. Need to call update() to correct it.
        if (show)
            popper?.update();
    }, [show]);
    if (!hasShown && !renderOnMount && !isInputGroup)
        return null;
    // For custom components provide additional, non-DOM, props;
    if (typeof Component !== 'string') {
        menuProps.show = show;
        menuProps.close = () => toggle?.(false);
        menuProps.align = align;
    }
    let style = props.style;
    if (popper?.placement) {
        // we don't need the default popper style,
        // menus are display: none when not shown.
        style = { ...props.style, ...menuProps.style };
        //@ts-ignore
        props['x-placement'] = popper.placement;
    }
    return (React.createElement(Component, { ...props, ...menuProps, style: style, ...((alignClasses.length || isNavbar) && {
            'data-bs-popper': 'static',
        }), className: classNames(className, prefix, show && 'show', alignEnd && `${prefix}-end`, variant && `${prefix}-${variant}`, ...alignClasses) }));
});
DropdownMenu.displayName = 'DropdownMenu';
DropdownMenu.propTypes = propTypes$4;
DropdownMenu.defaultProps = defaultProps$2;

const propTypes$3 = {
    /**
     * @default 'dropdown-toggle'
     */
    bsPrefix: PropTypes.string,
    /**
     * An html id attribute, necessary for assistive technologies, such as screen readers.
     * @type {string|number}
     */
    id: PropTypes.string,
    split: PropTypes.bool,
    as: PropTypes.elementType,
    /**
     * to passthrough to the underlying button or whatever from DropdownButton
     * @private
     */
    childBsPrefix: PropTypes.string,
};
const DropdownToggle = React.forwardRef(({ bsPrefix, split, className, childBsPrefix, 
// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
as: Component = Button, ...props }, ref) => {
    const prefix = 'dropdown-toggle';
    const dropdownContext = useContext(DropdownContext$1);
    const isInputGroup = useContext(context$1);
    if (childBsPrefix !== undefined) {
        props.bsPrefix = childBsPrefix;
    }
    const [toggleProps] = useDropdownToggle();
    toggleProps.ref = useMergedRefs(toggleProps.ref, useWrappedRefWithWarning(ref, 'DropdownToggle'));
    // This intentionally forwards size and variant (if set) to the
    // underlying component, to allow it to render size and style variants.
    return (React.createElement(Component, { className: classNames(className, prefix, split && `${prefix}-split`, !!isInputGroup && dropdownContext?.show && 'show'), variant: "outline-secondary", ...toggleProps, ...props, "aria-haspopup": "menu" }));
});
DropdownToggle.displayName = 'DropdownToggle';
DropdownToggle.propTypes = propTypes$3;

const DropdownHeader = createWithBsPrefix('dropdown-header', {
    defaultProps: { role: 'heading' },
});
const DropdownDivider = createWithBsPrefix('dropdown-divider', {
    Component: 'hr',
    defaultProps: { role: 'separator' },
});
const DropdownItemText = createWithBsPrefix('dropdown-item-text', {
    Component: 'span',
});

const propTypes$2 = {
    /** @default 'dropdown' */
    bsPrefix: PropTypes.string,
    /**
     * Determines the direction and location of the Menu in relation to it's Toggle.
     *
     * @type {"end"|"up"|"down" }
     */
    drop: PropTypes.oneOf(['up', 'end', 'down']),
    as: PropTypes.elementType,
    align: alignDirection,
    /**
     * Whether or not the Dropdown is visible.
     *
     * @controllable onToggle
     */
    show: PropTypes.bool,
    /**
     * Allow Dropdown to flip in case of an overlapping on the reference element. For more information refer to
     * Popper.js's flip [docs](https://popper.js.org/docs/v2/modifiers/flip/).
     *
     */
    flip: PropTypes.bool,
    /**
     * A callback fired when the Dropdown wishes to change visibility. Called with the requested
     * `show` value, the DOM event, and the source that fired it: `'click'`,`'keydown'`,`'rootClose'`, or `'select'`.
     *
     * ```js
     * function(
     *   isOpen: boolean,
     *   event: SyntheticEvent,
     *   metadata: {
     *     source: 'select' | 'click' | 'rootClose' | 'keydown'
     *   }
     * ): void
     * ```
     *
     * @controllable show
     */
    onToggle: PropTypes.func,
    /**
     * A callback fired when a menu item is selected.
     *
     * ```js
     * (eventKey: any, event: Object) => any
     * ```
     */
    onSelect: PropTypes.func,
    /**
     * Controls the focus behavior for when the Dropdown is opened. Set to
     * `true` to always focus the first menu item, `keyboard` to focus only when
     * navigating via the keyboard, or `false` to disable completely
     *
     * The Default behavior is `false` **unless** the Menu has a `role="menu"`
     * where it will default to `keyboard` to match the recommended [ARIA Authoring practices](https://www.w3.org/TR/wai-aria-practices-1.1/#menubutton).
     */
    focusFirstItemOnShow: PropTypes.oneOf([false, true, 'keyboard']),
    /** @private */
    navbar: PropTypes.bool,
    /**
     * Controls the auto close behaviour of the dropdown when clicking outside of
     * the button or the list.
     */
    autoClose: PropTypes.oneOf([true, 'outside', 'inside', false]),
};
const defaultProps$1 = {
    navbar: false,
    align: 'start',
    autoClose: true,
    focusFirstItemOnShow: 'keyboard',
};
const Dropdown = React.forwardRef((pProps, ref) => {
    const { bsPrefix, drop, show, className, align, onSelect, onToggle, focusFirstItemOnShow, 
    // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
    as: Component = 'div', navbar: _4, autoClose, ...props } = useUncontrolled(pProps, { show: 'onToggle' });
    const isInputGroup = useContext(context$1);
    const prefix = useBootstrapPrefix(bsPrefix, 'dropdown');
    const isRTL = useIsRTL();
    const isClosingPermitted = (source) => {
        // autoClose=false only permits close on button click
        if (autoClose === false)
            return source === 'click';
        // autoClose=inside doesn't permit close on rootClose
        if (autoClose === 'inside')
            return source !== 'rootClose';
        // autoClose=outside doesn't permit close on select
        if (autoClose === 'outside')
            return source !== 'select';
        return true;
    };
    const handleToggle = useEventCallback((nextShow, meta) => {
        if (meta.originalEvent.currentTarget === document &&
            (meta.source !== 'keydown' ||
                meta.originalEvent.key === 'Escape'))
            meta.source = 'rootClose';
        if (isClosingPermitted(meta.source))
            onToggle?.(nextShow, meta);
    });
    const alignEnd = align === 'end';
    const placement = getDropdownMenuPlacement(alignEnd, drop, isRTL);
    const contextValue = useMemo(() => ({
        align,
        drop,
        isRTL,
    }), [align, drop, isRTL]);
    return (React.createElement(DropdownContext.Provider, { value: contextValue },
        React.createElement(BaseDropdown, { placement: placement, show: show, onSelect: onSelect, onToggle: handleToggle, focusFirstItemOnShow: focusFirstItemOnShow, itemSelector: `.${prefix}-item:not(.disabled):not(:disabled)` }, isInputGroup ? (props.children) : (React.createElement(SGDSWrapper, { as: Component, ...props, ref: ref, className: classNames(className, show && 'show', prefix, drop === 'up' && 'dropup', drop === 'end' && 'dropend') })))));
});
Dropdown.displayName = 'Dropdown';
Dropdown.propTypes = propTypes$2;
Dropdown.defaultProps = defaultProps$1;
var Dropdown$1 = Object.assign(Dropdown, {
    Toggle: DropdownToggle,
    Menu: DropdownMenu,
    Item: DropdownItem,
    ItemText: DropdownItemText,
    Divider: DropdownDivider,
    Header: DropdownHeader,
});

const propTypes$1 = {
    /**
     * An html id attribute for the Toggle button, necessary for assistive technologies, such as screen readers.
     * @type {string}
     */
    id: PropTypes.string,
    /** An `href` passed to the Toggle component */
    href: PropTypes.string,
    /** An `onClick` handler passed to the Toggle component */
    onClick: PropTypes.func,
    /** The content of the non-toggle Button.  */
    title: PropTypes.node.isRequired,
    /** Disables both Buttons  */
    disabled: PropTypes.bool,
    /**
     * Aligns the dropdown menu.
     *
     * _see [DropdownMenu](#dropdown-menu-props) for more details_
     *
     * @type {"start"|"end"|{ sm: "start"|"end" }|{ md: "start"|"end" }|{ lg: "start"|"end" }|{ xl: "start"|"end"}|{ xxl: "start"|"end"} }
     */
    align: alignPropType,
    /** An ARIA accessible role applied to the Menu component. When set to 'menu', The dropdown */
    menuRole: PropTypes.string,
    /** Whether to render the dropdown menu in the DOM before the first time it is shown */
    renderMenuOnMount: PropTypes.bool,
    /**
     *  Which event when fired outside the component will cause it to be closed.
     *
     * _see [DropdownMenu](#dropdown-menu-props) for more details_
     */
    rootCloseEvent: PropTypes.string,
    /**
     * Menu color variant.
     *
     * Omitting this will use the default light color.
     */
    menuVariant: PropTypes.oneOf(['dark']),
    /** @ignore */
    bsPrefix: PropTypes.string,
    /** @ignore */
    variant: PropTypes.string,
    /** @ignore */
    size: PropTypes.string,
};
/**
 * A convenience component for simple or general use dropdowns. Renders a `Button` toggle and all `children`
 * are passed directly to the default `Dropdown.Menu`. This component accepts all of
 * [`Dropdown`'s props](#dropdown-props).
 *
 * _All unknown props are passed through to the `Dropdown` component._ Only
 * the Button `variant`, `size` and `bsPrefix` props are passed to the toggle,
 * along with menu-related props are passed to the `Dropdown.Menu`
 */
const DropdownButton = React.forwardRef(({ title, children, bsPrefix, rootCloseEvent, variant, size, menuRole, renderMenuOnMount, disabled, href, id, menuVariant, ...props }, ref) => (React.createElement(Dropdown$1, { ref: ref, ...props },
    React.createElement(DropdownToggle, { id: id, href: href, size: size, variant: variant, disabled: disabled, childBsPrefix: bsPrefix },
        title,
        React.createElement("i", { className: "bi bi-chevron-down" })),
    React.createElement(DropdownMenu, { role: menuRole, renderOnMount: renderMenuOnMount, rootCloseEvent: rootCloseEvent, variant: menuVariant }, children))));
DropdownButton.displayName = 'DropdownButton';
DropdownButton.propTypes = propTypes$1;

const propTypes = {
    initialValue: PropTypes.oneOfType([
        PropTypes.instanceOf(Date),
        PropTypes.shape({
            start: PropTypes.instanceOf(Date),
            end: PropTypes.instanceOf(Date),
        }),
    ]),
    required: PropTypes.bool,
    className: PropTypes.string,
    minDate: PropTypes.string,
    maxDate: PropTypes.string,
    displayDate: PropTypes.instanceOf(Date),
    placeholder: PropTypes.string,
    onChangeDate: PropTypes.func,
    onClear: PropTypes.func,
    onBlur: PropTypes.func,
    onFocus: PropTypes.func,
    autoFocus: PropTypes.bool,
    disabled: PropTypes.bool,
    calendarPlacement: PropTypes.oneOf(['up', 'down']),
    /**
     * dateFormat variants
     *
     * @type {('MM/DD/YYYY'|'DD/MM/YYYY'|'YYYY/MM/DD')}
     */
    dateFormat: PropTypes.string,
    id: PropTypes.string,
    /**
     * mode variants
     *
     * @type {('single'|'range')}
     */
    mode: PropTypes.string,
    flip: PropTypes.bool,
    clearBtnVariant: PropTypes.string
};
const SEPARATOR = '/';
const makeInputValueString = (date, dateFormat) => {
    if (date === undefined)
        return '';
    const month = date.getMonth() + 1;
    const day = date.getDate();
    //this method is executed during intialState setup... handle a missing state properly
    const separator = SEPARATOR;
    if (dateFormat.match(/MM.DD.YYYY/)) {
        return ((month > 9 ? month : `0${month}`) +
            separator +
            (day > 9 ? day : `0${day}`) +
            separator +
            date.getFullYear());
    }
    else if (dateFormat.match(/DD.MM.YYYY/)) {
        return ((day > 9 ? day : `0${day}`) +
            separator +
            (month > 9 ? month : `0${month}`) +
            separator +
            date.getFullYear());
    }
    else {
        return (date.getFullYear() +
            separator +
            (month > 9 ? month : `0${month}`) +
            separator +
            (day > 9 ? day : `0${day}`));
    }
};
const defaultProps = {
    dateFormat: 'DD/MM/YYYY',
    calendarPlacement: 'down',
    mode: 'single',
    displayDate: new Date(),
    flip: true,
};
const DatePicker = React.forwardRef(({ dateFormat = 'DD/MM/YYYY', calendarPlacement = 'down', mode = 'single', displayDate = new Date(), flip = true, clearBtnVariant = "primary", ...props }, ref) => {
    const isRange = mode === 'range';
    const formControlRef = useRef(null);
    const inputRef = useMergedRefs(ref, formControlRef);
    const initialState = {
        displayDate: displayDate,
        selectedDate: props.initialValue && ((isRange && !(props.initialValue instanceof Date))
            || (!isRange && props.initialValue instanceof Date))
            ? props.initialValue
            : (isRange ? { start: undefined, end: undefined } : undefined),
        invalid: false,
    };
    const [state, setState] = useState(initialState);
    const [view, setView] = useState('day');
    const contextValue = useMemo(() => ({
        view,
        setView,
    }), [view]);
    const onChangeMonth = (newDisplayDate) => {
        setState({ ...state, displayDate: newDisplayDate });
    };
    const clear = () => {
        setState({
            ...initialState,
            selectedDate: isRange ? { start: undefined, end: undefined } : undefined,
            displayDate: new Date(),
        });
        props.onClear?.();
        props.onChangeDate?.(undefined);
    };
    //triggered only when clicking dates
    const onChangeDateSingle = (newSelectedDate) => {
        setState({
            ...state,
            selectedDate: newSelectedDate,
            displayDate: newSelectedDate,
        });
        formControlRef?.current?.click();
        props.onChangeDate?.(newSelectedDate);
    };
    const onChangeDateRange = (newSelectedDate) => {
        let { start, end } = state.selectedDate;
        if ((!start && !end) || (start && end)) {
            // Selecting start date
            start = newSelectedDate;
            end = undefined;
        }
        else if (start && !end) {
            // Selecting end date
            // if selected end date is before selected start date --> swap
            if (new Date(start).getTime() > newSelectedDate.getTime()) {
                end = start;
                start = newSelectedDate;
            }
            else {
                end = newSelectedDate;
            }
        }
        const newSelectedDates = { start: start, end: end };
        setState({
            ...state,
            selectedDate: newSelectedDates,
            displayDate: newSelectedDate,
        });
        if (newSelectedDates.end) {
            formControlRef?.current?.click();
        }
        props.onChangeDate?.(newSelectedDates);
    };
    const calendarHeader = (React.createElement(CalendarHeader, { displayDate: state.displayDate, onChange: onChangeMonth }));
    const computeInputValue = () => {
        if (isRange && state.selectedDate) {
            const { start, end } = state.selectedDate;
            const separator = start ? ' - ' : '';
            return (makeInputValueString(start, dateFormat) +
                separator +
                makeInputValueString(end, dateFormat));
        }
        return makeInputValueString(state.selectedDate, dateFormat);
    };
    const defaultPlaceHolder = isRange
        ? `${dateFormat.toLowerCase()} - ${dateFormat.toLowerCase()}`
        : `${dateFormat.toLowerCase()}`;
    const controlProps = {
        value: computeInputValue(),
        required: props.required,
        placeholder: props.placeholder || defaultPlaceHolder,
        ref: inputRef,
        disabled: props.disabled,
        readOnly: true,
        className: props.className,
        isInvalid: state.invalid,
        id: props.id,
    };
    const BodyContent = () => {
        const onClickMonth = (month) => {
            const newDisplayDate = new Date(state.displayDate);
            newDisplayDate.setMonth(month);
            setView('day');
            setState({
                ...state,
                displayDate: newDisplayDate,
            });
        };
        const onClickYear = (year) => {
            const newDisplayDate = new Date(state.displayDate);
            newDisplayDate.setFullYear(year);
            setView('month');
            setState({
                ...state,
                displayDate: newDisplayDate,
            });
        };
        if (view === 'month')
            return (React.createElement(MonthView, { onClickMonth: onClickMonth, displayDate: state.displayDate }));
        if (view === 'year')
            return (React.createElement(YearView, { displayDate: state.displayDate, onClickYear: onClickYear }));
        return (React.createElement(Calendar, { selectedDate: state.selectedDate, displayDate: state.displayDate, changeDate: isRange ? onChangeDateRange : onChangeDateSingle, minDate: props.minDate, maxDate: props.maxDate, mode: mode }));
    };
    const warningCondition = () => {
        const displayDateStr = makeInputValueString(displayDate, dateFormat);
        if (isRange) {
            const { start, end } = props.initialValue;
            return (makeInputValueString(start, dateFormat) === displayDateStr ||
                makeInputValueString(end, dateFormat) === displayDateStr);
        }
        else {
            const initialValue = props.initialValue;
            return (makeInputValueString(initialValue, dateFormat) === displayDateStr);
        }
    };
    if (props.initialValue) {
        warning(warningCondition(), 'In DatePicker `single` mode, `initialValue` is `Date` type and `displayDate` prop must be of same value. In range mode, `initialValue` should be of object {start: Date, end: Date} and `displayDate` prop must be of same value as either `start` or `end`');
        if (isRange) {
            const { start, end } = props.initialValue;
            start &&
                end &&
                warning(start.getTime() <= end.getTime(), '`end` Date cannot be earlier than `start` Date');
        }
    }
    // Generation of unique id soley on client side 
    const [datepickerMenuId, setDatepickerMenuId] = useState("");
    React.useEffect(() => {
        setDatepickerMenuId(generateId('datepicker', 'ul'));
    }, []);
    return (React.createElement(context$2.Provider, { value: contextValue },
        React.createElement(Dropdown$1, { drop: calendarPlacement, className: "form-control-group input-group" },
            React.createElement(FormControlToggle, { ...controlProps, ref: formControlRef, role: "combobox", "aria-haspopup": "dialog", "aria-controls": datepickerMenuId, "aria-label": "Choose Date" }),
            React.createElement(Button, { onClick: clear, disabled: props.disabled, variant: clearBtnVariant, "aria-label": "Clear Selection" },
                React.createElement("i", { className: "bi bi-x" }),
                React.createElement("span", { className: "visually-hidden" }, "clear")),
            React.createElement("i", { className: "bi bi-calendar form-control-icon" }),
            React.createElement(Dropdown$1.Menu, { id: datepickerMenuId, className: "sgds datepicker", as: 'div', role: "dialog", "aria-modal": "true", "aria-label": "Choose Date" },
                React.createElement(Dropdown$1.Header, { className: "datepicker-header", role: "none" }, calendarHeader),
                React.createElement("div", { className: "datepicker-body" }, BodyContent())))));
});
DatePicker.displayName = 'DatePicker';
DatePicker.propTypes = propTypes;
DatePicker.defaultProps = defaultProps;

export { DatePicker };
